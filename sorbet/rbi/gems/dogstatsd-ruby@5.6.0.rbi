# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `dogstatsd-ruby` gem.
# Please instead update this file by running `bin/tapioca gem dogstatsd-ruby`.


# = Datadog::Statsd: A DogStatsd client (https://www.datadoghq.com)
#
# @example Set up a global Statsd client for a server on localhost:8125
#   require 'datadog/statsd'
#   $statsd = Datadog::Statsd.new 'localhost', 8125
# @example Send some stats
#   $statsd.increment 'page.views'
#   $statsd.timing 'page.load', 320
#   $statsd.gauge 'users.online', 100
# @example Use {#time} to time the execution of a block
#   $statsd.time('account.activate') { @account.activate! }
# @example Create a namespaced statsd client and increment 'account.activate'
#   statsd = Datadog::Statsd.new 'localhost', 8125, :namespace => 'account'
#   statsd.increment 'activate'
# @example Create a statsd client with global tags
#   statsd = Datadog::Statsd.new 'localhost', 8125, tags: 'tag1:true'
#
# source://dogstatsd-ruby//lib/datadog/statsd/connection.rb#3
module Datadog
  extend ::Datadog::Tracing::Contrib::Extensions::Helpers
  extend ::Datadog::Tracing::Contrib::Extensions::Configuration
end

# source://dogstatsd-ruby//lib/datadog/statsd/connection.rb#4
class Datadog::Statsd
  # @option [String]
  # @option [Array<String>|Hash]
  # @option [Logger]
  # @option [Integer]
  # @option [Integer]
  # @option [Integer]
  # @option [Numeric]
  # @option [String]
  # @option [Float]
  # @option [Boolean]
  # @option [Boolean]
  # @param host [String] your statsd host
  # @param port [Integer] your statsd port
  # @param [String] [Hash] a customizable set of options
  # @param [Array<String>|Hash] [Hash] a customizable set of options
  # @param [Logger] [Hash] a customizable set of options
  # @param [Integer] [Hash] a customizable set of options
  # @param [Numeric] [Hash] a customizable set of options
  # @param [Float] [Hash] a customizable set of options
  # @param [Boolean] [Hash] a customizable set of options
  # @return [Statsd] a new instance of Statsd
  #
  # source://dogstatsd-ruby//lib/datadog/statsd.rb#85
  def initialize(host = T.unsafe(nil), port = T.unsafe(nil), socket_path: T.unsafe(nil), namespace: T.unsafe(nil), tags: T.unsafe(nil), sample_rate: T.unsafe(nil), buffer_max_payload_size: T.unsafe(nil), buffer_max_pool_size: T.unsafe(nil), buffer_overflowing_stategy: T.unsafe(nil), buffer_flush_interval: T.unsafe(nil), sender_queue_size: T.unsafe(nil), logger: T.unsafe(nil), single_thread: T.unsafe(nil), delay_serialization: T.unsafe(nil), telemetry_enable: T.unsafe(nil), telemetry_flush_interval: T.unsafe(nil)); end

  # Send several metrics in the same packet.
  # They will be buffered and flushed when the block finishes.
  #
  # This method exists for compatibility with v4.x versions, it is not needed
  # anymore since the batching is now automatically done internally.
  # It also means that an automatic flush could occur if the buffer is filled
  # during the execution of the batch block.
  #
  # This method is DEPRECATED and will be removed in future v6.x API.
  #
  # @example Send several metrics in one packet:
  #   $statsd.batch do |s|
  #   s.gauge('users.online',156)
  #   s.increment('page.views')
  #   end
  # @yield [_self]
  # @yieldparam _self [Datadog::Statsd] the object that the method was called on
  #
  # source://dogstatsd-ruby//lib/datadog/statsd.rb#374
  def batch; end

  # Close the underlying socket
  #
  # @param flush [Boolean, true] Should we flush the metrics before closing
  #
  # source://dogstatsd-ruby//lib/datadog/statsd.rb#382
  def close(flush: T.unsafe(nil)); end

  # Sends an arbitrary count for the given stat to the statsd server.
  #
  # @option opts
  # @option opts
  # @option opts
  # @param stat [String] stat name
  # @param count [Integer] count
  # @param opts [Hash] the options to create the metric with
  #
  # source://dogstatsd-ruby//lib/datadog/statsd.rb#192
  def count(stat, count, opts = T.unsafe(nil)); end

  # Sends a decrement (count = -1) for the given stat to the statsd server.
  #
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param stat [String] stat name
  # @param opts [Hash] the options to create the metric with
  # @see #count
  #
  # source://dogstatsd-ruby//lib/datadog/statsd.rb#178
  def decrement(stat, opts = T.unsafe(nil)); end

  # Sends a value to be tracked as a distribution to the statsd server.
  #
  # @example Report the current user count:
  #   $statsd.distribution('user.count', User.count)
  # @option opts
  # @option opts
  # @option opts
  # @param stat [String] stat name.
  # @param value [Numeric] distribution value.
  # @param opts [Hash] the options to create the metric with
  #
  # source://dogstatsd-ruby//lib/datadog/statsd.rb#240
  def distribution(stat, value, opts = T.unsafe(nil)); end

  # Reports execution time of the provided block as a distribution.
  #
  # If the block fails, the stat is still reported, then the error
  # is reraised
  #
  # @example Report the time (in ms) taken to activate an account
  #   $statsd.distribution_time('account.activate') { @account.activate! }
  # @option opts
  # @option opts
  # @param stat [String] stat name.
  # @param value [Numeric] distribution value.
  # @param opts [Hash] the options to create the metric with
  #
  # source://dogstatsd-ruby//lib/datadog/statsd.rb#256
  def distribution_time(stat, opts = T.unsafe(nil)); end

  # This end point allows you to post events to the stream. You can tag them, set priority and even aggregate them with other events.
  #
  # Aggregation in the stream is made on hostname/event_type/source_type/aggregation_key.
  # If there's no event type, for example, then that won't matter;
  # it will be grouped with other events that don't have an event type.
  #
  # @example Report an awful event:
  #   $statsd.event('Something terrible happened', 'The end is near if we do nothing', :alert_type=>'warning', :tags=>['end_of_times','urgent'])
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param title [String] Event title
  # @param text [String] Event text. Supports newlines (+\n+)
  # @param opts [Hash] the additional data about the event
  #
  # source://dogstatsd-ruby//lib/datadog/statsd.rb#353
  def event(title, text, opts = T.unsafe(nil)); end

  # Flush the buffer into the connection
  #
  # source://dogstatsd-ruby//lib/datadog/statsd.rb#392
  def flush(flush_telemetry: T.unsafe(nil), sync: T.unsafe(nil)); end

  # Sends an arbitrary gauge value for the given stat to the statsd server.
  #
  # This is useful for recording things like available disk space,
  # memory usage, and the like, which have different semantics than
  # counters.
  #
  # @example Report the current user count:
  #   $statsd.gauge('user.count', User.count)
  # @option opts
  # @option opts
  # @option opts
  # @param stat [String] stat name.
  # @param value [Numeric] gauge value.
  # @param opts [Hash] the options to create the metric with
  #
  # source://dogstatsd-ruby//lib/datadog/statsd.rb#211
  def gauge(stat, value, opts = T.unsafe(nil)); end

  # Sends a value to be tracked as a histogram to the statsd server.
  #
  # @example Report the current user count:
  #   $statsd.histogram('user.count', User.count)
  # @option opts
  # @option opts
  # @option opts
  # @param stat [String] stat name.
  # @param value [Numeric] histogram value.
  # @param opts [Hash] the options to create the metric with
  #
  # source://dogstatsd-ruby//lib/datadog/statsd.rb#226
  def histogram(stat, value, opts = T.unsafe(nil)); end

  # source://dogstatsd-ruby//lib/datadog/statsd.rb#400
  def host; end

  # Sends an increment (count = 1) for the given stat to the statsd server.
  #
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param stat [String] stat name
  # @param opts [Hash] the options to create the metric with
  # @see #count
  #
  # source://dogstatsd-ruby//lib/datadog/statsd.rb#163
  def increment(stat, opts = T.unsafe(nil)); end

  # A namespace to prepend to all statsd calls. Defaults to no namespace.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd.rb#62
  def namespace; end

  # source://dogstatsd-ruby//lib/datadog/statsd.rb#404
  def port; end

  # Default sample rate
  #
  # source://dogstatsd-ruby//lib/datadog/statsd.rb#70
  def sample_rate; end

  # @example Report a critical service check status
  #   $statsd.service_check('my.service.check', Statsd::CRITICAL, :tags=>['urgent'])
  #
  # source://dogstatsd-ruby//lib/datadog/statsd.rb#328
  def service_check(name, status, opts = T.unsafe(nil)); end

  # Sends a value to be tracked as a set to the statsd server.
  #
  # @example Record a unique visitory by id:
  #   $statsd.set('visitors.uniques', User.id)
  # @option opts
  # @option opts
  # @option opts
  # @param stat [String] stat name.
  # @param value [Numeric] set value.
  # @param opts [Hash] the options to create the metric with
  #
  # source://dogstatsd-ruby//lib/datadog/statsd.rb#312
  def set(stat, value, opts = T.unsafe(nil)); end

  # source://dogstatsd-ruby//lib/datadog/statsd.rb#408
  def socket_path; end

  # source://dogstatsd-ruby//lib/datadog/statsd.rb#387
  def sync_with_outbound_io; end

  # Global tags to be added to every statsd call. Defaults to no tags.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd.rb#65
  def tags; end

  # source://dogstatsd-ruby//lib/datadog/statsd.rb#396
  def telemetry; end

  # Reports execution time of the provided block using {#timing}.
  #
  # If the block fails, the stat is still reported, then the error
  # is reraised
  #
  # @example Report the time (in ms) taken to activate an account
  #   $statsd.time('account.activate') { @account.activate! }
  # @option opts
  # @option opts
  # @option opts
  # @param stat [String] stat name
  # @param opts [Hash] the options to create the metric with
  # @see #timing
  # @yield The operation to be timed
  #
  # source://dogstatsd-ruby//lib/datadog/statsd.rb#294
  def time(stat, opts = T.unsafe(nil)); end

  # Sends a timing (in ms) for the given stat to the statsd server. The
  # sample_rate determines what percentage of the time this report is sent. The
  # statsd server then uses the sample_rate to correctly track the average
  # timing for the stat.
  #
  # @option opts
  # @option opts
  # @option opts
  # @param stat [String] stat name
  # @param ms [Integer] timing in milliseconds
  # @param opts [Hash] the options to create the metric with
  #
  # source://dogstatsd-ruby//lib/datadog/statsd.rb#275
  def timing(stat, ms, opts = T.unsafe(nil)); end

  # source://dogstatsd-ruby//lib/datadog/statsd.rb#412
  def transport_type; end

  private

  # Returns the value of attribute forwarder.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd.rb#418
  def forwarder; end

  # source://dogstatsd-ruby//lib/datadog/statsd.rb#422
  def now; end

  # source://dogstatsd-ruby//lib/datadog/statsd.rb#426
  def send_stats(stat, delta, type, opts = T.unsafe(nil)); end

  # Returns the value of attribute serializer.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd.rb#417
  def serializer; end

  class << self
    # yield a new instance to a block and close it when done
    # for short-term use-cases that don't want to close the socket manually
    # TODO: replace with ... once we are on ruby 2.7
    #
    # source://dogstatsd-ruby//lib/datadog/statsd.rb#146
    def open(*args, **kwargs); end
  end
end

# source://dogstatsd-ruby//lib/datadog/statsd.rb#54
Datadog::Statsd::COUNTER_TYPE = T.let(T.unsafe(nil), String)

# source://dogstatsd-ruby//lib/datadog/statsd.rb#39
Datadog::Statsd::CRITICAL = T.let(T.unsafe(nil), Integer)

# source://dogstatsd-ruby//lib/datadog/statsd/connection.rb#5
class Datadog::Statsd::Connection
  # @return [Connection] a new instance of Connection
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/connection.rb#6
  def initialize(telemetry: T.unsafe(nil), logger: T.unsafe(nil)); end

  # source://dogstatsd-ruby//lib/datadog/statsd/connection.rb#11
  def reset_telemetry; end

  # not thread safe: `Sender` instances that use this are required to properly synchronize or sequence calls to this method
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/connection.rb#16
  def write(payload); end

  private

  # source://dogstatsd-ruby//lib/datadog/statsd/connection.rb#55
  def close; end

  # source://dogstatsd-ruby//lib/datadog/statsd/connection.rb#51
  def connect; end

  # Returns the value of attribute logger.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/connection.rb#49
  def logger; end

  # Returns the value of attribute telemetry.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/connection.rb#48
  def telemetry; end
end

# source://dogstatsd-ruby//lib/datadog/statsd/connection_cfg.rb#3
class Datadog::Statsd::ConnectionCfg
  # @return [ConnectionCfg] a new instance of ConnectionCfg
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/connection_cfg.rb#9
  def initialize(host: T.unsafe(nil), port: T.unsafe(nil), socket_path: T.unsafe(nil)); end

  # Returns the value of attribute host.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/connection_cfg.rb#4
  def host; end

  # source://dogstatsd-ruby//lib/datadog/statsd/connection_cfg.rb#15
  def make_connection(**params); end

  # Returns the value of attribute port.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/connection_cfg.rb#5
  def port; end

  # Returns the value of attribute socket_path.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/connection_cfg.rb#6
  def socket_path; end

  # Returns the value of attribute transport_type.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/connection_cfg.rb#7
  def transport_type; end

  private

  # source://dogstatsd-ruby//lib/datadog/statsd/connection_cfg.rb#42
  def initialize_with_constructor_args(host: T.unsafe(nil), port: T.unsafe(nil), socket_path: T.unsafe(nil)); end

  # source://dogstatsd-ruby//lib/datadog/statsd/connection_cfg.rb#60
  def initialize_with_defaults; end

  # source://dogstatsd-ruby//lib/datadog/statsd/connection_cfg.rb#50
  def initialize_with_env_vars; end

  # @raise [ArgumentError]
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/connection_cfg.rb#90
  def parse_dogstatsd_url(str:); end

  # source://dogstatsd-ruby//lib/datadog/statsd/connection_cfg.rb#64
  def try_initialize_with(dogstatsd_url: T.unsafe(nil), host: T.unsafe(nil), port: T.unsafe(nil), socket_path: T.unsafe(nil), error_message: T.unsafe(nil)); end
end

# source://dogstatsd-ruby//lib/datadog/statsd/connection_cfg.rb#36
Datadog::Statsd::ConnectionCfg::DEFAULT_HOST = T.let(T.unsafe(nil), String)

# source://dogstatsd-ruby//lib/datadog/statsd/connection_cfg.rb#37
Datadog::Statsd::ConnectionCfg::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)

# source://dogstatsd-ruby//lib/datadog/statsd/connection_cfg.rb#26
Datadog::Statsd::ConnectionCfg::ERROR_MESSAGE = T.let(T.unsafe(nil), String)

# source://dogstatsd-ruby//lib/datadog/statsd/connection_cfg.rb#39
Datadog::Statsd::ConnectionCfg::UDP_PREFIX = T.let(T.unsafe(nil), String)

# source://dogstatsd-ruby//lib/datadog/statsd/connection_cfg.rb#40
Datadog::Statsd::ConnectionCfg::UDS_PREFIX = T.let(T.unsafe(nil), String)

# source://dogstatsd-ruby//lib/datadog/statsd.rb#44
Datadog::Statsd::DEFAULT_BUFFER_POOL_SIZE = T.let(T.unsafe(nil), Float)

# minimum flush interval for the telemetry in seconds
#
# source://dogstatsd-ruby//lib/datadog/statsd.rb#52
Datadog::Statsd::DEFAULT_TELEMETRY_FLUSH_INTERVAL = T.let(T.unsafe(nil), Integer)

# source://dogstatsd-ruby//lib/datadog/statsd.rb#57
Datadog::Statsd::DISTRIBUTION_TYPE = T.let(T.unsafe(nil), String)

# source://dogstatsd-ruby//lib/datadog/statsd.rb#420
Datadog::Statsd::EMPTY_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://dogstatsd-ruby//lib/datadog/statsd.rb#34
class Datadog::Statsd::Error < ::StandardError; end

# source://dogstatsd-ruby//lib/datadog/statsd/forwarder.rb#5
class Datadog::Statsd::Forwarder
  # @return [Forwarder] a new instance of Forwarder
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/forwarder.rb#9
  def initialize(serializer:, connection_cfg: T.unsafe(nil), buffer_max_payload_size: T.unsafe(nil), buffer_max_pool_size: T.unsafe(nil), buffer_overflowing_stategy: T.unsafe(nil), buffer_flush_interval: T.unsafe(nil), sender_queue_size: T.unsafe(nil), telemetry_flush_interval: T.unsafe(nil), global_tags: T.unsafe(nil), single_thread: T.unsafe(nil), logger: T.unsafe(nil)); end

  # source://dogstatsd-ruby//lib/datadog/statsd/forwarder.rb#113
  def close; end

  # source://dogstatsd-ruby//lib/datadog/statsd/forwarder.rb#89
  def flush(flush_telemetry: T.unsafe(nil), sync: T.unsafe(nil)); end

  # source://dogstatsd-ruby//lib/datadog/statsd/forwarder.rb#95
  def host; end

  # source://dogstatsd-ruby//lib/datadog/statsd/forwarder.rb#101
  def port; end

  # source://dogstatsd-ruby//lib/datadog/statsd/forwarder.rb#79
  def send_message(message); end

  # source://dogstatsd-ruby//lib/datadog/statsd/forwarder.rb#107
  def socket_path; end

  # source://dogstatsd-ruby//lib/datadog/statsd/forwarder.rb#85
  def sync_with_outbound_io; end

  # Returns the value of attribute telemetry.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/forwarder.rb#6
  def telemetry; end

  # Returns the value of attribute transport_type.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/forwarder.rb#7
  def transport_type; end

  private

  # Returns the value of attribute connection.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/forwarder.rb#120
  def connection; end

  # source://dogstatsd-ruby//lib/datadog/statsd/forwarder.rb#122
  def do_flush_telemetry; end

  # Returns the value of attribute sender.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/forwarder.rb#119
  def sender; end

  # source://dogstatsd-ruby//lib/datadog/statsd/forwarder.rb#131
  def tick_telemetry; end
end

# source://dogstatsd-ruby//lib/datadog/statsd.rb#55
Datadog::Statsd::GAUGE_TYPE = T.let(T.unsafe(nil), String)

# source://dogstatsd-ruby//lib/datadog/statsd.rb#56
Datadog::Statsd::HISTOGRAM_TYPE = T.let(T.unsafe(nil), String)

# source://dogstatsd-ruby//lib/datadog/statsd.rb#49
Datadog::Statsd::MAX_EVENT_SIZE = T.let(T.unsafe(nil), Integer)

# source://dogstatsd-ruby//lib/datadog/statsd/message_buffer.rb#5
class Datadog::Statsd::MessageBuffer
  # @raise [ArgumentError]
  # @return [MessageBuffer] a new instance of MessageBuffer
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/message_buffer.rb#8
  def initialize(connection, serializer:, max_payload_size: T.unsafe(nil), max_pool_size: T.unsafe(nil), overflowing_stategy: T.unsafe(nil)); end

  # source://dogstatsd-ruby//lib/datadog/statsd/message_buffer.rb#27
  def add(message); end

  # source://dogstatsd-ruby//lib/datadog/statsd/message_buffer.rb#58
  def flush; end

  # source://dogstatsd-ruby//lib/datadog/statsd/message_buffer.rb#53
  def reset; end

  private

  # Returns the value of attribute buffer.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/message_buffer.rb#73
  def buffer; end

  # source://dogstatsd-ruby//lib/datadog/statsd/message_buffer.rb#100
  def bytesize_threshold; end

  # source://dogstatsd-ruby//lib/datadog/statsd/message_buffer.rb#81
  def clear_buffer; end

  # Returns the value of attribute connection.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/message_buffer.rb#72
  def connection; end

  # source://dogstatsd-ruby//lib/datadog/statsd/message_buffer.rb#90
  def ensure_sendable!(message_size); end

  # Returns the value of attribute max_payload_size.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/message_buffer.rb#67
  def max_payload_size; end

  # Returns the value of attribute max_pool_size.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/message_buffer.rb#68
  def max_pool_size; end

  # Returns the value of attribute overflowing_stategy.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/message_buffer.rb#70
  def overflowing_stategy; end

  # @return [Boolean]
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/message_buffer.rb#86
  def preemptive_flush?; end

  # @return [Boolean]
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/message_buffer.rb#75
  def should_flush?(message_size); end
end

# source://dogstatsd-ruby//lib/datadog/statsd/message_buffer.rb#6
Datadog::Statsd::MessageBuffer::PAYLOAD_SIZE_TOLERANCE = T.let(T.unsafe(nil), Float)

# source://dogstatsd-ruby//lib/datadog/statsd.rb#37
Datadog::Statsd::OK = T.let(T.unsafe(nil), Integer)

# source://dogstatsd-ruby//lib/datadog/statsd.rb#59
Datadog::Statsd::SET_TYPE = T.let(T.unsafe(nil), String)

# Sender is using a companion thread to flush and pack messages
# in a `MessageBuffer`.
# The communication with this thread is done using a `Queue`.
# If the thread is dead, it is starting a new one to avoid having a blocked
# Sender with no companion thread to communicate with (most of the time, having
# a dead companion thread means that a fork just happened and that we are
# running in the child process).
#
# source://dogstatsd-ruby//lib/datadog/statsd/sender.rb#12
class Datadog::Statsd::Sender
  # @return [Sender] a new instance of Sender
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/sender.rb#15
  def initialize(message_buffer, telemetry: T.unsafe(nil), queue_size: T.unsafe(nil), logger: T.unsafe(nil), flush_interval: T.unsafe(nil), queue_class: T.unsafe(nil), thread_class: T.unsafe(nil)); end

  # @raise [ArgumentError]
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/sender.rb#63
  def add(message); end

  # source://dogstatsd-ruby//lib/datadog/statsd/sender.rb#30
  def flush(sync: T.unsafe(nil)); end

  # source://dogstatsd-ruby//lib/datadog/statsd/sender.rb#49
  def rendez_vous; end

  # @raise [ArgumentError]
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/sender.rb#94
  def start; end

  # when calling stop, make sure that no other threads is trying
  # to close the sender nor trying to continue to `#add` more message
  # into the sender.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/sender.rb#109
  def stop(join_worker: T.unsafe(nil)); end

  private

  # Returns the value of attribute message_buffer.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/sender.rb#135
  def message_buffer; end

  # Returns the value of attribute message_queue.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/sender.rb#136
  def message_queue; end

  # source://dogstatsd-ruby//lib/datadog/statsd/sender.rb#140
  def send_loop; end

  # Returns the value of attribute sender_thread.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/sender.rb#137
  def sender_thread; end
end

# source://dogstatsd-ruby//lib/datadog/statsd/sender.rb#13
Datadog::Statsd::Sender::CLOSEABLE_QUEUES = T.let(T.unsafe(nil), TrueClass)

# source://dogstatsd-ruby//lib/datadog/statsd/serialization.rb#5
module Datadog::Statsd::Serialization; end

# source://dogstatsd-ruby//lib/datadog/statsd/serialization/event_serializer.rb#6
class Datadog::Statsd::Serialization::EventSerializer
  # @return [EventSerializer] a new instance of EventSerializer
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/serialization/event_serializer.rb#16
  def initialize(global_tags: T.unsafe(nil)); end

  # source://dogstatsd-ruby//lib/datadog/statsd/serialization/event_serializer.rb#20
  def format(title, text, options = T.unsafe(nil)); end

  protected

  # source://dogstatsd-ruby//lib/datadog/statsd/serialization/event_serializer.rb#63
  def escape(text); end

  # Returns the value of attribute tag_serializer.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/serialization/event_serializer.rb#61
  def tag_serializer; end
end

# source://dogstatsd-ruby//lib/datadog/statsd/serialization/event_serializer.rb#7
Datadog::Statsd::Serialization::EventSerializer::EVENT_BASIC_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://dogstatsd-ruby//lib/datadog/statsd/serialization/serializer.rb#8
class Datadog::Statsd::Serialization::Serializer
  # @return [Serializer] a new instance of Serializer
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/serialization/serializer.rb#9
  def initialize(prefix: T.unsafe(nil), global_tags: T.unsafe(nil)); end

  # source://dogstatsd-ruby//lib/datadog/statsd/serialization/serializer.rb#30
  def global_tags; end

  # using *args would make new allocations
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/serialization/serializer.rb#26
  def to_event(title, text, options = T.unsafe(nil)); end

  # using *args would make new allocations
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/serialization/serializer.rb#21
  def to_service_check(name, status, options = T.unsafe(nil)); end

  # using *args would make new allocations
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/serialization/serializer.rb#16
  def to_stat(name, delta, type, tags: T.unsafe(nil), sample_rate: T.unsafe(nil)); end

  protected

  # Returns the value of attribute event_serializer.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/serialization/serializer.rb#37
  def event_serializer; end

  # Returns the value of attribute service_check_serializer.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/serialization/serializer.rb#36
  def service_check_serializer; end

  # Returns the value of attribute stat_serializer.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/serialization/serializer.rb#35
  def stat_serializer; end
end

# source://dogstatsd-ruby//lib/datadog/statsd/serialization/service_check_serializer.rb#6
class Datadog::Statsd::Serialization::ServiceCheckSerializer
  # @return [ServiceCheckSerializer] a new instance of ServiceCheckSerializer
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/serialization/service_check_serializer.rb#12
  def initialize(global_tags: T.unsafe(nil)); end

  # source://dogstatsd-ruby//lib/datadog/statsd/serialization/service_check_serializer.rb#16
  def format(name, status, options = T.unsafe(nil)); end

  protected

  # source://dogstatsd-ruby//lib/datadog/statsd/serialization/service_check_serializer.rb#51
  def escape_message(message); end

  # Returns the value of attribute tag_serializer.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/serialization/service_check_serializer.rb#49
  def tag_serializer; end
end

# source://dogstatsd-ruby//lib/datadog/statsd/serialization/service_check_serializer.rb#7
Datadog::Statsd::Serialization::ServiceCheckSerializer::SERVICE_CHECK_BASIC_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://dogstatsd-ruby//lib/datadog/statsd/serialization/stat_serializer.rb#6
class Datadog::Statsd::Serialization::StatSerializer
  # @return [StatSerializer] a new instance of StatSerializer
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/serialization/stat_serializer.rb#7
  def initialize(prefix, global_tags: T.unsafe(nil)); end

  # source://dogstatsd-ruby//lib/datadog/statsd/serialization/stat_serializer.rb#13
  def format(name, delta, type, tags: T.unsafe(nil), sample_rate: T.unsafe(nil)); end

  # source://dogstatsd-ruby//lib/datadog/statsd/serialization/stat_serializer.rb#31
  def global_tags; end

  private

  # source://dogstatsd-ruby//lib/datadog/statsd/serialization/stat_serializer.rb#40
  def formated_name(name); end

  # Returns the value of attribute prefix.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/serialization/stat_serializer.rb#37
  def prefix; end

  # Returns the value of attribute tag_serializer.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/serialization/stat_serializer.rb#38
  def tag_serializer; end
end

# source://dogstatsd-ruby//lib/datadog/statsd/serialization/tag_serializer.rb#6
class Datadog::Statsd::Serialization::TagSerializer
  # @return [TagSerializer] a new instance of TagSerializer
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/serialization/tag_serializer.rb#7
  def initialize(global_tags = T.unsafe(nil), env = T.unsafe(nil)); end

  # source://dogstatsd-ruby//lib/datadog/statsd/serialization/tag_serializer.rb#23
  def format(message_tags); end

  # Returns the value of attribute global_tags.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/serialization/tag_serializer.rb#37
  def global_tags; end

  private

  # source://dogstatsd-ruby//lib/datadog/statsd/serialization/tag_serializer.rb#79
  def dd_tags(env = T.unsafe(nil)); end

  # source://dogstatsd-ruby//lib/datadog/statsd/serialization/tag_serializer.rb#85
  def default_tags(env = T.unsafe(nil)); end

  # source://dogstatsd-ruby//lib/datadog/statsd/serialization/tag_serializer.rb#75
  def escape_tag_content(tag); end

  # source://dogstatsd-ruby//lib/datadog/statsd/serialization/tag_serializer.rb#41
  def to_tags_hash(tags); end

  # source://dogstatsd-ruby//lib/datadog/statsd/serialization/tag_serializer.rb#58
  def to_tags_list(tags); end
end

# The SingleThreadSender is a sender synchronously buffering messages
# in a `MessageBuffer`.
# It is using current Process.PID to check it is the result of a recent fork
# and it is reseting the MessageBuffer if that's the case.
#
# source://dogstatsd-ruby//lib/datadog/statsd/single_thread_sender.rb#9
class Datadog::Statsd::SingleThreadSender
  # @return [SingleThreadSender] a new instance of SingleThreadSender
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/single_thread_sender.rb#10
  def initialize(message_buffer, logger: T.unsafe(nil), flush_interval: T.unsafe(nil), queue_size: T.unsafe(nil)); end

  # source://dogstatsd-ruby//lib/datadog/statsd/single_thread_sender.rb#25
  def add(message); end

  # source://dogstatsd-ruby//lib/datadog/statsd/single_thread_sender.rb#43
  def flush(*_arg0); end

  # Compatibility with `Sender`
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/single_thread_sender.rb#59
  def rendez_vous; end

  # source://dogstatsd-ruby//lib/datadog/statsd/single_thread_sender.rb#50
  def start; end

  # source://dogstatsd-ruby//lib/datadog/statsd/single_thread_sender.rb#54
  def stop; end

  private

  # source://dogstatsd-ruby//lib/datadog/statsd/single_thread_sender.rb#64
  def drain_message_queue; end

  # below are "fork management" methods to be able to clean the MessageBuffer
  # if it detects that it is running in a unknown PID.
  #
  # @return [Boolean]
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/single_thread_sender.rb#73
  def forked?; end

  # source://dogstatsd-ruby//lib/datadog/statsd/single_thread_sender.rb#77
  def update_fork_pid; end
end

# source://dogstatsd-ruby//lib/datadog/statsd.rb#58
Datadog::Statsd::TIMING_TYPE = T.let(T.unsafe(nil), String)

# source://dogstatsd-ruby//lib/datadog/statsd/telemetry.rb#6
class Datadog::Statsd::Telemetry
  # bytes
  #
  # @return [Telemetry] a new instance of Telemetry
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/telemetry.rb#22
  def initialize(flush_interval, global_tags: T.unsafe(nil), transport_type: T.unsafe(nil)); end

  # Returns the value of attribute bytes_dropped.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/telemetry.rb#11
  def bytes_dropped; end

  # Returns the value of attribute bytes_dropped_queue.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/telemetry.rb#12
  def bytes_dropped_queue; end

  # Returns the value of attribute bytes_dropped_writer.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/telemetry.rb#13
  def bytes_dropped_writer; end

  # Returns the value of attribute bytes_sent.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/telemetry.rb#10
  def bytes_sent; end

  # source://dogstatsd-ruby//lib/datadog/statsd/telemetry.rb#65
  def dropped_queue(bytes: T.unsafe(nil), packets: T.unsafe(nil)); end

  # source://dogstatsd-ruby//lib/datadog/statsd/telemetry.rb#72
  def dropped_writer(bytes: T.unsafe(nil), packets: T.unsafe(nil)); end

  # Returns the value of attribute events.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/telemetry.rb#8
  def events; end

  # source://dogstatsd-ruby//lib/datadog/statsd/telemetry.rb#83
  def flush; end

  # Returns the value of attribute metrics.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/telemetry.rb#7
  def metrics; end

  # Returns the value of attribute packets_dropped.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/telemetry.rb#15
  def packets_dropped; end

  # Returns the value of attribute packets_dropped_queue.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/telemetry.rb#16
  def packets_dropped_queue; end

  # Returns the value of attribute packets_dropped_writer.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/telemetry.rb#17
  def packets_dropped_writer; end

  # Returns the value of attribute packets_sent.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/telemetry.rb#14
  def packets_sent; end

  # source://dogstatsd-ruby//lib/datadog/statsd/telemetry.rb#41
  def reset; end

  # source://dogstatsd-ruby//lib/datadog/statsd/telemetry.rb#56
  def sent(metrics: T.unsafe(nil), events: T.unsafe(nil), service_checks: T.unsafe(nil), bytes: T.unsafe(nil), packets: T.unsafe(nil)); end

  # Returns the value of attribute service_checks.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/telemetry.rb#9
  def service_checks; end

  # @return [Boolean]
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/telemetry.rb#79
  def should_flush?; end

  # @return [Boolean]
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/telemetry.rb#37
  def would_fit_in?(max_buffer_payload_size); end

  private

  # source://dogstatsd-ruby//lib/datadog/statsd/telemetry.rb#107
  def now_in_s; end

  # source://dogstatsd-ruby//lib/datadog/statsd/telemetry.rb#102
  def pattern; end

  # Returns the value of attribute serialized_tags.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/telemetry.rb#100
  def serialized_tags; end
end

# Rough estimation of maximum telemetry message size without tags
#
# source://dogstatsd-ruby//lib/datadog/statsd/telemetry.rb#20
Datadog::Statsd::Telemetry::MAX_TELEMETRY_MESSAGE_SIZE_WT_TAGS = T.let(T.unsafe(nil), Integer)

# source://dogstatsd-ruby//lib/datadog/statsd/timer.rb#5
class Datadog::Statsd::Timer
  # @return [Timer] a new instance of Timer
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/timer.rb#6
  def initialize(interval, &callback); end

  # source://dogstatsd-ruby//lib/datadog/statsd/timer.rb#15
  def start; end

  # source://dogstatsd-ruby//lib/datadog/statsd/timer.rb#33
  def stop; end

  # @return [Boolean]
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/timer.rb#44
  def stop?; end

  private

  # source://dogstatsd-ruby//lib/datadog/statsd/timer.rb#51
  def current_time; end
end

# source://dogstatsd-ruby//lib/datadog/statsd/udp_connection.rb#7
class Datadog::Statsd::UDPConnection < ::Datadog::Statsd::Connection
  # @return [UDPConnection] a new instance of UDPConnection
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/udp_connection.rb#14
  def initialize(host, port, **kwargs); end

  # source://dogstatsd-ruby//lib/datadog/statsd/udp_connection.rb#22
  def close; end

  # StatsD host.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/udp_connection.rb#9
  def host; end

  # StatsD port.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/udp_connection.rb#12
  def port; end

  private

  # source://dogstatsd-ruby//lib/datadog/statsd/udp_connection.rb#29
  def connect; end

  # send_message is writing the message in the socket, it may create the socket if nil
  # It is not thread-safe but since it is called by either the Sender bg thread or the
  # SingleThreadSender (which is using a mutex while Flushing), only one thread must call
  # it at a time.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/udp_connection.rb#40
  def send_message(message); end
end

# source://dogstatsd-ruby//lib/datadog/statsd.rb#42
Datadog::Statsd::UDP_DEFAULT_BUFFER_SIZE = T.let(T.unsafe(nil), Integer)

# source://dogstatsd-ruby//lib/datadog/statsd.rb#46
Datadog::Statsd::UDP_DEFAULT_SENDER_QUEUE_SIZE = T.let(T.unsafe(nil), Integer)

# source://dogstatsd-ruby//lib/datadog/statsd/uds_connection.rb#7
class Datadog::Statsd::UDSConnection < ::Datadog::Statsd::Connection
  # @return [UDSConnection] a new instance of UDSConnection
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/uds_connection.rb#13
  def initialize(socket_path, **kwargs); end

  # source://dogstatsd-ruby//lib/datadog/statsd/uds_connection.rb#20
  def close; end

  # DogStatsd unix socket path
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/uds_connection.rb#11
  def socket_path; end

  private

  # source://dogstatsd-ruby//lib/datadog/statsd/uds_connection.rb#27
  def connect; end

  # send_message is writing the message in the socket, it may create the socket if nil
  # It is not thread-safe but since it is called by either the Sender bg thread or the
  # SingleThreadSender (which is using a mutex while Flushing), only one thread must call
  # it at a time.
  #
  # source://dogstatsd-ruby//lib/datadog/statsd/uds_connection.rb#38
  def send_message(message); end
end

# source://dogstatsd-ruby//lib/datadog/statsd/uds_connection.rb#8
class Datadog::Statsd::UDSConnection::BadSocketError < ::StandardError; end

# source://dogstatsd-ruby//lib/datadog/statsd.rb#43
Datadog::Statsd::UDS_DEFAULT_BUFFER_SIZE = T.let(T.unsafe(nil), Integer)

# source://dogstatsd-ruby//lib/datadog/statsd.rb#47
Datadog::Statsd::UDS_DEFAULT_SENDER_QUEUE_SIZE = T.let(T.unsafe(nil), Integer)

# source://dogstatsd-ruby//lib/datadog/statsd.rb#40
Datadog::Statsd::UNKNOWN = T.let(T.unsafe(nil), Integer)

# source://dogstatsd-ruby//lib/datadog/statsd/version.rb#7
Datadog::Statsd::VERSION = T.let(T.unsafe(nil), String)

# source://dogstatsd-ruby//lib/datadog/statsd.rb#38
Datadog::Statsd::WARNING = T.let(T.unsafe(nil), Integer)

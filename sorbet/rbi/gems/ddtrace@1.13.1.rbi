# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `ddtrace` gem.
# Please instead update this file by running `bin/tapioca gem ddtrace`.


# source://ddtrace//lib/ddtrace/version.rb#3
module DDTrace; end

# source://ddtrace//lib/ddtrace/version.rb#4
module DDTrace::VERSION; end

# source://ddtrace//lib/ddtrace/version.rb#9
DDTrace::VERSION::BUILD = T.let(T.unsafe(nil), T.untyped)

# source://ddtrace//lib/ddtrace/version.rb#5
DDTrace::VERSION::MAJOR = T.let(T.unsafe(nil), Integer)

# Restrict the installation of this gem with untested future versions of Ruby.
#
# This prevents crashes in the native extension code and sends a clear signal to the
# user that this version of the gem is untested for the host Ruby version.
#
# To allow testing with the next unreleased version of Ruby, the version check is performed
# as `< #{MAXIMUM_RUBY_VERSION}`, meaning prereleases of MAXIMUM_RUBY_VERSION are allowed
# but not stable MAXIMUM_RUBY_VERSION releases.
#
# source://ddtrace//lib/ddtrace/version.rb#24
DDTrace::VERSION::MAXIMUM_RUBY_VERSION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/ddtrace/version.rb#14
DDTrace::VERSION::MINIMUM_RUBY_VERSION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/ddtrace/version.rb#6
DDTrace::VERSION::MINOR = T.let(T.unsafe(nil), Integer)

# source://ddtrace//lib/ddtrace/version.rb#7
DDTrace::VERSION::PATCH = T.let(T.unsafe(nil), Integer)

# source://ddtrace//lib/ddtrace/version.rb#8
DDTrace::VERSION::PRE = T.let(T.unsafe(nil), T.untyped)

# PRE and BUILD above are modified for dev gems during gem build GHA workflow
#
# source://ddtrace//lib/ddtrace/version.rb#12
DDTrace::VERSION::STRING = T.let(T.unsafe(nil), String)

# NOTE: This code is copied directly from Redis.
#       Its purpose is to resolve connection information.
#       It exists here only because it doesn't exist in the redis
#       library as a separated module and it allows to avoid
#       instantiating a new Redis::Client for resolving the connection
#
# source://ddtrace//lib/datadog/core/environment/variable_helpers.rb#3
module Datadog
  extend ::Datadog::Core::Extensions
  extend ::Datadog::Core::Configuration
  extend ::Datadog::Tracing::Contrib::Extensions::Helpers
  extend ::Datadog::Tracing::Contrib::Extensions::Configuration
end

# Namespace for Datadog AppSec instrumentation
#
# source://ddtrace//lib/datadog/appsec/processor/rule_merger.rb#4
module Datadog::AppSec
  class << self
    # source://ddtrace//lib/datadog/appsec.rb#16
    def active_scope; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/appsec.rb#12
    def enabled?; end

    # source://ddtrace//lib/datadog/appsec.rb#20
    def processor; end

    # source://ddtrace//lib/datadog/appsec.rb#26
    def reconfigure(ruleset:); end

    # source://ddtrace//lib/datadog/appsec.rb#34
    def reconfigure_lock(&block); end

    private

    # source://ddtrace//lib/datadog/appsec.rb#44
    def components; end
  end
end

# Helper methods to get vendored assets
#
# source://ddtrace//lib/datadog/appsec/assets.rb#6
module Datadog::AppSec::Assets
  private

  # source://ddtrace//lib/datadog/appsec/assets.rb#13
  def blocked(format: T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/appsec/assets.rb#29
  def dir; end

  # source://ddtrace//lib/datadog/appsec/assets.rb#21
  def filepath(filename); end

  # source://ddtrace//lib/datadog/appsec/assets.rb#17
  def path; end

  # source://ddtrace//lib/datadog/appsec/assets.rb#25
  def read(filename, mode = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/appsec/assets.rb#9
  def waf_rules(kind = T.unsafe(nil)); end

  class << self
    # source://ddtrace//lib/datadog/appsec/assets.rb#13
    def blocked(format: T.unsafe(nil)); end

    # source://ddtrace//lib/datadog/appsec/assets.rb#29
    def dir; end

    # source://ddtrace//lib/datadog/appsec/assets.rb#21
    def filepath(filename); end

    # source://ddtrace//lib/datadog/appsec/assets.rb#17
    def path; end

    # source://ddtrace//lib/datadog/appsec/assets.rb#25
    def read(filename, mode = T.unsafe(nil)); end

    # source://ddtrace//lib/datadog/appsec/assets.rb#9
    def waf_rules(kind = T.unsafe(nil)); end
  end
end

# Core-pluggable component for AppSec
#
# source://ddtrace//lib/datadog/appsec/component.rb#10
class Datadog::AppSec::Component
  # @return [Component] a new instance of Component
  #
  # source://ddtrace//lib/datadog/appsec/component.rb#53
  def initialize(processor:); end

  # Returns the value of attribute processor.
  #
  # source://ddtrace//lib/datadog/appsec/component.rb#51
  def processor; end

  # source://ddtrace//lib/datadog/appsec/component.rb#58
  def reconfigure(ruleset:); end

  # source://ddtrace//lib/datadog/appsec/component.rb#70
  def reconfigure_lock(&block); end

  # source://ddtrace//lib/datadog/appsec/component.rb#74
  def shutdown!; end

  class << self
    # source://ddtrace//lib/datadog/appsec/component.rb#12
    def build_appsec_component(settings); end

    private

    # source://ddtrace//lib/datadog/appsec/component.rb#30
    def create_processor(settings); end
  end
end

# Configuration for AppSec
#
# source://ddtrace//lib/datadog/appsec/configuration/settings.rb#7
module Datadog::AppSec::Configuration; end

# Settings
#
# source://ddtrace//lib/datadog/appsec/configuration/settings.rb#9
module Datadog::AppSec::Configuration::Settings
  class << self
    # source://ddtrace//lib/datadog/appsec/configuration/settings.rb#25
    def add_settings!(base); end

    # @private
    #
    # source://ddtrace//lib/datadog/appsec/configuration/settings.rb#19
    def extended(base); end
  end
end

# source://ddtrace//lib/datadog/appsec/configuration/settings.rb#14
Datadog::AppSec::Configuration::Settings::APPSEC_VALID_TRACK_USER_EVENTS_MODE = T.let(T.unsafe(nil), Array)

# source://ddtrace//lib/datadog/appsec/configuration/settings.rb#11
Datadog::AppSec::Configuration::Settings::DEFAULT_OBFUSCATOR_KEY_REGEX = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/appsec/configuration/settings.rb#12
Datadog::AppSec::Configuration::Settings::DEFAULT_OBFUSCATOR_VALUE_REGEX = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/appsec/contrib/integration.rb#5
module Datadog::AppSec::Contrib; end

# source://ddtrace//lib/datadog/appsec/contrib/devise/tracking.rb#8
module Datadog::AppSec::Contrib::Devise; end

# Class to extract event information from the resource
#
# source://ddtrace//lib/datadog/appsec/contrib/devise/event.rb#8
class Datadog::AppSec::Contrib::Devise::Event
  # @return [Event] a new instance of Event
  #
  # source://ddtrace//lib/datadog/appsec/contrib/devise/event.rb#16
  def initialize(resource, mode); end

  # source://ddtrace//lib/datadog/appsec/contrib/devise/event.rb#26
  def to_h; end

  # Returns the value of attribute user_id.
  #
  # source://ddtrace//lib/datadog/appsec/contrib/devise/event.rb#14
  def user_id; end

  private

  # source://ddtrace//lib/datadog/appsec/contrib/devise/event.rb#37
  def extract; end
end

# source://ddtrace//lib/datadog/appsec/contrib/devise/event.rb#12
Datadog::AppSec::Contrib::Devise::Event::EXTENDED_MODE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/appsec/contrib/devise/event.rb#11
Datadog::AppSec::Contrib::Devise::Event::SAFE_MODE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/appsec/contrib/devise/event.rb#9
Datadog::AppSec::Contrib::Devise::Event::UUID_REGEX = T.let(T.unsafe(nil), Regexp)

# Description of Devise integration
#
# source://ddtrace//lib/datadog/appsec/contrib/devise/integration.rb#12
class Datadog::AppSec::Contrib::Devise::Integration
  include ::Datadog::AppSec::Contrib::Integration
  extend ::Datadog::AppSec::Contrib::Integration::ClassMethods

  # source://ddtrace//lib/datadog/appsec/contrib/devise/integration.rb#35
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/appsec/contrib/devise/integration.rb#31
    def auto_instrument?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/appsec/contrib/devise/integration.rb#27
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/appsec/contrib/devise/integration.rb#23
    def loaded?; end

    # source://ddtrace//lib/datadog/appsec/contrib/devise/integration.rb#19
    def version; end
  end
end

# source://ddtrace//lib/datadog/appsec/contrib/devise/integration.rb#15
Datadog::AppSec::Contrib::Devise::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher for AppSec on Devise
#
# source://ddtrace//lib/datadog/appsec/contrib/devise/patcher/authenticatable_patch.rb#11
module Datadog::AppSec::Contrib::Devise::Patcher
  include ::Datadog::AppSec::Contrib::Patcher

  private

  # source://ddtrace//lib/datadog/appsec/contrib/devise/patcher.rb#25
  def patch; end

  # source://ddtrace//lib/datadog/appsec/contrib/devise/patcher.rb#32
  def patch_authenticable_strategy; end

  # source://ddtrace//lib/datadog/appsec/contrib/devise/patcher.rb#36
  def patch_registration_controller; end

  # source://ddtrace//lib/datadog/appsec/contrib/devise/patcher.rb#17
  def patched?; end

  # source://ddtrace//lib/datadog/appsec/contrib/devise/patcher.rb#21
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/appsec/contrib/devise/patcher.rb#25
    def patch; end

    # source://ddtrace//lib/datadog/appsec/contrib/devise/patcher.rb#32
    def patch_authenticable_strategy; end

    # source://ddtrace//lib/datadog/appsec/contrib/devise/patcher.rb#36
    def patch_registration_controller; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/appsec/contrib/devise/patcher.rb#17
    def patched?; end

    # source://ddtrace//lib/datadog/appsec/contrib/devise/patcher.rb#21
    def target_version; end
  end
end

# Hook in devise validate method
#
# source://ddtrace//lib/datadog/appsec/contrib/devise/patcher/authenticatable_patch.rb#13
module Datadog::AppSec::Contrib::Devise::Patcher::AuthenticatablePatch
  # source://ddtrace//lib/datadog/appsec/contrib/devise/patcher/authenticatable_patch.rb#15
  def validate(resource, &block); end
end

# Hook in devise registration controller
#
# source://ddtrace//lib/datadog/appsec/contrib/devise/patcher/registration_controller_patch.rb#13
module Datadog::AppSec::Contrib::Devise::Patcher::RegistrationControllerPatch
  # source://ddtrace//lib/datadog/appsec/contrib/devise/patcher/registration_controller_patch.rb#14
  def create; end
end

# Class to encpasulate extracting information from a Devise resource
# Normally a devise resource would be an Active::Record instance
#
# source://ddtrace//lib/datadog/appsec/contrib/devise/resource.rb#9
class Datadog::AppSec::Contrib::Devise::Resource
  # @return [Resource] a new instance of Resource
  #
  # source://ddtrace//lib/datadog/appsec/contrib/devise/resource.rb#10
  def initialize(resource); end

  # source://ddtrace//lib/datadog/appsec/contrib/devise/resource.rb#18
  def email; end

  # source://ddtrace//lib/datadog/appsec/contrib/devise/resource.rb#14
  def id; end

  # source://ddtrace//lib/datadog/appsec/contrib/devise/resource.rb#22
  def username; end

  private

  # source://ddtrace//lib/datadog/appsec/contrib/devise/resource.rb#28
  def extract(method); end
end

# Internal module to track user events
#
# source://ddtrace//lib/datadog/appsec/contrib/devise/tracking.rb#10
module Datadog::AppSec::Contrib::Devise::Tracking
  class << self
    # source://ddtrace//lib/datadog/appsec/contrib/devise/tracking.rb#33
    def track(event, trace, span, **others); end

    # source://ddtrace//lib/datadog/appsec/contrib/devise/tracking.rb#21
    def track_login_failure(trace, span, user_id:, user_exists:, **others); end

    # source://ddtrace//lib/datadog/appsec/contrib/devise/tracking.rb#15
    def track_login_success(trace, span, user_id:, **others); end

    # source://ddtrace//lib/datadog/appsec/contrib/devise/tracking.rb#28
    def track_signup(trace, span, user_id:, **others); end
  end
end

# source://ddtrace//lib/datadog/appsec/contrib/devise/tracking.rb#12
Datadog::AppSec::Contrib::Devise::Tracking::LOGIN_FAILURE_EVENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/appsec/contrib/devise/tracking.rb#11
Datadog::AppSec::Contrib::Devise::Tracking::LOGIN_SUCCESS_EVENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/appsec/contrib/devise/tracking.rb#13
Datadog::AppSec::Contrib::Devise::Tracking::SIGNUP_EVENT = T.let(T.unsafe(nil), String)

# Base provides features that are shared across all integrations
#
# source://ddtrace//lib/datadog/appsec/contrib/integration.rb#7
module Datadog::AppSec::Contrib::Integration
  mixes_in_class_methods ::Datadog::AppSec::Contrib::Integration::ClassMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/appsec/contrib/integration.rb#12
    def included(base); end

    # source://ddtrace//lib/datadog/appsec/contrib/integration.rb#27
    def register(integration, name, options); end

    # source://ddtrace//lib/datadog/appsec/contrib/integration.rb#31
    def registry; end
  end
end

# Class-level methods for Integration
#
# source://ddtrace//lib/datadog/appsec/contrib/integration.rb#17
module Datadog::AppSec::Contrib::Integration::ClassMethods
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/appsec/contrib/integration.rb#22
  def compatible?; end

  # source://ddtrace//lib/datadog/appsec/contrib/integration.rb#18
  def register_as(name, options = T.unsafe(nil)); end
end

# source://ddtrace//lib/datadog/appsec/contrib/integration.rb#10
class Datadog::AppSec::Contrib::Integration::RegisteredIntegration < ::Struct
  # Returns the value of attribute klass
  #
  # @return [Object] the current value of klass
  def klass; end

  # Sets the attribute klass
  #
  # @param value [Object] the value to set the attribute klass to.
  # @return [Object] the newly set value
  def klass=(_); end

  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  def name=(_); end

  # Returns the value of attribute options
  #
  # @return [Object] the current value of options
  def options; end

  # Sets the attribute options
  #
  # @param value [Object] the value to set the attribute options to.
  # @return [Object] the newly set value
  def options=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Common patcher code for AppSec integrations
# TODO: empty implementation, check with tracer shareable code
#
# source://ddtrace//lib/datadog/appsec/contrib/patcher.rb#8
module Datadog::AppSec::Contrib::Patcher; end

# source://ddtrace//lib/datadog/appsec/contrib/rack/reactive/request.rb#6
module Datadog::AppSec::Contrib::Rack; end

# source://ddtrace//lib/datadog/appsec/contrib/rack/gateway/watcher.rb#12
module Datadog::AppSec::Contrib::Rack::Gateway; end

# Gateway Request argument. Normalized extration of data from Rack::Request
#
# source://ddtrace//lib/datadog/appsec/contrib/rack/gateway/request.rb#13
class Datadog::AppSec::Contrib::Rack::Gateway::Request < ::Datadog::AppSec::Instrumentation::Gateway::Argument
  # @return [Request] a new instance of Request
  #
  # source://ddtrace//lib/datadog/appsec/contrib/rack/gateway/request.rb#16
  def initialize(env); end

  # source://ddtrace//lib/datadog/appsec/contrib/rack/gateway/request.rb#48
  def body; end

  # source://ddtrace//lib/datadog/appsec/contrib/rack/gateway/request.rb#89
  def client_ip; end

  # source://ddtrace//lib/datadog/appsec/contrib/rack/gateway/request.rb#64
  def cookies; end

  # Returns the value of attribute env.
  #
  # source://ddtrace//lib/datadog/appsec/contrib/rack/gateway/request.rb#14
  def env; end

  # source://ddtrace//lib/datadog/appsec/contrib/rack/gateway/request.rb#80
  def form_hash; end

  # source://ddtrace//lib/datadog/appsec/contrib/rack/gateway/request.rb#56
  def fullpath; end

  # source://ddtrace//lib/datadog/appsec/contrib/rack/gateway/request.rb#42
  def headers; end

  # source://ddtrace//lib/datadog/appsec/contrib/rack/gateway/request.rb#68
  def host; end

  # source://ddtrace//lib/datadog/appsec/contrib/rack/gateway/request.rb#38
  def method; end

  # source://ddtrace//lib/datadog/appsec/contrib/rack/gateway/request.rb#60
  def path; end

  # source://ddtrace//lib/datadog/appsec/contrib/rack/gateway/request.rb#25
  def query; end

  # source://ddtrace//lib/datadog/appsec/contrib/rack/gateway/request.rb#76
  def remote_addr; end

  # source://ddtrace//lib/datadog/appsec/contrib/rack/gateway/request.rb#21
  def request; end

  # source://ddtrace//lib/datadog/appsec/contrib/rack/gateway/request.rb#52
  def url; end

  # source://ddtrace//lib/datadog/appsec/contrib/rack/gateway/request.rb#72
  def user_agent; end
end

# Gateway Response argument.
#
# source://ddtrace//lib/datadog/appsec/contrib/rack/gateway/response.rb#11
class Datadog::AppSec::Contrib::Rack::Gateway::Response < ::Datadog::AppSec::Instrumentation::Gateway::Argument
  # @return [Response] a new instance of Response
  #
  # source://ddtrace//lib/datadog/appsec/contrib/rack/gateway/response.rb#14
  def initialize(body, status, headers, scope:); end

  # Returns the value of attribute body.
  #
  # source://ddtrace//lib/datadog/appsec/contrib/rack/gateway/response.rb#12
  def body; end

  # Returns the value of attribute headers.
  #
  # source://ddtrace//lib/datadog/appsec/contrib/rack/gateway/response.rb#12
  def headers; end

  # source://ddtrace//lib/datadog/appsec/contrib/rack/gateway/response.rb#22
  def response; end

  # Returns the value of attribute scope.
  #
  # source://ddtrace//lib/datadog/appsec/contrib/rack/gateway/response.rb#12
  def scope; end

  # Returns the value of attribute status.
  #
  # source://ddtrace//lib/datadog/appsec/contrib/rack/gateway/response.rb#12
  def status; end
end

# Watcher for Rack gateway events
#
# source://ddtrace//lib/datadog/appsec/contrib/rack/gateway/watcher.rb#14
module Datadog::AppSec::Contrib::Rack::Gateway::Watcher
  class << self
    # source://ddtrace//lib/datadog/appsec/contrib/rack/gateway/watcher.rb#16
    def watch; end

    # source://ddtrace//lib/datadog/appsec/contrib/rack/gateway/watcher.rb#24
    def watch_request(gateway = T.unsafe(nil)); end

    # source://ddtrace//lib/datadog/appsec/contrib/rack/gateway/watcher.rb#110
    def watch_request_body(gateway = T.unsafe(nil)); end

    # source://ddtrace//lib/datadog/appsec/contrib/rack/gateway/watcher.rb#67
    def watch_response(gateway = T.unsafe(nil)); end
  end
end

# Description of Rack integration
#
# source://ddtrace//lib/datadog/appsec/contrib/rack/integration.rb#12
class Datadog::AppSec::Contrib::Rack::Integration
  include ::Datadog::AppSec::Contrib::Integration
  extend ::Datadog::AppSec::Contrib::Integration::ClassMethods

  # source://ddtrace//lib/datadog/appsec/contrib/rack/integration.rb#35
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/appsec/contrib/rack/integration.rb#31
    def auto_instrument?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/appsec/contrib/rack/integration.rb#27
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/appsec/contrib/rack/integration.rb#23
    def loaded?; end

    # source://ddtrace//lib/datadog/appsec/contrib/rack/integration.rb#19
    def version; end
  end
end

# source://ddtrace//lib/datadog/appsec/contrib/rack/integration.rb#15
Datadog::AppSec::Contrib::Rack::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher for Rack integration
#
# source://ddtrace//lib/datadog/appsec/contrib/rack/patcher.rb#12
module Datadog::AppSec::Contrib::Rack::Patcher
  include ::Datadog::AppSec::Contrib::Patcher

  private

  # source://ddtrace//lib/datadog/appsec/contrib/rack/patcher.rb#25
  def patch; end

  # source://ddtrace//lib/datadog/appsec/contrib/rack/patcher.rb#17
  def patched?; end

  # source://ddtrace//lib/datadog/appsec/contrib/rack/patcher.rb#21
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/appsec/contrib/rack/patcher.rb#25
    def patch; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/appsec/contrib/rack/patcher.rb#17
    def patched?; end

    # source://ddtrace//lib/datadog/appsec/contrib/rack/patcher.rb#21
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/appsec/contrib/rack/reactive/request.rb#7
module Datadog::AppSec::Contrib::Rack::Reactive; end

# Dispatch data from a Rack request to the WAF context
#
# source://ddtrace//lib/datadog/appsec/contrib/rack/reactive/request.rb#9
module Datadog::AppSec::Contrib::Rack::Reactive::Request
  class << self
    # source://ddtrace//lib/datadog/appsec/contrib/rack/reactive/request.rb#20
    def publish(op, gateway_request); end

    # source://ddtrace//lib/datadog/appsec/contrib/rack/reactive/request.rb#34
    def subscribe(op, waf_context); end
  end
end

# source://ddtrace//lib/datadog/appsec/contrib/rack/reactive/request.rb#10
Datadog::AppSec::Contrib::Rack::Reactive::Request::ADDRESSES = T.let(T.unsafe(nil), Array)

# Dispatch data from a Rack request to the WAF context
#
# source://ddtrace//lib/datadog/appsec/contrib/rack/reactive/request_body.rb#9
module Datadog::AppSec::Contrib::Rack::Reactive::RequestBody
  class << self
    # source://ddtrace//lib/datadog/appsec/contrib/rack/reactive/request_body.rb#15
    def publish(op, gateway_request); end

    # source://ddtrace//lib/datadog/appsec/contrib/rack/reactive/request_body.rb#24
    def subscribe(op, waf_context); end
  end
end

# source://ddtrace//lib/datadog/appsec/contrib/rack/reactive/request_body.rb#10
Datadog::AppSec::Contrib::Rack::Reactive::RequestBody::ADDRESSES = T.let(T.unsafe(nil), Array)

# Dispatch data from a Rack response to the WAF context
#
# source://ddtrace//lib/datadog/appsec/contrib/rack/reactive/response.rb#9
module Datadog::AppSec::Contrib::Rack::Reactive::Response
  class << self
    # source://ddtrace//lib/datadog/appsec/contrib/rack/reactive/response.rb#16
    def publish(op, gateway_response); end

    # source://ddtrace//lib/datadog/appsec/contrib/rack/reactive/response.rb#25
    def subscribe(op, waf_context); end
  end
end

# source://ddtrace//lib/datadog/appsec/contrib/rack/reactive/response.rb#10
Datadog::AppSec::Contrib::Rack::Reactive::Response::ADDRESSES = T.let(T.unsafe(nil), Array)

# Rack request body middleware for AppSec
# This should be inserted just below Rack::JSONBodyParser or
# legacy Rack::PostBodyContentTypeParser from rack-contrib
#
# source://ddtrace//lib/datadog/appsec/contrib/rack/request_body_middleware.rb#14
class Datadog::AppSec::Contrib::Rack::RequestBodyMiddleware
  # @return [RequestBodyMiddleware] a new instance of RequestBodyMiddleware
  #
  # source://ddtrace//lib/datadog/appsec/contrib/rack/request_body_middleware.rb#15
  def initialize(app, opt = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/appsec/contrib/rack/request_body_middleware.rb#19
  def call(env); end
end

# Topmost Rack middleware for AppSec
# This should be inserted just below Datadog::Tracing::Contrib::Rack::TraceMiddleware
#
# source://ddtrace//lib/datadog/appsec/contrib/rack/request_middleware.rb#18
class Datadog::AppSec::Contrib::Rack::RequestMiddleware
  # @return [RequestMiddleware] a new instance of RequestMiddleware
  #
  # source://ddtrace//lib/datadog/appsec/contrib/rack/request_middleware.rb#19
  def initialize(app, opt = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/appsec/contrib/rack/request_middleware.rb#26
  def call(env); end

  private

  # source://ddtrace//lib/datadog/appsec/contrib/rack/request_middleware.rb#99
  def active_scope(env); end

  # source://ddtrace//lib/datadog/appsec/contrib/rack/request_middleware.rb#111
  def active_span; end

  # source://ddtrace//lib/datadog/appsec/contrib/rack/request_middleware.rb#103
  def active_trace; end

  # source://ddtrace//lib/datadog/appsec/contrib/rack/request_middleware.rb#119
  def add_appsec_tags(processor, scope, env); end

  # source://ddtrace//lib/datadog/appsec/contrib/rack/request_middleware.rb#163
  def add_waf_runtime_tags(scope); end
end

# source://ddtrace//lib/datadog/appsec/contrib/rails/framework.rb#6
module Datadog::AppSec::Contrib::Rails; end

# Rails specific framework tie
#
# source://ddtrace//lib/datadog/appsec/contrib/rails/framework.rb#8
module Datadog::AppSec::Contrib::Rails::Framework
  class << self
    # source://ddtrace//lib/datadog/appsec/contrib/rails/framework.rb#9
    def setup; end
  end
end

# source://ddtrace//lib/datadog/appsec/contrib/rails/gateway/watcher.rb#10
module Datadog::AppSec::Contrib::Rails::Gateway; end

# Gateway Request argument. Normalized extration of data from ActionDispatch::Request
#
# source://ddtrace//lib/datadog/appsec/contrib/rails/gateway/request.rb#11
class Datadog::AppSec::Contrib::Rails::Gateway::Request < ::Datadog::AppSec::Instrumentation::Gateway::Argument
  # @return [Request] a new instance of Request
  #
  # source://ddtrace//lib/datadog/appsec/contrib/rails/gateway/request.rb#14
  def initialize(request); end

  # source://ddtrace//lib/datadog/appsec/contrib/rails/gateway/request.rb#19
  def env; end

  # source://ddtrace//lib/datadog/appsec/contrib/rails/gateway/request.rb#23
  def headers; end

  # source://ddtrace//lib/datadog/appsec/contrib/rails/gateway/request.rb#27
  def host; end

  # source://ddtrace//lib/datadog/appsec/contrib/rails/gateway/request.rb#39
  def parsed_body; end

  # source://ddtrace//lib/datadog/appsec/contrib/rails/gateway/request.rb#35
  def remote_addr; end

  # Returns the value of attribute request.
  #
  # source://ddtrace//lib/datadog/appsec/contrib/rails/gateway/request.rb#12
  def request; end

  # source://ddtrace//lib/datadog/appsec/contrib/rails/gateway/request.rb#55
  def route_params; end

  # source://ddtrace//lib/datadog/appsec/contrib/rails/gateway/request.rb#31
  def user_agent; end
end

# Watcher for Rails gateway events
#
# source://ddtrace//lib/datadog/appsec/contrib/rails/gateway/watcher.rb#12
module Datadog::AppSec::Contrib::Rails::Gateway::Watcher
  class << self
    # source://ddtrace//lib/datadog/appsec/contrib/rails/gateway/watcher.rb#14
    def watch; end

    # source://ddtrace//lib/datadog/appsec/contrib/rails/gateway/watcher.rb#20
    def watch_request_action(gateway = T.unsafe(nil)); end
  end
end

# Description of Rails integration
#
# source://ddtrace//lib/datadog/appsec/contrib/rails/integration.rb#11
class Datadog::AppSec::Contrib::Rails::Integration
  include ::Datadog::AppSec::Contrib::Integration
  extend ::Datadog::AppSec::Contrib::Integration::ClassMethods

  # source://ddtrace//lib/datadog/appsec/contrib/rails/integration.rb#34
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/appsec/contrib/rails/integration.rb#30
    def auto_instrument?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/appsec/contrib/rails/integration.rb#26
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/appsec/contrib/rails/integration.rb#22
    def loaded?; end

    # source://ddtrace//lib/datadog/appsec/contrib/rails/integration.rb#18
    def version; end
  end
end

# source://ddtrace//lib/datadog/appsec/contrib/rails/integration.rb#14
Datadog::AppSec::Contrib::Rails::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher for AppSec on Rails
#
# source://ddtrace//lib/datadog/appsec/contrib/rails/patcher.rb#18
module Datadog::AppSec::Contrib::Rails::Patcher
  include ::Datadog::AppSec::Contrib::Patcher

  private

  # source://ddtrace//lib/datadog/appsec/contrib/rails/patcher.rb#58
  def add_middleware(app); end

  # source://ddtrace//lib/datadog/appsec/contrib/rails/patcher.rb#143
  def after_initialize(app); end

  # source://ddtrace//lib/datadog/appsec/contrib/rails/patcher.rb#48
  def before_initialize(app); end

  # source://ddtrace//lib/datadog/appsec/contrib/rails/patcher.rb#99
  def include_middleware?(middleware, app); end

  # source://ddtrace//lib/datadog/appsec/contrib/rails/patcher.rb#133
  def inspect_middlewares(app); end

  # source://ddtrace//lib/datadog/appsec/contrib/rails/patcher.rb#34
  def patch; end

  # source://ddtrace//lib/datadog/appsec/contrib/rails/patcher.rb#137
  def patch_after_initialize; end

  # source://ddtrace//lib/datadog/appsec/contrib/rails/patcher.rb#42
  def patch_before_initialize; end

  # source://ddtrace//lib/datadog/appsec/contrib/rails/patcher.rb#95
  def patch_process_action; end

  # source://ddtrace//lib/datadog/appsec/contrib/rails/patcher.rb#26
  def patched?; end

  # source://ddtrace//lib/datadog/appsec/contrib/rails/patcher.rb#152
  def setup_security; end

  # source://ddtrace//lib/datadog/appsec/contrib/rails/patcher.rb#30
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/appsec/contrib/rails/patcher.rb#58
    def add_middleware(app); end

    # source://ddtrace//lib/datadog/appsec/contrib/rails/patcher.rb#143
    def after_initialize(app); end

    # source://ddtrace//lib/datadog/appsec/contrib/rails/patcher.rb#48
    def before_initialize(app); end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/appsec/contrib/rails/patcher.rb#99
    def include_middleware?(middleware, app); end

    # source://ddtrace//lib/datadog/appsec/contrib/rails/patcher.rb#133
    def inspect_middlewares(app); end

    # source://ddtrace//lib/datadog/appsec/contrib/rails/patcher.rb#34
    def patch; end

    # source://ddtrace//lib/datadog/appsec/contrib/rails/patcher.rb#137
    def patch_after_initialize; end

    # source://ddtrace//lib/datadog/appsec/contrib/rails/patcher.rb#42
    def patch_before_initialize; end

    # source://ddtrace//lib/datadog/appsec/contrib/rails/patcher.rb#95
    def patch_process_action; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/appsec/contrib/rails/patcher.rb#26
    def patched?; end

    # source://ddtrace//lib/datadog/appsec/contrib/rails/patcher.rb#152
    def setup_security; end

    # source://ddtrace//lib/datadog/appsec/contrib/rails/patcher.rb#30
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/appsec/contrib/rails/patcher.rb#22
Datadog::AppSec::Contrib::Rails::Patcher::AFTER_INITIALIZE_ONLY_ONCE_PER_APP = T.let(T.unsafe(nil), Hash)

# source://ddtrace//lib/datadog/appsec/contrib/rails/patcher.rb#21
Datadog::AppSec::Contrib::Rails::Patcher::BEFORE_INITIALIZE_ONLY_ONCE_PER_APP = T.let(T.unsafe(nil), Hash)

# Hook into ActionController::Instrumentation#process_action, which encompasses action filters
#
# source://ddtrace//lib/datadog/appsec/contrib/rails/patcher.rb#71
module Datadog::AppSec::Contrib::Rails::Patcher::ProcessActionPatch
  # source://ddtrace//lib/datadog/appsec/contrib/rails/patcher.rb#72
  def process_action(*args); end
end

# source://ddtrace//lib/datadog/appsec/contrib/rails/reactive/action.rb#9
module Datadog::AppSec::Contrib::Rails::Reactive; end

# Dispatch data from a Rails request to the WAF context
#
# source://ddtrace//lib/datadog/appsec/contrib/rails/reactive/action.rb#11
module Datadog::AppSec::Contrib::Rails::Reactive::Action
  class << self
    # source://ddtrace//lib/datadog/appsec/contrib/rails/reactive/action.rb#18
    def publish(op, gateway_request); end

    # source://ddtrace//lib/datadog/appsec/contrib/rails/reactive/action.rb#28
    def subscribe(op, waf_context); end
  end
end

# source://ddtrace//lib/datadog/appsec/contrib/rails/reactive/action.rb#12
Datadog::AppSec::Contrib::Rails::Reactive::Action::ADDRESSES = T.let(T.unsafe(nil), Array)

# Normalized extration of data from ActionDispatch::Request
#
# source://ddtrace//lib/datadog/appsec/contrib/rails/request.rb#8
module Datadog::AppSec::Contrib::Rails::Request
  class << self
    # source://ddtrace//lib/datadog/appsec/contrib/rails/request.rb#9
    def parsed_body(request); end

    # source://ddtrace//lib/datadog/appsec/contrib/rails/request.rb#25
    def route_params(request); end
  end
end

# Rack middleware for AppSec on Rails
#
# source://ddtrace//lib/datadog/appsec/contrib/rails/request_middleware.rb#8
class Datadog::AppSec::Contrib::Rails::RequestMiddleware
  # @return [RequestMiddleware] a new instance of RequestMiddleware
  #
  # source://ddtrace//lib/datadog/appsec/contrib/rails/request_middleware.rb#9
  def initialize(app, opt = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/appsec/contrib/rails/request_middleware.rb#13
  def call(env); end
end

# Instrument Sinatra.
#
# source://ddtrace//lib/datadog/appsec/contrib/sinatra/framework.rb#7
module Datadog::AppSec::Contrib::Sinatra; end

# Set tracer configuration at a late enough time
#
# source://ddtrace//lib/datadog/appsec/contrib/sinatra/patcher.rb#18
module Datadog::AppSec::Contrib::Sinatra::AppSecSetupPatch
  # source://ddtrace//lib/datadog/appsec/contrib/sinatra/patcher.rb#19
  def setup_middleware(*args, &block); end
end

# Hook into builder before the middleware list gets frozen
#
# source://ddtrace//lib/datadog/appsec/contrib/sinatra/patcher.rb#27
module Datadog::AppSec::Contrib::Sinatra::DefaultMiddlewarePatch
  # source://ddtrace//lib/datadog/appsec/contrib/sinatra/patcher.rb#28
  def setup_middleware(*args, &block); end
end

# Hook into Base#dispatch!, which encompasses route filters
#
# source://ddtrace//lib/datadog/appsec/contrib/sinatra/patcher.rb#51
module Datadog::AppSec::Contrib::Sinatra::DispatchPatch
  # source://ddtrace//lib/datadog/appsec/contrib/sinatra/patcher.rb#52
  def dispatch!; end
end

# Sinatra integration constants
#
# source://ddtrace//lib/datadog/appsec/contrib/sinatra/ext.rb#8
module Datadog::AppSec::Contrib::Sinatra::Ext; end

# source://ddtrace//lib/datadog/appsec/contrib/sinatra/ext.rb#9
Datadog::AppSec::Contrib::Sinatra::Ext::ROUTE_INTERRUPT = T.let(T.unsafe(nil), Symbol)

# Sinatra framework code, used to essentially:
# - handle configuration entries which are specific to Datadog tracing
# - instrument parts of the framework when needed
#
# source://ddtrace//lib/datadog/appsec/contrib/sinatra/framework.rb#11
module Datadog::AppSec::Contrib::Sinatra::Framework
  class << self
    # Configure Rack from Sinatra, but only if Rack has not been configured manually beforehand
    #
    # source://ddtrace//lib/datadog/appsec/contrib/sinatra/framework.rb#13
    def setup; end
  end
end

# source://ddtrace//lib/datadog/appsec/contrib/sinatra/gateway/watcher.rb#11
module Datadog::AppSec::Contrib::Sinatra::Gateway; end

# Gateway Request argument. Normalized extration of data from Rack::Request
#
# source://ddtrace//lib/datadog/appsec/contrib/sinatra/gateway/request.rb#11
class Datadog::AppSec::Contrib::Sinatra::Gateway::Request < ::Datadog::AppSec::Contrib::Rack::Gateway::Request; end

# Gateway Route Params argument.
#
# source://ddtrace//lib/datadog/appsec/contrib/sinatra/gateway/route_params.rb#11
class Datadog::AppSec::Contrib::Sinatra::Gateway::RouteParams < ::Datadog::AppSec::Instrumentation::Gateway::Argument
  # @return [RouteParams] a new instance of RouteParams
  #
  # source://ddtrace//lib/datadog/appsec/contrib/sinatra/gateway/route_params.rb#14
  def initialize(params); end

  # Returns the value of attribute params.
  #
  # source://ddtrace//lib/datadog/appsec/contrib/sinatra/gateway/route_params.rb#12
  def params; end
end

# Watcher for Sinatra gateway events
#
# source://ddtrace//lib/datadog/appsec/contrib/sinatra/gateway/watcher.rb#13
module Datadog::AppSec::Contrib::Sinatra::Gateway::Watcher
  class << self
    # source://ddtrace//lib/datadog/appsec/contrib/sinatra/gateway/watcher.rb#15
    def watch; end

    # source://ddtrace//lib/datadog/appsec/contrib/sinatra/gateway/watcher.rb#22
    def watch_request_dispatch(gateway = T.unsafe(nil)); end

    # source://ddtrace//lib/datadog/appsec/contrib/sinatra/gateway/watcher.rb#65
    def watch_request_routed(gateway = T.unsafe(nil)); end
  end
end

# Description of Sinatra integration
#
# source://ddtrace//lib/datadog/appsec/contrib/sinatra/integration.rb#11
class Datadog::AppSec::Contrib::Sinatra::Integration
  include ::Datadog::AppSec::Contrib::Integration
  extend ::Datadog::AppSec::Contrib::Integration::ClassMethods

  # source://ddtrace//lib/datadog/appsec/contrib/sinatra/integration.rb#34
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/appsec/contrib/sinatra/integration.rb#30
    def auto_instrument?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/appsec/contrib/sinatra/integration.rb#26
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/appsec/contrib/sinatra/integration.rb#22
    def loaded?; end

    # source://ddtrace//lib/datadog/appsec/contrib/sinatra/integration.rb#18
    def version; end
  end
end

# source://ddtrace//lib/datadog/appsec/contrib/sinatra/integration.rb#14
Datadog::AppSec::Contrib::Sinatra::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher for AppSec on Sinatra
#
# source://ddtrace//lib/datadog/appsec/contrib/sinatra/patcher.rb#119
module Datadog::AppSec::Contrib::Sinatra::Patcher
  include ::Datadog::AppSec::Contrib::Patcher

  private

  # source://ddtrace//lib/datadog/appsec/contrib/sinatra/patcher.rb#132
  def patch; end

  # source://ddtrace//lib/datadog/appsec/contrib/sinatra/patcher.rb#145
  def patch_default_middlewares; end

  # source://ddtrace//lib/datadog/appsec/contrib/sinatra/patcher.rb#149
  def patch_dispatch; end

  # source://ddtrace//lib/datadog/appsec/contrib/sinatra/patcher.rb#153
  def patch_route; end

  # source://ddtrace//lib/datadog/appsec/contrib/sinatra/patcher.rb#124
  def patched?; end

  # source://ddtrace//lib/datadog/appsec/contrib/sinatra/patcher.rb#141
  def setup_security; end

  # source://ddtrace//lib/datadog/appsec/contrib/sinatra/patcher.rb#128
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/appsec/contrib/sinatra/patcher.rb#132
    def patch; end

    # source://ddtrace//lib/datadog/appsec/contrib/sinatra/patcher.rb#145
    def patch_default_middlewares; end

    # source://ddtrace//lib/datadog/appsec/contrib/sinatra/patcher.rb#149
    def patch_dispatch; end

    # source://ddtrace//lib/datadog/appsec/contrib/sinatra/patcher.rb#153
    def patch_route; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/appsec/contrib/sinatra/patcher.rb#124
    def patched?; end

    # source://ddtrace//lib/datadog/appsec/contrib/sinatra/patcher.rb#141
    def setup_security; end

    # source://ddtrace//lib/datadog/appsec/contrib/sinatra/patcher.rb#128
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/appsec/contrib/sinatra/reactive/routed.rb#7
module Datadog::AppSec::Contrib::Sinatra::Reactive; end

# Dispatch data from a Sinatra request to the WAF context
#
# source://ddtrace//lib/datadog/appsec/contrib/sinatra/reactive/routed.rb#9
module Datadog::AppSec::Contrib::Sinatra::Reactive::Routed
  class << self
    # source://ddtrace//lib/datadog/appsec/contrib/sinatra/reactive/routed.rb#15
    def publish(op, data); end

    # source://ddtrace//lib/datadog/appsec/contrib/sinatra/reactive/routed.rb#25
    def subscribe(op, waf_context); end
  end
end

# source://ddtrace//lib/datadog/appsec/contrib/sinatra/reactive/routed.rb#10
Datadog::AppSec::Contrib::Sinatra::Reactive::Routed::ADDRESSES = T.let(T.unsafe(nil), Array)

# Rack middleware for AppSec on Sinatra
#
# source://ddtrace//lib/datadog/appsec/contrib/sinatra/request_middleware.rb#8
class Datadog::AppSec::Contrib::Sinatra::RequestMiddleware
  # @return [RequestMiddleware] a new instance of RequestMiddleware
  #
  # source://ddtrace//lib/datadog/appsec/contrib/sinatra/request_middleware.rb#9
  def initialize(app, opt = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/appsec/contrib/sinatra/request_middleware.rb#13
  def call(env); end
end

# Hook into Base#route_eval, which
# path params are returned by pattern.params in process_route, then
# merged with normal params, so we get both
#
# source://ddtrace//lib/datadog/appsec/contrib/sinatra/patcher.rb#80
module Datadog::AppSec::Contrib::Sinatra::RoutePatch
  # source://ddtrace//lib/datadog/appsec/contrib/sinatra/patcher.rb#81
  def process_route(*_arg0); end
end

# AppSec event
#
# source://ddtrace//lib/datadog/appsec/event.rb#8
module Datadog::AppSec::Event
  class << self
    # source://ddtrace//lib/datadog/appsec/event.rb#76
    def build_service_entry_tags(event_group); end

    # Record events for a trace
    #
    # This is expected to be called only once per trace for the rate limiter
    # to properly apply
    #
    # source://ddtrace//lib/datadog/appsec/event.rb#41
    def record(span, *events); end

    # source://ddtrace//lib/datadog/appsec/event.rb#50
    def record_via_span(span, *events); end
  end
end

# source://ddtrace//lib/datadog/appsec/event.rb#9
Datadog::AppSec::Event::ALLOWED_REQUEST_HEADERS = T.let(T.unsafe(nil), Array)

# source://ddtrace//lib/datadog/appsec/event.rb#30
Datadog::AppSec::Event::ALLOWED_RESPONSE_HEADERS = T.let(T.unsafe(nil), Array)

# source://ddtrace//lib/datadog/appsec/ext.rb#5
module Datadog::AppSec::Ext; end

# source://ddtrace//lib/datadog/appsec/ext.rb#6
Datadog::AppSec::Ext::INTERRUPT = T.let(T.unsafe(nil), Symbol)

# source://ddtrace//lib/datadog/appsec/ext.rb#7
Datadog::AppSec::Ext::SCOPE_KEY = T.let(T.unsafe(nil), String)

# Extends Datadog tracing with AppSec features
#
# source://ddtrace//lib/datadog/appsec/extensions.rb#8
module Datadog::AppSec::Extensions
  class << self
    # Inject AppSec into global objects.
    #
    # source://ddtrace//lib/datadog/appsec/extensions.rb#10
    def activate!; end
  end
end

# Instrumentation for AppSec
#
# source://ddtrace//lib/datadog/appsec/instrumentation/gateway.rb#6
module Datadog::AppSec::Instrumentation
  class << self
    # source://ddtrace//lib/datadog/appsec/instrumentation/gateway.rb#59
    def gateway; end
  end
end

# Instrumentation gateway implementation
#
# source://ddtrace//lib/datadog/appsec/instrumentation/gateway.rb#8
class Datadog::AppSec::Instrumentation::Gateway
  # @return [Gateway] a new instance of Gateway
  #
  # source://ddtrace//lib/datadog/appsec/instrumentation/gateway.rb#25
  def initialize; end

  # source://ddtrace//lib/datadog/appsec/instrumentation/gateway.rb#29
  def push(name, env, &block); end

  # source://ddtrace//lib/datadog/appsec/instrumentation/gateway.rb#50
  def watch(name, key, &block); end

  private

  # Returns the value of attribute middlewares.
  #
  # source://ddtrace//lib/datadog/appsec/instrumentation/gateway.rb#56
  def middlewares; end
end

# Base class for Gateway Arguments
#
# source://ddtrace//lib/datadog/appsec/instrumentation/gateway/argument.rb#8
class Datadog::AppSec::Instrumentation::Gateway::Argument; end

# Instrumentation gateway middleware
#
# source://ddtrace//lib/datadog/appsec/instrumentation/gateway.rb#10
class Datadog::AppSec::Instrumentation::Gateway::Middleware
  # @return [Middleware] a new instance of Middleware
  #
  # source://ddtrace//lib/datadog/appsec/instrumentation/gateway.rb#13
  def initialize(key, &block); end

  # Returns the value of attribute block.
  #
  # source://ddtrace//lib/datadog/appsec/instrumentation/gateway.rb#11
  def block; end

  # source://ddtrace//lib/datadog/appsec/instrumentation/gateway.rb#18
  def call(stack, env); end

  # Returns the value of attribute key.
  #
  # source://ddtrace//lib/datadog/appsec/instrumentation/gateway.rb#11
  def key; end
end

# Gateway User argument
#
# source://ddtrace//lib/datadog/appsec/instrumentation/gateway/argument.rb#11
class Datadog::AppSec::Instrumentation::Gateway::User < ::Datadog::AppSec::Instrumentation::Gateway::Argument
  # @return [User] a new instance of User
  #
  # source://ddtrace//lib/datadog/appsec/instrumentation/gateway/argument.rb#14
  def initialize(id); end

  # Returns the value of attribute id.
  #
  # source://ddtrace//lib/datadog/appsec/instrumentation/gateway/argument.rb#12
  def id; end
end

# Monitor for internal AppSec Events
#
# source://ddtrace//lib/datadog/appsec/monitor/reactive/set_user.rb#5
module Datadog::AppSec::Monitor; end

# source://ddtrace//lib/datadog/appsec/monitor/gateway/watcher.rb#10
module Datadog::AppSec::Monitor::Gateway; end

# Watcher for Apssec internal events
#
# source://ddtrace//lib/datadog/appsec/monitor/gateway/watcher.rb#12
module Datadog::AppSec::Monitor::Gateway::Watcher
  class << self
    # source://ddtrace//lib/datadog/appsec/monitor/gateway/watcher.rb#14
    def watch; end

    # source://ddtrace//lib/datadog/appsec/monitor/gateway/watcher.rb#20
    def watch_user_id(gateway = T.unsafe(nil)); end
  end
end

# source://ddtrace//lib/datadog/appsec/monitor/reactive/set_user.rb#6
module Datadog::AppSec::Monitor::Reactive; end

# Dispatch data from Datadog::Kit::Identity.set_user to the WAF context
#
# source://ddtrace//lib/datadog/appsec/monitor/reactive/set_user.rb#8
module Datadog::AppSec::Monitor::Reactive::SetUser
  class << self
    # source://ddtrace//lib/datadog/appsec/monitor/reactive/set_user.rb#14
    def publish(op, user); end

    # source://ddtrace//lib/datadog/appsec/monitor/reactive/set_user.rb#22
    def subscribe(op, waf_context); end
  end
end

# source://ddtrace//lib/datadog/appsec/monitor/reactive/set_user.rb#9
Datadog::AppSec::Monitor::Reactive::SetUser::ADDRESSES = T.let(T.unsafe(nil), Array)

# Processor integrates libddwaf into datadog/appsec
#
# source://ddtrace//lib/datadog/appsec/processor/rule_merger.rb#5
class Datadog::AppSec::Processor
  # @return [Processor] a new instance of Processor
  #
  # source://ddtrace//lib/datadog/appsec/processor.rb#48
  def initialize(ruleset:); end

  # Returns the value of attribute addresses.
  #
  # source://ddtrace//lib/datadog/appsec/processor.rb#46
  def addresses; end

  # source://ddtrace//lib/datadog/appsec/processor.rb#62
  def finalize; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/appsec/processor.rb#58
  def ready?; end

  # Returns the value of attribute ruleset_info.
  #
  # source://ddtrace//lib/datadog/appsec/processor.rb#46
  def ruleset_info; end

  protected

  # Returns the value of attribute handle.
  #
  # source://ddtrace//lib/datadog/appsec/processor.rb#68
  def handle; end

  private

  # source://ddtrace//lib/datadog/appsec/processor.rb#76
  def create_waf_handle(settings, ruleset); end

  # source://ddtrace//lib/datadog/appsec/processor.rb#72
  def load_libddwaf; end

  class << self
    # source://ddtrace//lib/datadog/appsec/processor.rb#133
    def libddwaf_platform; end

    # check whether libddwaf is required *and* able to provide the needed feature
    #
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/appsec/processor.rb#108
    def libddwaf_provides_waf?; end

    # source://ddtrace//lib/datadog/appsec/processor.rb#129
    def libddwaf_spec; end

    # libddwaf raises a LoadError on unsupported platforms; it may at some
    # point succeed in being required yet not provide a specific needed feature.
    #
    # source://ddtrace//lib/datadog/appsec/processor.rb#114
    def require_libddwaf; end

    # source://ddtrace//lib/datadog/appsec/processor.rb#137
    def ruby_platforms; end
  end
end

# Context manages a sequence of runs
#
# source://ddtrace//lib/datadog/appsec/processor.rb#8
class Datadog::AppSec::Processor::Context
  # @return [Context] a new instance of Context
  #
  # source://ddtrace//lib/datadog/appsec/processor.rb#11
  def initialize(processor); end

  # Returns the value of attribute events.
  #
  # source://ddtrace//lib/datadog/appsec/processor.rb#9
  def events; end

  # source://ddtrace//lib/datadog/appsec/processor.rb#41
  def finalize; end

  # source://ddtrace//lib/datadog/appsec/processor.rb#20
  def run(input, timeout = T.unsafe(nil)); end

  # Returns the value of attribute time_ext_ns.
  #
  # source://ddtrace//lib/datadog/appsec/processor.rb#9
  def time_ext_ns; end

  # Returns the value of attribute time_ns.
  #
  # source://ddtrace//lib/datadog/appsec/processor.rb#9
  def time_ns; end

  # Returns the value of attribute timeouts.
  #
  # source://ddtrace//lib/datadog/appsec/processor.rb#9
  def timeouts; end
end

# RuleLoader utility modules
# that load appsec rules and data from  settings
#
# source://ddtrace//lib/datadog/appsec/processor/rule_loader.rb#10
module Datadog::AppSec::Processor::RuleLoader
  class << self
    # source://ddtrace//lib/datadog/appsec/processor/rule_loader.rb#42
    def load_data(ip_denylist: T.unsafe(nil), user_id_denylist: T.unsafe(nil)); end

    # source://ddtrace//lib/datadog/appsec/processor/rule_loader.rb#12
    def load_rules(ruleset:); end

    private

    # source://ddtrace//lib/datadog/appsec/processor/rule_loader.rb#52
    def denylist_data(id, denylist); end
  end
end

# RuleMerger merge different sources of information
# into the rules payload
#
# source://ddtrace//lib/datadog/appsec/processor/rule_merger.rb#8
module Datadog::AppSec::Processor::RuleMerger
  class << self
    # source://ddtrace//lib/datadog/appsec/processor/rule_merger.rb#20
    def merge(rules:, data: T.unsafe(nil), overrides: T.unsafe(nil), exclusions: T.unsafe(nil), custom_rules: T.unsafe(nil)); end

    private

    # source://ddtrace//lib/datadog/appsec/processor/rule_merger.rb#125
    def combine_custom_rules(custom_rules); end

    # source://ddtrace//lib/datadog/appsec/processor/rule_merger.rb#63
    def combine_data(data); end

    # source://ddtrace//lib/datadog/appsec/processor/rule_merger.rb#121
    def combine_exclusions(exclusions); end

    # source://ddtrace//lib/datadog/appsec/processor/rule_merger.rb#117
    def combine_overrides(overrides); end

    # source://ddtrace//lib/datadog/appsec/processor/rule_merger.rb#38
    def combine_rules(rules); end

    # source://ddtrace//lib/datadog/appsec/processor/rule_merger.rb#87
    def merge_data_base_on_expiration(data1, data2); end
  end
end

# RuleVersionMismatchError
#
# source://ddtrace//lib/datadog/appsec/processor/rule_merger.rb#10
class Datadog::AppSec::Processor::RuleMerger::RuleVersionMismatchError < ::StandardError
  # @return [RuleVersionMismatchError] a new instance of RuleVersionMismatchError
  #
  # source://ddtrace//lib/datadog/appsec/processor/rule_merger.rb#11
  def initialize(version1, version2); end
end

# Simple per-thread rate limiter
# Since AppSec marks sampling to keep on a security event, this limits the flood of egress traces involving AppSec
#
# source://ddtrace//lib/datadog/appsec/rate_limiter.rb#5
class Datadog::AppSec::RateLimiter
  # @return [RateLimiter] a new instance of RateLimiter
  #
  # source://ddtrace//lib/datadog/appsec/rate_limiter.rb#6
  def initialize(rate); end

  # source://ddtrace//lib/datadog/appsec/rate_limiter.rb#11
  def limit; end

  class << self
    # source://ddtrace//lib/datadog/appsec/rate_limiter.rb#32
    def limit(name, &block); end

    # reset a rate limiter: used for testing
    #
    # source://ddtrace//lib/datadog/appsec/rate_limiter.rb#37
    def reset!(name); end

    protected

    # source://ddtrace//lib/datadog/appsec/rate_limiter.rb#43
    def rate_limiter(name); end

    # source://ddtrace//lib/datadog/appsec/rate_limiter.rb#52
    def trace_rate_limit; end
  end
end

# source://ddtrace//lib/datadog/appsec/reactive/address_hash.rb#5
module Datadog::AppSec::Reactive; end

# AddressHash for Reactive Engine
#
# source://ddtrace//lib/datadog/appsec/reactive/address_hash.rb#7
class Datadog::AppSec::Reactive::AddressHash < ::Hash
  # source://ddtrace//lib/datadog/appsec/reactive/address_hash.rb#12
  def addresses; end

  # source://ddtrace//lib/datadog/appsec/reactive/address_hash.rb#16
  def with(address); end

  class << self
    # source://ddtrace//lib/datadog/appsec/reactive/address_hash.rb#8
    def new(*arguments, &block); end
  end
end

# Reactive Engine
#
# source://ddtrace//lib/datadog/appsec/reactive/engine.rb#10
class Datadog::AppSec::Reactive::Engine
  # @return [Engine] a new instance of Engine
  #
  # source://ddtrace//lib/datadog/appsec/reactive/engine.rb#11
  def initialize; end

  # source://ddtrace//lib/datadog/appsec/reactive/engine.rb#20
  def publish(address, value); end

  # source://ddtrace//lib/datadog/appsec/reactive/engine.rb#16
  def subscribe(*addresses, &block); end

  private

  # Returns the value of attribute data.
  #
  # source://ddtrace//lib/datadog/appsec/reactive/engine.rb#43
  def data; end

  # Returns the value of attribute subscribers.
  #
  # source://ddtrace//lib/datadog/appsec/reactive/engine.rb#43
  def subscribers; end
end

# Reactive Engine nested operation tracking
#
# source://ddtrace//lib/datadog/appsec/reactive/operation.rb#9
class Datadog::AppSec::Reactive::Operation
  # @return [Operation] a new instance of Operation
  #
  # source://ddtrace//lib/datadog/appsec/reactive/operation.rb#14
  def initialize(name, parent = T.unsafe(nil), reactive_engine = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/appsec/reactive/operation.rb#38
  def finalize; end

  # Returns the value of attribute name.
  #
  # source://ddtrace//lib/datadog/appsec/reactive/operation.rb#10
  def name; end

  # Returns the value of attribute parent.
  #
  # source://ddtrace//lib/datadog/appsec/reactive/operation.rb#10
  def parent; end

  # source://ddtrace//lib/datadog/appsec/reactive/operation.rb#34
  def publish(address, data); end

  # Returns the value of attribute reactive.
  #
  # source://ddtrace//lib/datadog/appsec/reactive/operation.rb#10
  def reactive; end

  # TODO: use structs instead of an arg splat
  #
  # source://ddtrace//lib/datadog/appsec/reactive/operation.rb#30
  def subscribe(*addresses, &block); end

  private

  # source://ddtrace//lib/datadog/appsec/reactive/operation.rb#45
  def select_reactive_engine(reactive, parent); end

  class << self
    # source://ddtrace//lib/datadog/appsec/reactive/operation.rb#54
    def active; end

    private

    # For testing only.
    #
    # source://ddtrace//lib/datadog/appsec/reactive/operation.rb#61
    def reset!; end
  end
end

# Reactive Engine subscriber
#
# source://ddtrace//lib/datadog/appsec/reactive/subscriber.rb#7
class Datadog::AppSec::Reactive::Subscriber
  # @return [Subscriber] a new instance of Subscriber
  #
  # source://ddtrace//lib/datadog/appsec/reactive/subscriber.rb#8
  def initialize(&block); end

  # source://ddtrace//lib/datadog/appsec/reactive/subscriber.rb#13
  def call(*args); end
end

# Remote
#
# source://ddtrace//lib/datadog/appsec/remote.rb#10
module Datadog::AppSec::Remote
  class << self
    # source://ddtrace//lib/datadog/appsec/remote.rb#43
    def capabilities; end

    # source://ddtrace//lib/datadog/appsec/remote.rb#47
    def products; end

    # source://ddtrace//lib/datadog/appsec/remote.rb#52
    def receivers; end

    private

    # @raise [ReadError]
    #
    # source://ddtrace//lib/datadog/appsec/remote.rb#111
    def parse_content(content); end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/appsec/remote.rb#107
    def remote_features_enabled?; end
  end
end

# source://ddtrace//lib/datadog/appsec/remote.rb#12
class Datadog::AppSec::Remote::NoRulesError < ::StandardError; end

# source://ddtrace//lib/datadog/appsec/remote.rb#11
class Datadog::AppSec::Remote::ReadError < ::StandardError; end

# AppSec response
#
# source://ddtrace//lib/datadog/appsec/response.rb#9
class Datadog::AppSec::Response
  # @return [Response] a new instance of Response
  #
  # source://ddtrace//lib/datadog/appsec/response.rb#12
  def initialize(status:, headers: T.unsafe(nil), body: T.unsafe(nil)); end

  # Returns the value of attribute body.
  #
  # source://ddtrace//lib/datadog/appsec/response.rb#10
  def body; end

  # Returns the value of attribute headers.
  #
  # source://ddtrace//lib/datadog/appsec/response.rb#10
  def headers; end

  # Returns the value of attribute status.
  #
  # source://ddtrace//lib/datadog/appsec/response.rb#10
  def status; end

  # source://ddtrace//lib/datadog/appsec/response.rb#26
  def to_action_dispatch_response; end

  # source://ddtrace//lib/datadog/appsec/response.rb#18
  def to_rack; end

  # source://ddtrace//lib/datadog/appsec/response.rb#22
  def to_sinatra_response; end

  class << self
    # source://ddtrace//lib/datadog/appsec/response.rb#31
    def negotiate(env); end

    private

    # source://ddtrace//lib/datadog/appsec/response.rb#53
    def content_type(env); end
  end
end

# Capture context essential to consistently call processor and report via traces
#
# source://ddtrace//lib/datadog/appsec/scope.rb#8
class Datadog::AppSec::Scope
  # @return [Scope] a new instance of Scope
  #
  # source://ddtrace//lib/datadog/appsec/scope.rb#11
  def initialize(trace, service_entry_span, processor_context); end

  # source://ddtrace//lib/datadog/appsec/scope.rb#17
  def finalize; end

  # Returns the value of attribute processor_context.
  #
  # source://ddtrace//lib/datadog/appsec/scope.rb#9
  def processor_context; end

  # Returns the value of attribute service_entry_span.
  #
  # source://ddtrace//lib/datadog/appsec/scope.rb#9
  def service_entry_span; end

  # Returns the value of attribute trace.
  #
  # source://ddtrace//lib/datadog/appsec/scope.rb#9
  def trace; end

  class << self
    # @raise [ActiveScopeError]
    #
    # source://ddtrace//lib/datadog/appsec/scope.rb#22
    def activate_scope(trace, service_entry_span, processor); end

    # source://ddtrace//lib/datadog/appsec/scope.rb#40
    def active_scope; end

    # @raise [InactiveScopeError]
    #
    # source://ddtrace//lib/datadog/appsec/scope.rb#30
    def deactivate_scope; end

    private

    # @raise [ArgumentError]
    #
    # source://ddtrace//lib/datadog/appsec/scope.rb#46
    def active_scope=(scope); end

    # source://ddtrace//lib/datadog/appsec/scope.rb#52
    def reset_active_scope; end
  end
end

# source://ddtrace//lib/datadog/appsec/scope.rb#58
class Datadog::AppSec::Scope::ActiveScopeError < ::StandardError; end

# source://ddtrace//lib/datadog/appsec/scope.rb#57
class Datadog::AppSec::Scope::InactiveScopeError < ::StandardError; end

# Utilities for AppSec
#
# source://ddtrace//lib/datadog/appsec/utils/http/media_type.rb#3
module Datadog::AppSec::Utils; end

# HTTP utilities
#
# source://ddtrace//lib/datadog/appsec/utils/http/media_type.rb#4
module Datadog::AppSec::Utils::HTTP; end

# Implementation of media range for content negotiation
#
# source://ddtrace//lib/datadog/appsec/utils/http/media_range.rb#8
class Datadog::AppSec::Utils::HTTP::MediaRange
  # @raise [ParseError]
  # @return [MediaRange] a new instance of MediaRange
  #
  # source://ddtrace//lib/datadog/appsec/utils/http/media_range.rb#92
  def initialize(media_range); end

  # Compare two MediaRange for ordering
  #
  # source://ddtrace//lib/datadog/appsec/utils/http/media_range.rb#139
  def <=>(other); end

  # Compare with a MediaType for match
  #
  # returns true if the MediaType is accepted by this MediaRange
  #
  # source://ddtrace//lib/datadog/appsec/utils/http/media_range.rb#168
  def ===(other); end

  # Returns the value of attribute accept_ext.
  #
  # source://ddtrace//lib/datadog/appsec/utils/http/media_range.rb#90
  def accept_ext; end

  # Returns the value of attribute parameters.
  #
  # source://ddtrace//lib/datadog/appsec/utils/http/media_range.rb#90
  def parameters; end

  # Returns the value of attribute quality.
  #
  # source://ddtrace//lib/datadog/appsec/utils/http/media_range.rb#90
  def quality; end

  # source://ddtrace//lib/datadog/appsec/utils/http/media_range.rb#176
  def specificity; end

  # Returns the value of attribute subtype.
  #
  # source://ddtrace//lib/datadog/appsec/utils/http/media_range.rb#90
  def subtype; end

  # source://ddtrace//lib/datadog/appsec/utils/http/media_range.rb#186
  def to_s; end

  # Returns the value of attribute type.
  #
  # source://ddtrace//lib/datadog/appsec/utils/http/media_range.rb#90
  def type; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/appsec/utils/http/media_range.rb#180
  def wildcard?(field = T.unsafe(nil)); end
end

# See: https://www.rfc-editor.org/rfc/rfc7231#section-5.3.2
#
# source://ddtrace//lib/datadog/appsec/utils/http/media_range.rb#32
Datadog::AppSec::Utils::HTTP::MediaRange::ACCEPT_EXT_RE = T.let(T.unsafe(nil), Regexp)

# See: https://www.rfc-editor.org/rfc/rfc7231#section-5.3.2
#
# source://ddtrace//lib/datadog/appsec/utils/http/media_range.rb#52
Datadog::AppSec::Utils::HTTP::MediaRange::MEDIA_RANGE_RE = T.let(T.unsafe(nil), Regexp)

# See: https://www.rfc-editor.org/rfc/rfc7231#section-3.1.1.1
#
# source://ddtrace//lib/datadog/appsec/utils/http/media_range.rb#19
Datadog::AppSec::Utils::HTTP::MediaRange::PARAMETER_RE = T.let(T.unsafe(nil), Regexp)

# source://ddtrace//lib/datadog/appsec/utils/http/media_range.rb#9
class Datadog::AppSec::Utils::HTTP::MediaRange::ParseError < ::StandardError; end

# See: https://www.rfc-editor.org/rfc/rfc7231#section-5.3.1
#
# source://ddtrace//lib/datadog/appsec/utils/http/media_range.rb#45
Datadog::AppSec::Utils::HTTP::MediaRange::QVALUE_RE = T.let(T.unsafe(nil), Regexp)

# See: https://www.rfc-editor.org/rfc/rfc7230#section-3.2.6
#
# source://ddtrace//lib/datadog/appsec/utils/http/media_range.rb#16
Datadog::AppSec::Utils::HTTP::MediaRange::TOKEN_RE = T.let(T.unsafe(nil), Regexp)

# source://ddtrace//lib/datadog/appsec/utils/http/media_range.rb#12
Datadog::AppSec::Utils::HTTP::MediaRange::WILDCARD = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/appsec/utils/http/media_range.rb#13
Datadog::AppSec::Utils::HTTP::MediaRange::WILDCARD_RE = T.let(T.unsafe(nil), String)

# Implementation of media type for content negotiation
#
# See:
# - https://www.rfc-editor.org/rfc/rfc7231#section-5.3.1
# - https://www.rfc-editor.org/rfc/rfc7231#section-5.3.2
#
# source://ddtrace//lib/datadog/appsec/utils/http/media_type.rb#10
class Datadog::AppSec::Utils::HTTP::MediaType
  # @raise [ParseError]
  # @return [MediaType] a new instance of MediaType
  #
  # source://ddtrace//lib/datadog/appsec/utils/http/media_type.rb#47
  def initialize(media_type); end

  # Returns the value of attribute parameters.
  #
  # source://ddtrace//lib/datadog/appsec/utils/http/media_type.rb#45
  def parameters; end

  # Returns the value of attribute subtype.
  #
  # source://ddtrace//lib/datadog/appsec/utils/http/media_type.rb#45
  def subtype; end

  # source://ddtrace//lib/datadog/appsec/utils/http/media_type.rb#74
  def to_s; end

  # Returns the value of attribute type.
  #
  # source://ddtrace//lib/datadog/appsec/utils/http/media_type.rb#45
  def type; end
end

# See: https://www.rfc-editor.org/rfc/rfc7231#section-3.1.1.1
#
# source://ddtrace//lib/datadog/appsec/utils/http/media_type.rb#33
Datadog::AppSec::Utils::HTTP::MediaType::MEDIA_TYPE_RE = T.let(T.unsafe(nil), Regexp)

# See: https://www.rfc-editor.org/rfc/rfc7231#section-3.1.1.1
#
# source://ddtrace//lib/datadog/appsec/utils/http/media_type.rb#20
Datadog::AppSec::Utils::HTTP::MediaType::PARAMETER_RE = T.let(T.unsafe(nil), Regexp)

# source://ddtrace//lib/datadog/appsec/utils/http/media_type.rb#11
class Datadog::AppSec::Utils::HTTP::MediaType::ParseError < ::StandardError; end

# See: https://www.rfc-editor.org/rfc/rfc7230#section-3.2.6
#
# source://ddtrace//lib/datadog/appsec/utils/http/media_type.rb#17
Datadog::AppSec::Utils::HTTP::MediaType::TOKEN_RE = T.let(T.unsafe(nil), Regexp)

# source://ddtrace//lib/datadog/appsec/utils/http/media_type.rb#14
Datadog::AppSec::Utils::HTTP::MediaType::WILDCARD = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/ddtrace/auto_instrument.rb#12
module Datadog::AutoInstrument; end

# Flag to determine if Auto Instrumentation was used
#
# source://ddtrace//lib/ddtrace/auto_instrument.rb#14
Datadog::AutoInstrument::LOADED = T.let(T.unsafe(nil), TrueClass)

# Namespace for Datadog CI instrumentation:
# e.g. rspec, cucumber, etc...
#
# source://ddtrace//lib/datadog/ci.rb#10
module Datadog::CI; end

# source://ddtrace//lib/datadog/ci/configuration/settings.rb#7
module Datadog::CI::Configuration; end

# Adds CI behavior to Datadog trace components
#
# source://ddtrace//lib/datadog/ci/configuration/components.rb#9
module Datadog::CI::Configuration::Components
  # source://ddtrace//lib/datadog/ci/configuration/components.rb#10
  def initialize(settings); end

  # source://ddtrace//lib/datadog/ci/configuration/components.rb#18
  def activate_ci!(settings); end
end

# Adds CI behavior to Datadog trace settings
#
# source://ddtrace//lib/datadog/ci/configuration/settings.rb#9
module Datadog::CI::Configuration::Settings
  class << self
    # source://ddtrace//lib/datadog/ci/configuration/settings.rb#15
    def add_settings!(base); end

    # @private
    #
    # source://ddtrace//lib/datadog/ci/configuration/settings.rb#10
    def extended(base); end
  end
end

# source://ddtrace//lib/datadog/ci/contrib/cucumber/ext.rb#5
module Datadog::CI::Contrib; end

# source://ddtrace//lib/datadog/ci/contrib/cucumber/ext.rb#6
module Datadog::CI::Contrib::Cucumber; end

# source://ddtrace//lib/datadog/ci/contrib/cucumber/configuration/settings.rb#10
module Datadog::CI::Contrib::Cucumber::Configuration; end

# Custom settings for the Cucumber integration
# TODO: mark as `@public_api` when GA
#
# source://ddtrace//lib/datadog/ci/contrib/cucumber/configuration/settings.rb#13
class Datadog::CI::Contrib::Cucumber::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def operation_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def operation_name=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# Cucumber integration constants
# TODO: mark as `@public_api` when GA, to protect from resource and tag name changes.
#
# source://ddtrace//lib/datadog/ci/contrib/cucumber/ext.rb#9
module Datadog::CI::Contrib::Cucumber::Ext; end

# source://ddtrace//lib/datadog/ci/contrib/cucumber/ext.rb#10
Datadog::CI::Contrib::Cucumber::Ext::APP = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/contrib/cucumber/ext.rb#11
Datadog::CI::Contrib::Cucumber::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/contrib/cucumber/ext.rb#12
Datadog::CI::Contrib::Cucumber::Ext::ENV_OPERATION_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/contrib/cucumber/ext.rb#13
Datadog::CI::Contrib::Cucumber::Ext::FRAMEWORK = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/contrib/cucumber/ext.rb#14
Datadog::CI::Contrib::Cucumber::Ext::OPERATION_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/contrib/cucumber/ext.rb#15
Datadog::CI::Contrib::Cucumber::Ext::SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/contrib/cucumber/ext.rb#16
Datadog::CI::Contrib::Cucumber::Ext::STEP_SPAN_TYPE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/contrib/cucumber/ext.rb#17
Datadog::CI::Contrib::Cucumber::Ext::TEST_TYPE = T.let(T.unsafe(nil), String)

# Defines collection of instrumented Cucumber events
#
# source://ddtrace//lib/datadog/ci/contrib/cucumber/formatter.rb#14
class Datadog::CI::Contrib::Cucumber::Formatter
  # @return [Formatter] a new instance of Formatter
  #
  # source://ddtrace//lib/datadog/ci/contrib/cucumber/formatter.rb#19
  def initialize(config); end

  # source://ddtrace//lib/datadog/ci/contrib/cucumber/formatter.rb#25
  def bind_events(config); end

  # source://ddtrace//lib/datadog/ci/contrib/cucumber/formatter.rb#49
  def on_test_case_finished(event); end

  # source://ddtrace//lib/datadog/ci/contrib/cucumber/formatter.rb#32
  def on_test_case_started(event); end

  # source://ddtrace//lib/datadog/ci/contrib/cucumber/formatter.rb#71
  def on_test_step_finished(event); end

  # source://ddtrace//lib/datadog/ci/contrib/cucumber/formatter.rb#63
  def on_test_step_started(event); end

  private

  # Returns the value of attribute config.
  #
  # source://ddtrace//lib/datadog/ci/contrib/cucumber/formatter.rb#15
  def config; end

  # source://ddtrace//lib/datadog/ci/contrib/cucumber/formatter.rb#87
  def configuration; end

  # Returns the value of attribute current_feature_span.
  #
  # source://ddtrace//lib/datadog/ci/contrib/cucumber/formatter.rb#15
  def current_feature_span; end

  # Returns the value of attribute current_step_span.
  #
  # source://ddtrace//lib/datadog/ci/contrib/cucumber/formatter.rb#15
  def current_step_span; end
end

# Instrumentation for Cucumber
#
# source://ddtrace//lib/datadog/ci/contrib/cucumber/instrumentation.rb#10
module Datadog::CI::Contrib::Cucumber::Instrumentation
  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/ci/contrib/cucumber/instrumentation.rb#11
    def included(base); end
  end
end

# Instance methods for configuration
#
# source://ddtrace//lib/datadog/ci/contrib/cucumber/instrumentation.rb#16
module Datadog::CI::Contrib::Cucumber::Instrumentation::InstanceMethods
  # Returns the value of attribute datadog_formatter.
  #
  # source://ddtrace//lib/datadog/ci/contrib/cucumber/instrumentation.rb#17
  def datadog_formatter; end

  # source://ddtrace//lib/datadog/ci/contrib/cucumber/instrumentation.rb#19
  def formatters; end
end

# Description of Cucumber integration
#
# source://ddtrace//lib/datadog/ci/contrib/cucumber/integration.rb#11
class Datadog::CI::Contrib::Cucumber::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # test environments should not auto instrument test libraries
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/ci/contrib/cucumber/integration.rb#32
  def auto_instrument?; end

  # source://ddtrace//lib/datadog/ci/contrib/cucumber/integration.rb#36
  def new_configuration; end

  # source://ddtrace//lib/datadog/ci/contrib/cucumber/integration.rb#40
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/ci/contrib/cucumber/integration.rb#27
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/ci/contrib/cucumber/integration.rb#23
    def loaded?; end

    # source://ddtrace//lib/datadog/ci/contrib/cucumber/integration.rb#18
    def version; end
  end
end

# source://ddtrace//lib/datadog/ci/contrib/cucumber/integration.rb#14
Datadog::CI::Contrib::Cucumber::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'cucumber' module.
#
# source://ddtrace//lib/datadog/ci/contrib/cucumber/patcher.rb#11
module Datadog::CI::Contrib::Cucumber::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/ci/contrib/cucumber/patcher.rb#20
  def patch; end

  # source://ddtrace//lib/datadog/ci/contrib/cucumber/patcher.rb#16
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/ci/contrib/cucumber/patcher.rb#16
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/ci/contrib/minitest/ext.rb#6
module Datadog::CI::Contrib::Minitest; end

# source://ddtrace//lib/datadog/ci/contrib/minitest/configuration/settings.rb#10
module Datadog::CI::Contrib::Minitest::Configuration; end

# Custom settings for the Minitest integration
# TODO: mark as `@public_api` when GA
#
# source://ddtrace//lib/datadog/ci/contrib/minitest/configuration/settings.rb#13
class Datadog::CI::Contrib::Minitest::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def operation_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def operation_name=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# Minitest integration constants
# TODO: mark as `@public_api` when GA, to protect from resource and tag name changes.
#
# source://ddtrace//lib/datadog/ci/contrib/minitest/ext.rb#9
module Datadog::CI::Contrib::Minitest::Ext; end

# source://ddtrace//lib/datadog/ci/contrib/minitest/ext.rb#10
Datadog::CI::Contrib::Minitest::Ext::APP = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/contrib/minitest/ext.rb#11
Datadog::CI::Contrib::Minitest::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/contrib/minitest/ext.rb#12
Datadog::CI::Contrib::Minitest::Ext::ENV_OPERATION_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/contrib/minitest/ext.rb#13
Datadog::CI::Contrib::Minitest::Ext::FRAMEWORK = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/contrib/minitest/ext.rb#14
Datadog::CI::Contrib::Minitest::Ext::OPERATION_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/contrib/minitest/ext.rb#15
Datadog::CI::Contrib::Minitest::Ext::SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/contrib/minitest/ext.rb#16
Datadog::CI::Contrib::Minitest::Ext::TEST_TYPE = T.let(T.unsafe(nil), String)

# Description of Minitest integration
#
# source://ddtrace//lib/datadog/ci/contrib/minitest/integration.rb#13
class Datadog::CI::Contrib::Minitest::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # test environments should not auto instrument test libraries
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/ci/contrib/minitest/integration.rb#34
  def auto_instrument?; end

  # source://ddtrace//lib/datadog/ci/contrib/minitest/integration.rb#38
  def new_configuration; end

  # source://ddtrace//lib/datadog/ci/contrib/minitest/integration.rb#42
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/ci/contrib/minitest/integration.rb#29
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/ci/contrib/minitest/integration.rb#25
    def loaded?; end

    # source://ddtrace//lib/datadog/ci/contrib/minitest/integration.rb#20
    def version; end
  end
end

# source://ddtrace//lib/datadog/ci/contrib/minitest/integration.rb#16
Datadog::CI::Contrib::Minitest::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'minitest' module.
#
# source://ddtrace//lib/datadog/ci/contrib/minitest/patcher.rb#11
module Datadog::CI::Contrib::Minitest::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/ci/contrib/minitest/patcher.rb#20
  def patch; end

  # source://ddtrace//lib/datadog/ci/contrib/minitest/patcher.rb#16
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/ci/contrib/minitest/patcher.rb#16
    def target_version; end
  end
end

# Instrument Minitest::Test
#
# source://ddtrace//lib/datadog/ci/contrib/minitest/test_helper.rb#10
module Datadog::CI::Contrib::Minitest::TestHelper
  # source://ddtrace//lib/datadog/ci/contrib/minitest/test_helper.rb#38
  def after_teardown; end

  # source://ddtrace//lib/datadog/ci/contrib/minitest/test_helper.rb#11
  def before_setup; end

  private

  # source://ddtrace//lib/datadog/ci/contrib/minitest/test_helper.rb#61
  def configuration; end
end

# source://ddtrace//lib/datadog/ci/contrib/rspec/ext.rb#6
module Datadog::CI::Contrib::RSpec; end

# source://ddtrace//lib/datadog/ci/contrib/rspec/configuration/settings.rb#10
module Datadog::CI::Contrib::RSpec::Configuration; end

# Custom settings for the RSpec integration
# TODO: mark as `@public_api` when GA
#
# source://ddtrace//lib/datadog/ci/contrib/rspec/configuration/settings.rb#13
class Datadog::CI::Contrib::RSpec::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def operation_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def operation_name=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# Instrument RSpec::Core::Example
#
# source://ddtrace//lib/datadog/ci/contrib/rspec/example.rb#13
module Datadog::CI::Contrib::RSpec::Example
  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/ci/contrib/rspec/example.rb#14
    def included(base); end
  end
end

# Instance methods for configuration
#
# source://ddtrace//lib/datadog/ci/contrib/rspec/example.rb#19
module Datadog::CI::Contrib::RSpec::Example::InstanceMethods
  # source://ddtrace//lib/datadog/ci/contrib/rspec/example.rb#20
  def run(example_group_instance, reporter); end

  private

  # source://ddtrace//lib/datadog/ci/contrib/rspec/example.rb#60
  def configuration; end
end

# RSpec integration constants
# TODO: mark as `@public_api` when GA, to protect from resource and tag name changes.
#
# source://ddtrace//lib/datadog/ci/contrib/rspec/ext.rb#9
module Datadog::CI::Contrib::RSpec::Ext; end

# source://ddtrace//lib/datadog/ci/contrib/rspec/ext.rb#10
Datadog::CI::Contrib::RSpec::Ext::APP = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/contrib/rspec/ext.rb#11
Datadog::CI::Contrib::RSpec::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/contrib/rspec/ext.rb#12
Datadog::CI::Contrib::RSpec::Ext::ENV_OPERATION_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/contrib/rspec/ext.rb#13
Datadog::CI::Contrib::RSpec::Ext::FRAMEWORK = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/contrib/rspec/ext.rb#14
Datadog::CI::Contrib::RSpec::Ext::OPERATION_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/contrib/rspec/ext.rb#15
Datadog::CI::Contrib::RSpec::Ext::SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/contrib/rspec/ext.rb#16
Datadog::CI::Contrib::RSpec::Ext::TEST_TYPE = T.let(T.unsafe(nil), String)

# Description of RSpec integration
#
# source://ddtrace//lib/datadog/ci/contrib/rspec/integration.rb#11
class Datadog::CI::Contrib::RSpec::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # test environments should not auto instrument test libraries
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/ci/contrib/rspec/integration.rb#33
  def auto_instrument?; end

  # source://ddtrace//lib/datadog/ci/contrib/rspec/integration.rb#37
  def new_configuration; end

  # source://ddtrace//lib/datadog/ci/contrib/rspec/integration.rb#41
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/ci/contrib/rspec/integration.rb#28
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/ci/contrib/rspec/integration.rb#23
    def loaded?; end

    # source://ddtrace//lib/datadog/ci/contrib/rspec/integration.rb#18
    def version; end
  end
end

# source://ddtrace//lib/datadog/ci/contrib/rspec/integration.rb#14
Datadog::CI::Contrib::RSpec::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'rspec' module.
#
# source://ddtrace//lib/datadog/ci/contrib/rspec/patcher.rb#11
module Datadog::CI::Contrib::RSpec::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/ci/contrib/rspec/patcher.rb#20
  def patch; end

  # source://ddtrace//lib/datadog/ci/contrib/rspec/patcher.rb#16
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/ci/contrib/rspec/patcher.rb#16
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/ci/ext/app_types.rb#3
module Datadog::CI::Ext; end

# source://ddtrace//lib/datadog/ci/ext/app_types.rb#4
module Datadog::CI::Ext::AppTypes; end

# source://ddtrace//lib/datadog/ci/ext/app_types.rb#5
Datadog::CI::Ext::AppTypes::TYPE_TEST = T.let(T.unsafe(nil), String)

# Defines constants for CI tags
#
# source://ddtrace//lib/datadog/ci/ext/environment.rb#12
module Datadog::CI::Ext::Environment
  private

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#551
  def branch_or_tag(branch_or_tag); end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#515
  def exec_git_command(cmd); end

  # CI providers
  #
  # source://ddtrace//lib/datadog/ci/ext/environment.rb#90
  def extract_appveyor(env); end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#124
  def extract_azure_pipelines(env); end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#165
  def extract_bitbucket(env); end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#372
  def extract_bitrise(env); end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#183
  def extract_buddy(env); end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#201
  def extract_buildkite(env); end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#234
  def extract_circle_ci(env); end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#402
  def extract_codefresh(env); end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#257
  def extract_github_actions(env); end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#287
  def extract_gitlab(env); end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#318
  def extract_jenkins(env); end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#527
  def extract_local_git; end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#562
  def extract_name_email(name_and_email); end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#347
  def extract_teamcity(env); end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#355
  def extract_travis(env); end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#419
  def extract_user_defined_git(env); end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#84
  def filter_sensitive_info(url); end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#506
  def git_base_directory; end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#479
  def git_branch; end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#470
  def git_commit_message; end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#488
  def git_commit_sha; end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#435
  def git_commit_users; end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#461
  def git_repository_url; end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#497
  def git_tag; end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#77
  def normalize_ref(name); end

  # source://ddtrace//lib/datadog/ci/ext/environment.rb#44
  def tags(env); end

  class << self
    # source://ddtrace//lib/datadog/ci/ext/environment.rb#551
    def branch_or_tag(branch_or_tag); end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#515
    def exec_git_command(cmd); end

    # CI providers
    #
    # source://ddtrace//lib/datadog/ci/ext/environment.rb#90
    def extract_appveyor(env); end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#124
    def extract_azure_pipelines(env); end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#165
    def extract_bitbucket(env); end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#372
    def extract_bitrise(env); end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#183
    def extract_buddy(env); end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#201
    def extract_buildkite(env); end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#234
    def extract_circle_ci(env); end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#402
    def extract_codefresh(env); end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#257
    def extract_github_actions(env); end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#287
    def extract_gitlab(env); end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#318
    def extract_jenkins(env); end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#527
    def extract_local_git; end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#562
    def extract_name_email(name_and_email); end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#347
    def extract_teamcity(env); end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#355
    def extract_travis(env); end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#419
    def extract_user_defined_git(env); end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#84
    def filter_sensitive_info(url); end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#506
    def git_base_directory; end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#479
    def git_branch; end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#470
    def git_commit_message; end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#488
    def git_commit_sha; end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#435
    def git_commit_users; end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#461
    def git_repository_url; end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#497
    def git_tag; end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#77
    def normalize_ref(name); end

    # source://ddtrace//lib/datadog/ci/ext/environment.rb#44
    def tags(env); end
  end
end

# source://ddtrace//lib/datadog/ci/ext/environment.rb#26
Datadog::CI::Ext::Environment::PROVIDERS = T.let(T.unsafe(nil), Array)

# source://ddtrace//lib/datadog/ci/ext/environment.rb#24
Datadog::CI::Ext::Environment::TAG_CI_ENV_VARS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/environment.rb#13
Datadog::CI::Ext::Environment::TAG_JOB_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/environment.rb#14
Datadog::CI::Ext::Environment::TAG_JOB_URL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/environment.rb#22
Datadog::CI::Ext::Environment::TAG_NODE_LABELS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/environment.rb#23
Datadog::CI::Ext::Environment::TAG_NODE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/environment.rb#15
Datadog::CI::Ext::Environment::TAG_PIPELINE_ID = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/environment.rb#16
Datadog::CI::Ext::Environment::TAG_PIPELINE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/environment.rb#17
Datadog::CI::Ext::Environment::TAG_PIPELINE_NUMBER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/environment.rb#18
Datadog::CI::Ext::Environment::TAG_PIPELINE_URL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/environment.rb#19
Datadog::CI::Ext::Environment::TAG_PROVIDER_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/environment.rb#20
Datadog::CI::Ext::Environment::TAG_STAGE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/environment.rb#21
Datadog::CI::Ext::Environment::TAG_WORKSPACE_PATH = T.let(T.unsafe(nil), String)

# Defines constants for test tags
#
# source://ddtrace//lib/datadog/ci/ext/settings.rb#5
module Datadog::CI::Ext::Settings; end

# source://ddtrace//lib/datadog/ci/ext/settings.rb#6
Datadog::CI::Ext::Settings::ENV_MODE_ENABLED = T.let(T.unsafe(nil), String)

# Defines constants for test tags
#
# source://ddtrace//lib/datadog/ci/ext/test.rb#5
module Datadog::CI::Ext::Test; end

# source://ddtrace//lib/datadog/ci/ext/test.rb#6
Datadog::CI::Ext::Test::CONTEXT_ORIGIN = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/test.rb#27
module Datadog::CI::Ext::Test::Status; end

# source://ddtrace//lib/datadog/ci/ext/test.rb#29
Datadog::CI::Ext::Test::Status::FAIL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/test.rb#28
Datadog::CI::Ext::Test::Status::PASS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/test.rb#30
Datadog::CI::Ext::Test::Status::SKIP = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/test.rb#8
Datadog::CI::Ext::Test::TAG_ARGUMENTS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/test.rb#9
Datadog::CI::Ext::Test::TAG_FRAMEWORK = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/test.rb#10
Datadog::CI::Ext::Test::TAG_FRAMEWORK_VERSION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/test.rb#11
Datadog::CI::Ext::Test::TAG_NAME = T.let(T.unsafe(nil), String)

# Environment runtime tags
#
# source://ddtrace//lib/datadog/ci/ext/test.rb#19
Datadog::CI::Ext::Test::TAG_OS_ARCHITECTURE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/test.rb#20
Datadog::CI::Ext::Test::TAG_OS_PLATFORM = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/test.rb#21
Datadog::CI::Ext::Test::TAG_RUNTIME_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/test.rb#22
Datadog::CI::Ext::Test::TAG_RUNTIME_VERSION = T.let(T.unsafe(nil), String)

# DEV: Not populated yet
#
# source://ddtrace//lib/datadog/ci/ext/test.rb#12
Datadog::CI::Ext::Test::TAG_SKIP_REASON = T.let(T.unsafe(nil), String)

# TODO: is there a better place for SPAN_KIND?
#
# source://ddtrace//lib/datadog/ci/ext/test.rb#25
Datadog::CI::Ext::Test::TAG_SPAN_KIND = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/test.rb#13
Datadog::CI::Ext::Test::TAG_STATUS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/test.rb#14
Datadog::CI::Ext::Test::TAG_SUITE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/test.rb#15
Datadog::CI::Ext::Test::TAG_TRAITS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/ci/ext/test.rb#16
Datadog::CI::Ext::Test::TAG_TYPE = T.let(T.unsafe(nil), String)

# Extends Datadog tracing with CI features
#
# source://ddtrace//lib/datadog/ci/extensions.rb#12
module Datadog::CI::Extensions
  class << self
    # source://ddtrace//lib/datadog/ci/extensions.rb#13
    def activate!; end
  end
end

# source://ddtrace//lib/datadog/ci/flush.rb#8
module Datadog::CI::Flush; end

# Consumes only completed traces (where all spans have finished)
#
# source://ddtrace//lib/datadog/ci/flush.rb#28
class Datadog::CI::Flush::Finished < ::Datadog::Tracing::Flush::Finished
  include ::Datadog::CI::Flush::Tagging
end

# Performs partial trace flushing to avoid large traces residing in memory for too long
#
# source://ddtrace//lib/datadog/ci/flush.rb#33
class Datadog::CI::Flush::Partial < ::Datadog::Tracing::Flush::Partial
  include ::Datadog::CI::Flush::Tagging
end

# Common behavior for CI flushing
#
# source://ddtrace//lib/datadog/ci/flush.rb#10
module Datadog::CI::Flush::Tagging
  # Decorate a trace with CI tags
  #
  # source://ddtrace//lib/datadog/ci/flush.rb#12
  def get_trace(trace_op); end
end

# Common behavior for CI tests
#
# source://ddtrace//lib/datadog/ci/test.rb#13
module Datadog::CI::Test
  class << self
    # source://ddtrace//lib/datadog/ci/test.rb#62
    def failed!(span, exception = T.unsafe(nil)); end

    # source://ddtrace//lib/datadog/ci/test.rb#58
    def passed!(span); end

    # Adds tags to a CI test span.
    #
    # source://ddtrace//lib/datadog/ci/test.rb#34
    def set_tags!(trace, span, tags = T.unsafe(nil)); end

    # source://ddtrace//lib/datadog/ci/test.rb#68
    def skipped!(span, exception = T.unsafe(nil)); end

    # Creates a new span for a CI test
    #
    # source://ddtrace//lib/datadog/ci/test.rb#15
    def trace(span_name, options = T.unsafe(nil)); end

    private

    # source://ddtrace//lib/datadog/ci/test.rb#73
    def set_environment_runtime_tags!(span); end
  end
end

# Common, lower level, internal code used (or usable) by two or more
# products. It is a dependency of each product. Contrast with Datadog::Kit
# for higher-level features.
#
# source://ddtrace//lib/datadog/core/environment/variable_helpers.rb#4
module Datadog::Core
  class << self
    # Records the occurrence of a deprecated operation in this library.
    #
    # Currently, these operations are logged to `Datadog.logger` at `warn` level.
    #
    # `disallowed_next_major` adds a message informing that the deprecated operation
    # won't be allowed in the next major release.
    #
    # @param disallowed_next_major [Boolean] whether this deprecation will be enforced in the next major release.
    # @yieldreturn [String] a String with the lazily evaluated deprecation message.
    #
    # source://ddtrace//lib/datadog/core.rb#22
    def log_deprecation(disallowed_next_major: T.unsafe(nil)); end
  end
end

# This module is used to provide features from Ruby 2.4+ to older Rubies
#
# source://ddtrace//lib/datadog/core/backport.rb#24
module Datadog::Core::BackportFrom24
  class << self
    # source://ddtrace//lib/datadog/core/backport.rb#35
    def dup(value); end

    # source://ddtrace//lib/datadog/core/backport.rb#41
    def hash_compact!(hash); end
  end
end

# This module is used to provide features from Ruby 2.5+ to older Rubies
#
# source://ddtrace//lib/datadog/core/backport.rb#6
module Datadog::Core::BackportFrom25
  class << self
    # source://ddtrace//lib/datadog/core/backport.rb#8
    def string_delete_prefix(string, prefix); end
  end
end

# source://ddtrace//lib/datadog/core/buffer/random.rb#5
module Datadog::Core::Buffer; end

# Buffer that stores objects, has a maximum size, and
# can be safely used concurrently with CRuby.
#
# Because singular +Array+ operations are thread-safe in CRuby,
# we can implement the buffer without an explicit lock,
# while making the compromise of allowing the buffer to go
# over its maximum limit under extreme circumstances.
#
# On the following scenario:
# * 4.5 million spans/second.
# * Pushed into a single CRubyTraceBuffer from 1000 threads.
#
# This implementation allocates less memory and is faster
# than {Datadog::Core::Buffer::ThreadSafe}.
#
# @see spec/ddtrace/benchmark/buffer_benchmark_spec.rb Buffer benchmarks
# @see https://github.com/ruby-concurrency/concurrent-ruby/blob/c1114a0c6891d9634f019f1f9fe58dcae8658964/lib/concurrent-ruby/concurrent/array.rb#L23-L27
#
# source://ddtrace//lib/datadog/core/buffer/cruby.rb#25
class Datadog::Core::Buffer::CRuby < ::Datadog::Core::Buffer::Random
  # Add a new ``item`` in the local queue. This method doesn't block the execution
  # even if the buffer is full. In that case, a random item is discarded.
  #
  # source://ddtrace//lib/datadog/core/buffer/cruby.rb#32
  def replace!(item); end
end

# A very large number to allow us to effectively
# drop all items when invoking `slice!(i, FIXNUM_MAX)`.
#
# source://ddtrace//lib/datadog/core/buffer/cruby.rb#28
Datadog::Core::Buffer::CRuby::FIXNUM_MAX = T.let(T.unsafe(nil), Integer)

# Buffer that stores objects. The buffer has a maximum size and when
# the buffer is full, a random object is discarded.
#
# source://ddtrace//lib/datadog/core/buffer/random.rb#11
class Datadog::Core::Buffer::Random
  # @return [Random] a new instance of Random
  #
  # source://ddtrace//lib/datadog/core/buffer/random.rb#12
  def initialize(max_size); end

  # Closes this buffer, preventing further pushing.
  # Draining is still allowed.
  #
  # source://ddtrace//lib/datadog/core/buffer/random.rb#63
  def close; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/buffer/random.rb#67
  def closed?; end

  # A bulk push alternative to +#push+. Use this method if
  # pushing more than one item for efficiency.
  #
  # source://ddtrace//lib/datadog/core/buffer/random.rb#33
  def concat(items); end

  # Return if the buffer is empty.
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/buffer/random.rb#57
  def empty?; end

  # Return the current number of stored items.
  #
  # source://ddtrace//lib/datadog/core/buffer/random.rb#52
  def length; end

  # Stored items are returned and the local buffer is reset.
  #
  # source://ddtrace//lib/datadog/core/buffer/random.rb#47
  def pop; end

  # Add a new ``item`` in the local queue. This method doesn't block the execution
  # even if the buffer is full.
  #
  # When the buffer is full, we try to ensure that we are fairly choosing newly
  # pushed items by randomly inserting them into the buffer slots. This discards
  # old items randomly while trying to ensure that recent items are still captured.
  #
  # source://ddtrace//lib/datadog/core/buffer/random.rb#24
  def push(item); end

  protected

  # source://ddtrace//lib/datadog/core/buffer/random.rb#110
  def add!(item); end

  # source://ddtrace//lib/datadog/core/buffer/random.rb#106
  def add_all!(items); end

  # source://ddtrace//lib/datadog/core/buffer/random.rb#126
  def drain!; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/buffer/random.rb#102
  def full?; end

  # Segment items into two segments: underflow and overflow.
  # Underflow are items that will fit into buffer.
  # Overflow are items that will exceed capacity, after underflow is added.
  # Returns each array, and nil if there is no underflow/overflow.
  #
  # source://ddtrace//lib/datadog/core/buffer/random.rb#77
  def overflow_segments(items); end

  # source://ddtrace//lib/datadog/core/buffer/random.rb#114
  def replace!(item); end
end

# Buffer that stores objects, has a maximum size, and
# can be safely used concurrently on any environment.
#
# This implementation uses a {Mutex} around public methods, incurring
# overhead in order to ensure thread-safety.
#
# This is implementation is recommended for non-CRuby environments.
# If using CRuby, {Datadog::Core::Buffer::CRuby} is a faster implementation with minimal compromise.
#
# source://ddtrace//lib/datadog/core/buffer/thread_safe.rb#16
class Datadog::Core::Buffer::ThreadSafe < ::Datadog::Core::Buffer::Random
  # @return [ThreadSafe] a new instance of ThreadSafe
  #
  # source://ddtrace//lib/datadog/core/buffer/thread_safe.rb#17
  def initialize(max_size); end

  # source://ddtrace//lib/datadog/core/buffer/thread_safe.rb#48
  def close; end

  # source://ddtrace//lib/datadog/core/buffer/thread_safe.rb#29
  def concat(items); end

  # Return if the buffer is empty.
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/buffer/thread_safe.rb#39
  def empty?; end

  # Return the current number of stored items.
  #
  # source://ddtrace//lib/datadog/core/buffer/thread_safe.rb#34
  def length; end

  # Stored items are returned and the local buffer is reset.
  #
  # source://ddtrace//lib/datadog/core/buffer/thread_safe.rb#44
  def pop; end

  # Add a new ``item`` in the local queue. This method doesn't block the execution
  # even if the buffer is full. In that case, a random item is discarded.
  #
  # source://ddtrace//lib/datadog/core/buffer/thread_safe.rb#25
  def push(item); end

  # source://ddtrace//lib/datadog/core/buffer/thread_safe.rb#52
  def synchronize(&block); end
end

# Chunks list of elements into batches
#
# source://ddtrace//lib/datadog/core/chunker.rb#6
module Datadog::Core::Chunker
  private

  # Chunks a list into batches of at most +max_chunk_size+ elements each.
  #
  # An exception can occur if a single element is too large. That single
  # element will be returned in its own chunk. You have to verify by yourself
  # when such elements are returned.
  #
  # @param list [Enumerable] list of elements
  # @param max_chunk_size [Numeric] maximum acceptable chunk size
  # @return [Enumerable] lazy list of chunks
  #
  # source://ddtrace//lib/datadog/core/chunker.rb#18
  def chunk_by_size(list, max_chunk_size); end

  class << self
    # Chunks a list into batches of at most +max_chunk_size+ elements each.
    #
    # An exception can occur if a single element is too large. That single
    # element will be returned in its own chunk. You have to verify by yourself
    # when such elements are returned.
    #
    # @param list [Enumerable] list of elements
    # @param max_chunk_size [Numeric] maximum acceptable chunk size
    # @return [Enumerable] lazy list of chunks
    #
    # source://ddtrace//lib/datadog/core/chunker.rb#18
    def chunk_by_size(list, max_chunk_size); end
  end
end

# Configuration provides a unique access point for configurations
#
# source://ddtrace//lib/datadog/core/configuration/option_set.rb#5
module Datadog::Core::Configuration
  # Current Datadog configuration.
  #
  # Access to non-global configuration will raise an error.
  #
  # To modify the configuration, use {.configure}.
  #
  # @return [Datadog::Core::Configuration::Settings]
  #
  # source://ddtrace//lib/datadog/core/configuration.rb#49
  def configuration; end

  # Sets the attribute configuration
  #
  # @param value the value to set the attribute configuration to.
  #
  # source://ddtrace//lib/datadog/core/configuration.rb#38
  def configuration=(_arg0); end

  # Get configuration changes applied only to a specific Ruby object, via {.configure_onto}.
  # An example of an object with specific configuration:
  #
  # ```
  # client = Net::HTTP.new(host, port)
  # Datadog.configure_onto(client, service_name: 'api-requests', split_by_domain: true)
  # config = Datadog.configuration_for(client)
  # config[:service_name] # => 'api-requests'
  # config[:split_by_domain] # => true
  # ```
  #
  # @param target [Object] the object to receive configuration options
  # @param option [Object] an option to retrieve from the object configuration
  #
  # source://ddtrace//lib/datadog/core/configuration.rb#147
  def configuration_for(target, option = T.unsafe(nil)); end

  # Apply global configuration changes to `Datadog`. An example of a {.configure} call:
  #
  # ```
  # Datadog.configure do |c|
  #   c.service = 'my-service'
  #   c.env = 'staging'
  #   # c.diagnostics.debug = true # Enables debug output
  # end
  # ```
  #
  # See {Datadog::Core::Configuration::Settings} for all available options, defaults, and
  # available environment variables for configuration.
  #
  # Only permits access to global configuration settings; others will raise an error.
  # If you wish to configure a setting for a specific Datadog component (e.g. Tracing),
  # use the corresponding `Datadog::COMPONENT.configure` method instead.
  #
  # Because many configuration changes require restarting internal components,
  # invoking {.configure} is the only safe way to change `Datadog` configuration.
  #
  # Successive calls to {.configure} maintain the previous configuration values:
  # configuration is additive between {.configure} calls.
  #
  # The yielded configuration `c` comes pre-populated from environment variables, if
  # any are applicable.
  #
  # @yieldparam c [Datadog::Core::Configuration::Settings] the mutable configuration object
  #
  # source://ddtrace//lib/datadog/core/configuration.rb#80
  def configure; end

  # Apply configuration changes only to a specific Ruby object.
  #
  # Certain integrations or Datadog features may use these
  # settings to customize behavior for this object.
  #
  # An example of a {.configure_onto} call:
  #
  # ```
  # client = Net::HTTP.new(host, port)
  # Datadog.configure_onto(client, service_name: 'api-requests', split_by_domain: true)
  # ```
  #
  # In this example, it will configure the `client` object with custom options
  # `service_name: 'api-requests', split_by_domain: true`. The `Net::HTTP` integration
  # will then use these customized options when the `client` is used, whereas other
  # clients will use the `service_name: 'http-requests'` configuration provided to the
  # `Datadog.configure` call block.
  #
  # {.configure_onto} is used to separate cases where spans generated by certain objects
  # require exceptional options.
  #
  # The configuration keyword arguments provided should match well known options defined
  # in the integration or feature that would use them.
  #
  # For example, for `Datadog.configure_onto(redis_client, **opts)`, `opts` can be
  # any of the options in the Redis {Datadog::Tracing::Contrib::Redis::Configuration::Settings} class.
  #
  # @param target [Object] the object to receive configuration options
  # @param opts [Hash] keyword arguments respective to the integration this object belongs to
  #
  # source://ddtrace//lib/datadog/core/configuration.rb#129
  def configure_onto(target, **opts); end

  # Internal {Datadog::Statsd} metrics collection.
  #
  # The list of metrics collected can be found in {Datadog::Core::Diagnostics::Ext::Health::Metrics}.
  #
  # source://ddtrace//lib/datadog/core/configuration.rb#158
  def health_metrics; end

  # source://ddtrace//lib/datadog/core/configuration.rb#162
  def logger; end

  # Gracefully shuts down all components.
  #
  # Components will still respond to method calls as usual,
  # but might not internally perform their work after shutdown.
  #
  # This avoids errors being raised across the host application
  # during shutdown, while allowing for graceful decommission of resources.
  #
  # Components won't be automatically reinitialized after a shutdown.
  #
  # source://ddtrace//lib/datadog/core/configuration.rb#183
  def shutdown!; end

  protected

  # source://ddtrace//lib/datadog/core/configuration.rb#191
  def components(allow_initialization: T.unsafe(nil)); end

  private

  # source://ddtrace//lib/datadog/core/configuration.rb#247
  def build_components(settings); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/configuration.rb#242
  def components?; end

  # Called from our at_exit hook whenever there was a pending Interrupt exception (e.g. typically due to ctrl+c)
  # to print a nice message whenever we're taking a bit longer than usual to finish the process.
  #
  # source://ddtrace//lib/datadog/core/configuration.rb#273
  def handle_interrupt_shutdown!; end

  # source://ddtrace//lib/datadog/core/configuration.rb#261
  def logger_without_components; end

  # source://ddtrace//lib/datadog/core/configuration.rb#253
  def replace_components!(settings, old); end

  # Gracefully shuts down Datadog components and disposes of component references,
  # allowing execution to start anew.
  #
  # In contrast with +#shutdown!+, components will be automatically
  # reinitialized after a reset.
  #
  # Used internally to ensure a clean environment between test runs.
  #
  # source://ddtrace//lib/datadog/core/configuration.rb#209
  def reset!; end

  # source://ddtrace//lib/datadog/core/configuration.rb#221
  def safely_synchronize; end
end

# This class unifies all the different ways that users can configure how we talk to the agent.
#
# It has quite a lot of complexity, but this complexity just reflects the actual complexity we have around our
# configuration today. E.g., this is just all of the complexity regarding agent settings gathered together in a
# single place. As we deprecate more and more of the different ways that these things can be configured,
# this class will reflect that simplification as well.
#
# Whenever there is a conflict (different configurations are provided in different orders), it MUST warn the users
# about it and pick a value based on the following priority: code > environment variable > defaults.
#
# source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#19
class Datadog::Core::Configuration::AgentSettingsResolver
  # @return [AgentSettingsResolver] a new instance of AgentSettingsResolver
  #
  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#62
  def initialize(settings, logger: T.unsafe(nil)); end

  private

  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#97
  def adapter; end

  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#67
  def call; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#228
  def can_use_uds?; end

  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#105
  def configured_hostname; end

  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#128
  def configured_port; end

  # In transport_options, we try to invoke the transport_options proc and get its configuration. In case that
  # doesn't work, we include the proc directly in the agent settings result.
  #
  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#203
  def deprecated_for_removal_transport_configuration_proc; end

  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#169
  def hostname; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#287
  def http_scheme?(uri); end

  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#283
  def log_warning(message); end

  # Returns the value of attribute logger.
  #
  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#58
  def logger; end

  # When we have mixed settings for http/https and uds, we print a warning and ignore the uds settings
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#301
  def mixed_http_and_uds?; end

  # Expected to return nil (not false!) when it's not http
  #
  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#292
  def parsed_http_url; end

  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#235
  def parsed_url; end

  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#260
  def pick_from(*configurations_in_priority_order); end

  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#173
  def port; end

  # Returns the value of attribute settings.
  #
  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#58
  def settings; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#224
  def should_use_uds?; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#164
  def ssl?; end

  # Defaults to +nil+, letting the adapter choose what default
  # works best in their case.
  #
  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#197
  def timeout_seconds; end

  # The settings.tracing.transport_options allows users to have full control over the settings used to
  # communicate with the agent. In the general case, we can't extract the configuration from this proc, but
  # in the specific case of the http and unix socket adapters we can, and we use this method together with the
  # `TransportOptionsResolver` to call the proc and extract its information.
  #
  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#328
  def transport_options; end

  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#151
  def try_parsing_as_integer(value:, friendly_name:); end

  # We only use the default unix socket if it is already present.
  # This is by design, as we still want to use the default host:port if no unix socket is present.
  #
  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#211
  def uds_fallback; end

  # Unix socket path in the file system
  #
  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#178
  def uds_path; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#296
  def unix_scheme?(uri); end

  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#272
  def warn_if_configuration_mismatch(detected_configurations_in_priority_order); end

  class << self
    # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#52
    def call(settings, logger: T.unsafe(nil)); end
  end
end

# source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#21
class Datadog::Core::Configuration::AgentSettingsResolver::AgentSettings < ::Struct
  # @return [AgentSettings] a new instance of AgentSettings
  #
  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#30
  def initialize(adapter:, ssl:, hostname:, port:, uds_path:, timeout_seconds:, deprecated_for_removal_transport_configuration_proc:); end

  # Returns the value of attribute adapter
  #
  # @return [Object] the current value of adapter
  def adapter; end

  # Sets the attribute adapter
  #
  # @param value [Object] the value to set the attribute adapter to.
  # @return [Object] the newly set value
  def adapter=(_); end

  # Returns the value of attribute deprecated_for_removal_transport_configuration_proc
  #
  # @return [Object] the current value of deprecated_for_removal_transport_configuration_proc
  def deprecated_for_removal_transport_configuration_proc; end

  # Sets the attribute deprecated_for_removal_transport_configuration_proc
  #
  # @param value [Object] the value to set the attribute deprecated_for_removal_transport_configuration_proc to.
  # @return [Object] the newly set value
  def deprecated_for_removal_transport_configuration_proc=(_); end

  # Returns the value of attribute hostname
  #
  # @return [Object] the current value of hostname
  def hostname; end

  # Sets the attribute hostname
  #
  # @param value [Object] the value to set the attribute hostname to.
  # @return [Object] the newly set value
  def hostname=(_); end

  # Returns the value of attribute port
  #
  # @return [Object] the current value of port
  def port; end

  # Sets the attribute port
  #
  # @param value [Object] the value to set the attribute port to.
  # @return [Object] the newly set value
  def port=(_); end

  # Returns the value of attribute ssl
  #
  # @return [Object] the current value of ssl
  def ssl; end

  # Sets the attribute ssl
  #
  # @param value [Object] the value to set the attribute ssl to.
  # @return [Object] the newly set value
  def ssl=(_); end

  # Returns the value of attribute timeout_seconds
  #
  # @return [Object] the current value of timeout_seconds
  def timeout_seconds; end

  # Sets the attribute timeout_seconds
  #
  # @param value [Object] the value to set the attribute timeout_seconds to.
  # @return [Object] the newly set value
  def timeout_seconds=(_); end

  # Returns the value of attribute uds_path
  #
  # @return [Object] the current value of uds_path
  def uds_path; end

  # Sets the attribute uds_path
  #
  # @param value [Object] the value to set the attribute uds_path to.
  # @return [Object] the newly set value
  def uds_path=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Represents a given configuration value and where we got it from
#
# source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#356
class Datadog::Core::Configuration::AgentSettingsResolver::DetectedConfiguration
  # @return [DetectedConfiguration] a new instance of DetectedConfiguration
  #
  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#359
  def initialize(friendly_name:, value:); end

  # Returns the value of attribute friendly_name.
  #
  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#357
  def friendly_name; end

  # Returns the value of attribute value.
  #
  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#357
  def value; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#365
  def value?; end
end

# Used to contain information extracted from the transport_options proc (see #transport_options above)
#
# source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#372
class Datadog::Core::Configuration::AgentSettingsResolver::TransportOptions < ::Struct
  # Returns the value of attribute adapter
  #
  # @return [Object] the current value of adapter
  def adapter; end

  # Sets the attribute adapter
  #
  # @param value [Object] the value to set the attribute adapter to.
  # @return [Object] the newly set value
  def adapter=(_); end

  # Returns the value of attribute hostname
  #
  # @return [Object] the current value of hostname
  def hostname; end

  # Sets the attribute hostname
  #
  # @param value [Object] the value to set the attribute hostname to.
  # @return [Object] the newly set value
  def hostname=(_); end

  # Returns the value of attribute port
  #
  # @return [Object] the current value of port
  def port; end

  # Sets the attribute port
  #
  # @param value [Object] the value to set the attribute port to.
  # @return [Object] the newly set value
  def port=(_); end

  # Returns the value of attribute ssl
  #
  # @return [Object] the current value of ssl
  def ssl; end

  # Sets the attribute ssl
  #
  # @param value [Object] the value to set the attribute ssl to.
  # @return [Object] the newly set value
  def ssl=(_); end

  # Returns the value of attribute timeout_seconds
  #
  # @return [Object] the current value of timeout_seconds
  def timeout_seconds; end

  # Sets the attribute timeout_seconds
  #
  # @param value [Object] the value to set the attribute timeout_seconds to.
  # @return [Object] the newly set value
  def timeout_seconds=(_); end

  # Returns the value of attribute uds_path
  #
  # @return [Object] the current value of uds_path
  def uds_path; end

  # Sets the attribute uds_path
  #
  # @param value [Object] the value to set the attribute uds_path to.
  # @return [Object] the newly set value
  def uds_path=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Used to extract information from the transport_options proc (see #transport_options above)
#
# source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#376
class Datadog::Core::Configuration::AgentSettingsResolver::TransportOptionsResolver
  # @return [TransportOptionsResolver] a new instance of TransportOptionsResolver
  #
  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#377
  def initialize(transport_options); end

  # source://ddtrace//lib/datadog/core/configuration/agent_settings_resolver.rb#381
  def adapter(kind_or_custom_adapter, *args, **kwargs); end
end

# Basic configuration behavior
#
# source://ddtrace//lib/datadog/core/configuration/base.rb#9
module Datadog::Core::Configuration::Base
  include ::Datadog::Core::Environment::VariableHelpers
  include ::Datadog::Core::Configuration::Options::InstanceMethods
  include ::Datadog::Core::Configuration::Options
  include ::Datadog::Core::Configuration::Base::InstanceMethods

  mixes_in_class_methods ::Datadog::Core::Environment::VariableHelpers
  mixes_in_class_methods ::Datadog::Core::Configuration::Options::ClassMethods
  mixes_in_class_methods ::Datadog::Core::Configuration::Base::ClassMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/core/configuration/base.rb#10
    def included(base); end
  end
end

# Class methods for configuration
#
# source://ddtrace//lib/datadog/core/configuration/base.rb#21
module Datadog::Core::Configuration::Base::ClassMethods
  protected

  # Allows subgroupings of settings to be defined.
  # e.g. `settings :foo { option :bar }` --> `config.foo.bar`
  #
  # @param name [Symbol] option name. Methods will be created based on this name.
  #
  # source://ddtrace//lib/datadog/core/configuration/base.rb#27
  def settings(name, &block); end

  private

  # source://ddtrace//lib/datadog/core/configuration/base.rb#44
  def new_settings_class(name, &block); end
end

# Instance methods for configuration
#
# source://ddtrace//lib/datadog/core/configuration/base.rb#54
module Datadog::Core::Configuration::Base::InstanceMethods
  # source://ddtrace//lib/datadog/core/configuration/base.rb#55
  def initialize(options = T.unsafe(nil)); end

  # @yield [_self]
  # @yieldparam _self [Datadog::Core::Configuration::Base::InstanceMethods] the object that the method was called on
  #
  # source://ddtrace//lib/datadog/core/configuration/base.rb#59
  def configure(opts = T.unsafe(nil)); end

  # Retrieves a nested option from a list of symbols
  #
  # @raise [ArgumentError]
  #
  # source://ddtrace//lib/datadog/core/configuration/base.rb#84
  def dig(*options); end

  # source://ddtrace//lib/datadog/core/configuration/base.rb#92
  def reset!; end

  # source://ddtrace//lib/datadog/core/configuration/base.rb#79
  def to_h; end
end

# We use a separate lock when reading the @components, so that they continue to be accessible during reconfiguration.
# This was needed because we ran into several issues where we still needed to read the old
# components while the COMPONENTS_WRITE_LOCK was being held (see https://github.com/DataDog/dd-trace-rb/pull/1387
# and https://github.com/DataDog/dd-trace-rb/pull/1373#issuecomment-799593022 ).
#
# Technically on MRI we could get away without this lock, but on non-MRI Rubies, we may run into issues because
# we fall into the "UnsafeDCLFactory" case of https://shipilev.net/blog/2014/safe-public-construction/ .
# Specifically, on JRuby reads from the @components do NOT have volatile semantics, and on TruffleRuby they do
# BUT just as an implementation detail, see https://github.com/jruby/jruby/wiki/Concurrency-in-jruby#volatility and
# https://github.com/DataDog/dd-trace-rb/pull/1329#issuecomment-776750377 .
# Concurrency is hard.
#
# source://ddtrace//lib/datadog/core/configuration.rb#35
Datadog::Core::Configuration::COMPONENTS_READ_LOCK = T.let(T.unsafe(nil), Thread::Mutex)

# Used to ensure that @components initialization/reconfiguration is performed one-at-a-time, by a single thread.
#
# This is important because components can end up being accessed from multiple application threads (for instance on
# a threaded webserver), and we don't want their initialization to clash (for instance, starting two profilers...).
#
# Note that a Mutex **IS NOT** reentrant: the same thread cannot grab the same Mutex more than once.
# This means below we are careful not to nest calls to methods that would trigger initialization and grab the lock.
#
# Every method that directly or indirectly mutates @components should be holding the lock (through
# #safely_synchronize) while doing so.
#
# source://ddtrace//lib/datadog/core/configuration.rb#21
Datadog::Core::Configuration::COMPONENTS_WRITE_LOCK = T.let(T.unsafe(nil), Thread::Mutex)

# Global components for the trace library.
#
# source://ddtrace//lib/datadog/core/configuration/components.rb#18
class Datadog::Core::Configuration::Components
  include ::Datadog::CI::Configuration::Components
  include ::Datadog::Tracing::Component::InstanceMethods
  extend ::Datadog::Tracing::Component

  # @return [Components] a new instance of Components
  #
  # source://ddtrace//lib/datadog/ci/configuration/components.rb#10
  def initialize(settings); end

  # Returns the value of attribute appsec.
  #
  # source://ddtrace//lib/datadog/core/configuration/components.rb#71
  def appsec; end

  # Returns the value of attribute health_metrics.
  #
  # source://ddtrace//lib/datadog/core/configuration/components.rb#71
  def health_metrics; end

  # Returns the value of attribute logger.
  #
  # source://ddtrace//lib/datadog/core/configuration/components.rb#71
  def logger; end

  # Returns the value of attribute profiler.
  #
  # source://ddtrace//lib/datadog/core/configuration/components.rb#71
  def profiler; end

  # Returns the value of attribute remote.
  #
  # source://ddtrace//lib/datadog/core/configuration/components.rb#71
  def remote; end

  # Returns the value of attribute runtime_metrics.
  #
  # source://ddtrace//lib/datadog/core/configuration/components.rb#71
  def runtime_metrics; end

  # Shuts down all the components in use.
  # If it has another instance to compare to, it will compare
  # and avoid tearing down parts still in use.
  #
  # source://ddtrace//lib/datadog/core/configuration/components.rb#118
  def shutdown!(replacement = T.unsafe(nil)); end

  # Starts up components
  #
  # source://ddtrace//lib/datadog/core/configuration/components.rb#100
  def startup!(settings); end

  # Returns the value of attribute telemetry.
  #
  # source://ddtrace//lib/datadog/core/configuration/components.rb#71
  def telemetry; end

  # Returns the value of attribute tracer.
  #
  # source://ddtrace//lib/datadog/core/configuration/components.rb#71
  def tracer; end

  class << self
    # source://ddtrace//lib/datadog/core/configuration/components.rb#22
    def build_health_metrics(settings); end

    # source://ddtrace//lib/datadog/core/configuration/components.rb#30
    def build_logger(settings); end

    # source://ddtrace//lib/datadog/core/configuration/components.rb#37
    def build_runtime_metrics(settings); end

    # source://ddtrace//lib/datadog/core/configuration/components.rb#45
    def build_runtime_metrics_worker(settings); end

    # source://ddtrace//lib/datadog/core/configuration/components.rb#55
    def build_telemetry(settings, agent_settings, logger); end
  end
end

# Resolver performs a topological sort over the dependency graph
#
# source://ddtrace//lib/datadog/core/configuration/dependency_resolver.rb#9
class Datadog::Core::Configuration::DependencyResolver
  include ::TSort

  # @return [DependencyResolver] a new instance of DependencyResolver
  #
  # source://ddtrace//lib/datadog/core/configuration/dependency_resolver.rb#12
  def initialize(dependency_graph = T.unsafe(nil)); end

  # source://tsort/0.1.1/tsort.rb#149
  def call; end

  # source://ddtrace//lib/datadog/core/configuration/dependency_resolver.rb#20
  def tsort_each_child(node, &blk); end

  # source://ddtrace//lib/datadog/core/configuration/dependency_resolver.rb#16
  def tsort_each_node(&blk); end
end

# Constants for configuration settings
# e.g. Env vars, default values, enums, etc...
#
# source://ddtrace//lib/datadog/core/configuration/ext.rb#8
module Datadog::Core::Configuration::Ext; end

# source://ddtrace//lib/datadog/core/configuration/ext.rb#10
module Datadog::Core::Configuration::Ext::Diagnostics; end

# source://ddtrace//lib/datadog/core/configuration/ext.rb#11
Datadog::Core::Configuration::Ext::Diagnostics::ENV_DEBUG_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/configuration/ext.rb#12
Datadog::Core::Configuration::Ext::Diagnostics::ENV_HEALTH_METRICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/configuration/ext.rb#13
Datadog::Core::Configuration::Ext::Diagnostics::ENV_STARTUP_LOGS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/configuration/ext.rb#16
module Datadog::Core::Configuration::Ext::Metrics; end

# source://ddtrace//lib/datadog/core/configuration/ext.rb#17
Datadog::Core::Configuration::Ext::Metrics::ENV_DEFAULT_PORT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/configuration/ext.rb#20
module Datadog::Core::Configuration::Ext::Transport; end

# source://ddtrace//lib/datadog/core/configuration/ext.rb#21
Datadog::Core::Configuration::Ext::Transport::ENV_DEFAULT_HOST = T.let(T.unsafe(nil), String)

# Represents an instance of an integration configuration option
#
# source://ddtrace//lib/datadog/core/configuration/option.rb#10
class Datadog::Core::Configuration::Option
  # @return [Option] a new instance of Option
  #
  # source://ddtrace//lib/datadog/core/configuration/option.rb#42
  def initialize(definition, context); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/configuration/option.rb#148
  def default_precedence?; end

  # source://ddtrace//lib/datadog/core/configuration/option.rb#140
  def default_value; end

  # Returns the value of attribute definition.
  #
  # source://ddtrace//lib/datadog/core/configuration/option.rb#11
  def definition; end

  # source://ddtrace//lib/datadog/core/configuration/option.rb#113
  def get; end

  # source://ddtrace//lib/datadog/core/configuration/option.rb#123
  def reset; end

  # Overrides the current value for this option if the `precedence` is equal or higher than
  # the previously set value.
  # The first call to `#set` will always store the value regardless of precedence.
  #
  # @param value [Object] the new value to be associated with this option
  # @param precedence [Precedence] from what precedence order this new value comes from
  #
  # source://ddtrace//lib/datadog/core/configuration/option.rb#62
  def set(value, precedence: T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/core/configuration/option.rb#84
  def unset(precedence); end

  private

  # source://ddtrace//lib/datadog/core/configuration/option.rb#154
  def coerce_env_variable(value); end

  # source://ddtrace//lib/datadog/core/configuration/option.rb#277
  def context_eval(&block); end

  # source://ddtrace//lib/datadog/core/configuration/option.rb#273
  def context_exec(*args, &block); end

  # Directly manipulates the current value and currently set precedence.
  #
  # source://ddtrace//lib/datadog/core/configuration/option.rb#260
  def internal_set(value, precedence); end

  # Used for testing
  #
  # source://ddtrace//lib/datadog/core/configuration/option.rb#309
  def precedence_set; end

  # source://ddtrace//lib/datadog/core/configuration/option.rb#281
  def set_value_from_env_or_default; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/configuration/option.rb#304
  def skip_validation?; end

  # source://ddtrace//lib/datadog/core/configuration/option.rb#236
  def validate(type, value); end

  # source://ddtrace//lib/datadog/core/configuration/option.rb#201
  def validate_type(value); end
end

# Option setting precedence.
#
# source://ddtrace//lib/datadog/core/configuration/option.rb#14
module Datadog::Core::Configuration::Option::Precedence; end

# Configuration that comes from default values
#
# source://ddtrace//lib/datadog/core/configuration/option.rb#36
Datadog::Core::Configuration::Option::Precedence::DEFAULT = T.let(T.unsafe(nil), Datadog::Core::Configuration::Option::Precedence::Value)

# All precedences, sorted from highest to lowest
#
# source://ddtrace//lib/datadog/core/configuration/option.rb#39
Datadog::Core::Configuration::Option::Precedence::LIST = T.let(T.unsafe(nil), Array)

# Configuration provided in Ruby code, in this same process
# or via Environment variable
#
# source://ddtrace//lib/datadog/core/configuration/option.rb#33
Datadog::Core::Configuration::Option::Precedence::PROGRAMMATIC = T.let(T.unsafe(nil), Datadog::Core::Configuration::Option::Precedence::Value)

# Remote configuration provided through the Datadog app.
#
# source://ddtrace//lib/datadog/core/configuration/option.rb#29
Datadog::Core::Configuration::Option::Precedence::REMOTE_CONFIGURATION = T.let(T.unsafe(nil), Datadog::Core::Configuration::Option::Precedence::Value)

# Represents an Option precedence level.
# Each precedence has a `numeric` value; higher values means higher precedence.
# `name` is for inspection purposes only.
#
# source://ddtrace//lib/datadog/core/configuration/option.rb#18
class Datadog::Core::Configuration::Option::Precedence::Value < ::Struct
  include ::Comparable

  # source://ddtrace//lib/datadog/core/configuration/option.rb#21
  def <=>(other); end

  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  def name=(_); end

  # Returns the value of attribute numeric
  #
  # @return [Object] the current value of numeric
  def numeric; end

  # Sets the attribute numeric
  #
  # @param value [Object] the value to set the attribute numeric to.
  # @return [Object] the newly set value
  def numeric=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Anchor object that represents a value that is not set.
# This is necessary because `nil` is a valid value to be set.
#
# source://ddtrace//lib/datadog/core/configuration/option.rb#314
Datadog::Core::Configuration::Option::UNSET = T.let(T.unsafe(nil), Object)

# Represents a definition for an integration configuration option
#
# source://ddtrace//lib/datadog/core/configuration/option_definition.rb#9
class Datadog::Core::Configuration::OptionDefinition
  # @return [OptionDefinition] a new instance of OptionDefinition
  #
  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#31
  def initialize(name, meta = T.unsafe(nil), &block); end

  # Creates a new Option, bound to the context provided.
  #
  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#48
  def build(context); end

  # Returns the value of attribute default.
  #
  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#12
  def default; end

  # Returns the value of attribute delegate_to.
  #
  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#12
  def delegate_to; end

  # Returns the value of attribute depends_on.
  #
  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#12
  def depends_on; end

  # Returns the value of attribute deprecated_env.
  #
  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#12
  def deprecated_env; end

  # Returns the value of attribute env.
  #
  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#12
  def env; end

  # Returns the value of attribute env_parser.
  #
  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#12
  def env_parser; end

  # Returns the value of attribute experimental_default_proc.
  #
  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#12
  def experimental_default_proc; end

  # Returns the value of attribute name.
  #
  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#12
  def name; end

  # Returns the value of attribute on_set.
  #
  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#12
  def on_set; end

  # Returns the value of attribute resetter.
  #
  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#12
  def resetter; end

  # Returns the value of attribute setter.
  #
  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#12
  def setter; end

  # Returns the value of attribute type.
  #
  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#12
  def type; end

  # Returns the value of attribute type_options.
  #
  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#12
  def type_options; end
end

# Acts as DSL for building OptionDefinitions
#
# source://ddtrace//lib/datadog/core/configuration/option_definition.rb#54
class Datadog::Core::Configuration::OptionDefinition::Builder
  # @return [Builder] a new instance of Builder
  # @yield [_self]
  # @yieldparam _self [Datadog::Core::Configuration::OptionDefinition::Builder] the object that the method was called on
  #
  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#60
  def initialize(name, options = T.unsafe(nil)); end

  # For applying options for OptionDefinition
  #
  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#147
  def apply_options!(options = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#100
  def default(value = T.unsafe(nil), &block); end

  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#108
  def delegate_to(&block); end

  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#84
  def depends_on(*values); end

  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#92
  def deprecated_env(value); end

  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#88
  def env(value); end

  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#96
  def env_parser(&block); end

  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#104
  def experimental_default_proc(&block); end

  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#112
  def helper(name, *_args, &block); end

  # Returns the value of attribute helpers.
  #
  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#57
  def helpers; end

  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#116
  def lazy(_value = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#169
  def meta; end

  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#126
  def on_set(&block); end

  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#130
  def resetter(&block); end

  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#134
  def setter(&block); end

  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#165
  def to_definition; end

  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#138
  def type(value, nilable: T.unsafe(nil)); end

  private

  # source://ddtrace//lib/datadog/core/configuration/option_definition.rb#188
  def validate_options!; end
end

# source://ddtrace//lib/datadog/core/configuration/option_definition.rb#55
class Datadog::Core::Configuration::OptionDefinition::Builder::InvalidOptionError < ::StandardError; end

# source://ddtrace//lib/datadog/core/configuration/option_definition.rb#10
Datadog::Core::Configuration::OptionDefinition::IDENTITY = T.let(T.unsafe(nil), Proc)

# Represents a set of configuration option definitions for an integration
#
# source://ddtrace//lib/datadog/core/configuration/option_definition_set.rb#9
class Datadog::Core::Configuration::OptionDefinitionSet < ::Hash
  # source://ddtrace//lib/datadog/core/configuration/option_definition_set.rb#14
  def dependency_graph; end

  # source://ddtrace//lib/datadog/core/configuration/option_definition_set.rb#10
  def dependency_order; end
end

# source://ddtrace//lib/datadog/core/configuration/option_set.rb#6
class Datadog::Core::Configuration::OptionSet < ::Hash; end

# Behavior for a configuration object that has options
#
# source://ddtrace//lib/datadog/core/configuration/options.rb#10
module Datadog::Core::Configuration::Options
  include ::Datadog::Core::Configuration::Options::InstanceMethods

  mixes_in_class_methods ::Datadog::Core::Configuration::Options::ClassMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/core/configuration/options.rb#11
    def included(base); end
  end
end

# Class behavior for a configuration object with options
#
# source://ddtrace//lib/datadog/core/configuration/options.rb#18
module Datadog::Core::Configuration::Options::ClassMethods
  # source://ddtrace//lib/datadog/core/configuration/options.rb#19
  def options; end

  protected

  # source://ddtrace//lib/datadog/core/configuration/options.rb#26
  def option(name, meta = T.unsafe(nil), &block); end

  private

  # source://ddtrace//lib/datadog/core/configuration/options.rb#41
  def default_helpers(name); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#54
  def define_helpers(helpers); end
end

# Instance behavior for a configuration object with options
#
# source://ddtrace//lib/datadog/core/configuration/options.rb#65
module Datadog::Core::Configuration::Options::InstanceMethods
  # source://ddtrace//lib/datadog/core/configuration/options.rb#78
  def get_option(name); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/configuration/options.rb#87
  def option_defined?(name); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#66
  def options; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#97
  def options_hash; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#82
  def reset_option(name); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#103
  def reset_options!; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#70
  def set_option(name, value, precedence: T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#74
  def unset_option(name, precedence: T.unsafe(nil)); end

  # Is this option's value the default fallback value?
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/configuration/options.rb#92
  def using_default?(name); end

  private

  # @raise [InvalidOptionError]
  #
  # source://ddtrace//lib/datadog/core/configuration/options.rb#119
  def assert_valid_option!(name); end

  # Ensure option DSL is loaded
  #
  # source://ddtrace//lib/datadog/core/configuration/options.rb#110
  def resolve_option(name); end
end

# source://ddtrace//lib/datadog/core/configuration/options.rb#124
class Datadog::Core::Configuration::Options::InvalidOptionError < ::StandardError; end

# Global configuration settings for the Datadog library.
#
# source://ddtrace//lib/datadog/core/configuration/settings.rb#20
class Datadog::Core::Configuration::Settings
  include ::Datadog::Core::Configuration::Base
  include ::Datadog::Core::Environment::VariableHelpers
  include ::Datadog::Core::Configuration::Options
  include ::Datadog::Core::Configuration::Options::InstanceMethods
  include ::Datadog::Core::Configuration::Base::InstanceMethods
  extend ::Datadog::Core::Environment::VariableHelpers
  extend ::Datadog::Core::Configuration::Options::ClassMethods
  extend ::Datadog::Core::Configuration::Base::ClassMethods
  extend ::Datadog::Tracing::Configuration::Settings
  extend ::Datadog::AppSec::Configuration::Settings
  extend ::Datadog::CI::Configuration::Settings

  # @return [Settings] a new instance of Settings
  #
  # source://ddtrace//lib/datadog/core/configuration/settings.rb#24
  def initialize(*_); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def agent; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def agent=(value); end

  # Datadog API key.
  #
  # For internal use only.
  #
  # @return [String, nil]
  #
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def api_key; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def api_key=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def appsec; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def appsec=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def ci; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def ci=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def diagnostics; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def diagnostics=(value); end

  # The `env` tag in Datadog. Use it to separate out your staging, development, and production environments.
  #
  # @return [String, nil]
  # @see https://docs.datadoghq.com/getting_started/tagging/unified_service_tagging
  #
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def env; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def env=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def logger; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def logger=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def profiling; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def profiling=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def remote; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def remote=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def runtime_metrics; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def runtime_metrics=(value); end

  # The `service` tag in Datadog. Use it to group related traces into a service.
  #
  # @return [String]
  # @see https://docs.datadoghq.com/getting_started/tagging/unified_service_tagging
  #
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service=(value); end

  # source://ddtrace//lib/datadog/core/configuration/settings.rb#439
  def service_without_fallback; end

  # The Datadog site host to send data to.
  # By default, data is sent to the Datadog US site: `app.datadoghq.com`.
  #
  # If your organization is on another site, you must update this value to the new site.
  #
  # For internal use only.
  #
  # @return [String, nil]
  # @see https://docs.datadoghq.com/agent/troubleshooting/site/
  #
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def site; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def site=(value); end

  # Default tags
  #
  # These tags are used by all Datadog products, when applicable.
  # e.g. trace spans, profiles, etc.
  #
  # @return [Hash<String,String>]
  #
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def tags; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def tags=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def telemetry; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def telemetry=(value); end

  # The time provider used by Datadog. It must respect the interface of [Time](https://ruby-doc.org/core-3.0.1/Time.html).
  #
  # When testing, it can be helpful to use a different time provider.
  #
  # For [Timecop](https://rubygems.org/gems/timecop), for example, `->{ Time.now_without_mock_time }`
  # allows Datadog features to use the real wall time when time is frozen.
  #
  # @return [Proc<Time>]
  #
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def time_now_provider; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def time_now_provider=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def tracing; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def tracing=(value); end

  # The `version` tag in Datadog. Use it to enable [Deployment Tracking](https://docs.datadoghq.com/tracing/deployment_tracking/).
  #
  # @return [String, nil]
  # @see https://docs.datadoghq.com/getting_started/tagging/unified_service_tagging
  #
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def version; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def version=(value); end
end

# source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#7
module Datadog::Core::Diagnostics; end

# Collects environment information for diagnostic logging
#
# source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#58
class Datadog::Core::Diagnostics::EnvironmentCollector
  # Error returned by Datadog agent during a tracer flush attempt
  #
  # @return [String] concatenated list of transport errors
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#121
  def agent_error(transport_responses); end

  # @return [String, nil] target agent URL for trace flushing
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#108
  def agent_url; end

  # @return [Boolean, nil] analytics enabled in configuration
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#135
  def analytics_enabled; end

  # @return [Hash] environment information available at call time
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#231
  def collect!(transport_responses); end

  # @return [String] current time in ISO8601 format
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#60
  def date; end

  # @return [String] configured application version
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#103
  def dd_version; end

  # @return [Boolean, nil] debug mode enabled in configuration
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#130
  def debug; end

  # @return [Boolean, nil]
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#93
  def enabled; end

  # @return [String] configured application environment
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#88
  def env; end

  # @return [Boolean, nil] health metrics enabled in configuration
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#218
  def health_metrics_enabled; end

  # Concatenated list of integrations activated, with their gem version.
  # Example: "rails@6.0.3,rack@2.2.3"
  #
  # @return [String, nil]
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#186
  def integrations_loaded; end

  # @return [String] "ruby"
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#76
  def lang; end

  # Supported Ruby language version.
  # Will be distinct from VM version for non-MRI environments.
  #
  # @return [String]
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#83
  def lang_version; end

  # Best portable guess of OS information.
  #
  # @return [String] platform string
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#66
  def os_name; end

  # @return [Boolean, nil] partial flushing enabled in configuration
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#208
  def partial_flushing_enabled; end

  # @return [Boolean, nil] priority sampling enabled in configuration
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#213
  def priority_sampling_enabled; end

  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#222
  def profiling_enabled; end

  # @return [Boolean, nil] runtime metrics enabled in configuration
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#178
  def runtime_metrics_enabled; end

  # @return [Numeric, nil] tracer sample rate configured
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#140
  def sample_rate; end

  # DEV: We currently only support SimpleRule instances.
  # DEV: These are the most commonly used rules.
  # DEV: We should expand support for other rules in the future,
  # DEV: although it is tricky to serialize arbitrary rules.
  #
  # @return [Hash, nil] sample rules configured
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#153
  def sampling_rules; end

  # @return [String] configured application service name
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#98
  def service; end

  # @return [Hash, nil] concatenated list of global tracer tags configured
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#170
  def tags; end

  # @return [String] ddtrace version
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#71
  def version; end

  # Ruby VM name and version.
  # Examples: "ruby-2.7.1", "jruby-9.2.11.1", "truffleruby-20.1.0"
  #
  # @return [String, nil]
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#196
  def vm; end

  private

  # Outputs "k1:v1,k2:v2,..."
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#280
  def hash_serializer(h); end

  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#262
  def instrumented_integrations; end

  # Capture all active integration settings into "integrationName_settingName: value" entries.
  #
  # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#267
  def instrumented_integrations_settings; end
end

# A holistic collection of the environment in which ddtrace is running.
# This logger should allow for easy reporting by users to Datadog support.
#
# source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#11
module Datadog::Core::Diagnostics::EnvironmentLogger
  class << self
    # Outputs environment information to {Datadog.logger}.
    # Executes only once for the lifetime of the program.
    #
    # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#15
    def log!(transport_responses); end

    private

    # Are we logging the environment data?
    #
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#40
    def log?; end

    # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#31
    def log_environment!(line); end

    # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#35
    def log_error!(type, error); end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/core/diagnostics/environment_logger.rb#51
    def repl?; end
  end
end

# Health-related diagnostics
#
# source://ddtrace//lib/datadog/core/diagnostics/health.rb#10
module Datadog::Core::Diagnostics::Health; end

# Health metrics for diagnostics
#
# source://ddtrace//lib/datadog/core/diagnostics/health.rb#12
class Datadog::Core::Diagnostics::Health::Metrics < ::Datadog::Core::Metrics::Client
  extend ::Datadog::Tracing::Diagnostics::Health::Metrics

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#17
  def api_errors(*args, &block); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#17
  def api_requests(*args, &block); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#17
  def api_responses(*args, &block); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#17
  def error_context_overflow(*args, &block); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#17
  def error_instrumentation_patch(*args, &block); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#17
  def error_span_finish(*args, &block); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#17
  def error_unfinished_spans(*args, &block); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#17
  def instrumentation_patched(*args, &block); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#17
  def queue_accepted(*args, &block); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#17
  def queue_accepted_lengths(*args, &block); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#17
  def queue_dropped(*args, &block); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#17
  def queue_length(*args, &block); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#17
  def queue_max_length(*args, &block); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#17
  def queue_spans(*args, &block); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#17
  def sampling_service_cache_length(*args, &block); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#17
  def traces_filtered(*args, &block); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#17
  def transport_chunked(*args, &block); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#17
  def transport_trace_too_large(*args, &block); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#17
  def writer_cpu_time(*args, &block); end
end

# Encoding module that encodes data for the AgentTransport
#
# source://ddtrace//lib/datadog/core/encoding.rb#7
module Datadog::Core::Encoding; end

# Encoder interface that provides the logic to encode traces and service
#
# @abstract
#
# source://ddtrace//lib/datadog/core/encoding.rb#10
module Datadog::Core::Encoding::Encoder
  # @raise [NotImplementedError]
  #
  # source://ddtrace//lib/datadog/core/encoding.rb#11
  def content_type; end

  # Serializes a single trace into a String suitable for network transmission.
  #
  # @raise [NotImplementedError]
  #
  # source://ddtrace//lib/datadog/core/encoding.rb#21
  def encode(_); end

  # Concatenates a list of elements previously encoded by +#encode+.
  #
  # @raise [NotImplementedError]
  #
  # source://ddtrace//lib/datadog/core/encoding.rb#16
  def join(encoded_elements); end
end

# Encoder for the JSON format
#
# source://ddtrace//lib/datadog/core/encoding.rb#27
module Datadog::Core::Encoding::JSONEncoder
  extend ::Datadog::Core::Encoding::Encoder

  private

  # source://ddtrace//lib/datadog/core/encoding.rb#34
  def content_type; end

  # source://ddtrace//lib/datadog/core/encoding.rb#38
  def encode(obj); end

  # source://ddtrace//lib/datadog/core/encoding.rb#42
  def join(encoded_data); end

  class << self
    # source://ddtrace//lib/datadog/core/encoding.rb#34
    def content_type; end

    # source://ddtrace//lib/datadog/core/encoding.rb#38
    def encode(obj); end

    # source://ddtrace//lib/datadog/core/encoding.rb#42
    def join(encoded_data); end
  end
end

# source://ddtrace//lib/datadog/core/encoding.rb#30
Datadog::Core::Encoding::JSONEncoder::CONTENT_TYPE = T.let(T.unsafe(nil), String)

# Encoder for the Msgpack format
#
# source://ddtrace//lib/datadog/core/encoding.rb#48
module Datadog::Core::Encoding::MsgpackEncoder
  extend ::Datadog::Core::Encoding::Encoder

  private

  # source://ddtrace//lib/datadog/core/encoding.rb#55
  def content_type; end

  # source://ddtrace//lib/datadog/core/encoding.rb#59
  def encode(obj); end

  # source://ddtrace//lib/datadog/core/encoding.rb#63
  def join(encoded_data); end

  class << self
    # source://ddtrace//lib/datadog/core/encoding.rb#55
    def content_type; end

    # source://ddtrace//lib/datadog/core/encoding.rb#59
    def encode(obj); end

    # source://ddtrace//lib/datadog/core/encoding.rb#63
    def join(encoded_data); end
  end
end

# source://ddtrace//lib/datadog/core/encoding.rb#53
Datadog::Core::Encoding::MsgpackEncoder::CONTENT_TYPE = T.let(T.unsafe(nil), String)

# Namespace for handling application environment
#
# source://ddtrace//lib/datadog/core/environment/variable_helpers.rb#6
module Datadog::Core::Environment; end

# Reads information from Linux cgroups.
# This information is used to extract information
# about the current Linux container identity.
#
# @see https://man7.org/linux/man-pages/man7/cgroups.7.html
#
# source://ddtrace//lib/datadog/core/environment/cgroup.rb#10
module Datadog::Core::Environment::Cgroup
  private

  # source://ddtrace//lib/datadog/core/environment/cgroup.rb#22
  def descriptors(process = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/core/environment/cgroup.rb#41
  def parse(line); end

  class << self
    # source://ddtrace//lib/datadog/core/environment/cgroup.rb#22
    def descriptors(process = T.unsafe(nil)); end

    # source://ddtrace//lib/datadog/core/environment/cgroup.rb#41
    def parse(line); end
  end
end

# source://ddtrace//lib/datadog/core/environment/cgroup.rb#13
class Datadog::Core::Environment::Cgroup::Descriptor < ::Struct
  # Returns the value of attribute controllers
  #
  # @return [Object] the current value of controllers
  def controllers; end

  # Sets the attribute controllers
  #
  # @param value [Object] the value to set the attribute controllers to.
  # @return [Object] the newly set value
  def controllers=(_); end

  # Returns the value of attribute groups
  #
  # @return [Object] the current value of groups
  def groups; end

  # Sets the attribute groups
  #
  # @param value [Object] the value to set the attribute groups to.
  # @return [Object] the newly set value
  def groups=(_); end

  # Returns the value of attribute id
  #
  # @return [Object] the current value of id
  def id; end

  # Sets the attribute id
  #
  # @param value [Object] the value to set the attribute id to.
  # @return [Object] the newly set value
  def id=(_); end

  # Returns the value of attribute path
  #
  # @return [Object] the current value of path
  def path; end

  # Sets the attribute path
  #
  # @param value [Object] the value to set the attribute path to.
  # @return [Object] the newly set value
  def path=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://ddtrace//lib/datadog/core/environment/cgroup.rb#11
Datadog::Core::Environment::Cgroup::LINE_REGEX = T.let(T.unsafe(nil), Regexp)

# Retrieves number of classes from runtime
#
# source://ddtrace//lib/datadog/core/environment/class_count.rb#7
module Datadog::Core::Environment::ClassCount
  private

  # source://ddtrace//lib/datadog/core/environment/class_count.rb#14
  def available?; end

  # source://ddtrace//lib/datadog/core/environment/class_count.rb#10
  def value; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/core/environment/class_count.rb#14
    def available?; end

    # source://ddtrace//lib/datadog/core/environment/class_count.rb#10
    def value; end
  end
end

# For container environments
#
# source://ddtrace//lib/datadog/core/environment/container.rb#7
module Datadog::Core::Environment::Container
  private

  # source://ddtrace//lib/datadog/core/environment/container.rb#28
  def container_id; end

  # source://ddtrace//lib/datadog/core/environment/container.rb#36
  def descriptor; end

  # source://ddtrace//lib/datadog/core/environment/container.rb#24
  def platform; end

  # source://ddtrace//lib/datadog/core/environment/container.rb#32
  def task_uid; end

  class << self
    # source://ddtrace//lib/datadog/core/environment/container.rb#28
    def container_id; end

    # source://ddtrace//lib/datadog/core/environment/container.rb#36
    def descriptor; end

    # source://ddtrace//lib/datadog/core/environment/container.rb#24
    def platform; end

    # source://ddtrace//lib/datadog/core/environment/container.rb#32
    def task_uid; end
  end
end

# source://ddtrace//lib/datadog/core/environment/container.rb#9
Datadog::Core::Environment::Container::CONTAINER_PATTERN = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/environment/container.rb#13
Datadog::Core::Environment::Container::CONTAINER_REGEX = T.let(T.unsafe(nil), Regexp)

# source://ddtrace//lib/datadog/core/environment/container.rb#16
class Datadog::Core::Environment::Container::Descriptor < ::Struct
  # Returns the value of attribute container_id
  #
  # @return [Object] the current value of container_id
  def container_id; end

  # Sets the attribute container_id
  #
  # @param value [Object] the value to set the attribute container_id to.
  # @return [Object] the newly set value
  def container_id=(_); end

  # Returns the value of attribute platform
  #
  # @return [Object] the current value of platform
  def platform; end

  # Sets the attribute platform
  #
  # @param value [Object] the value to set the attribute platform to.
  # @return [Object] the newly set value
  def platform=(_); end

  # Returns the value of attribute task_uid
  #
  # @return [Object] the current value of task_uid
  def task_uid; end

  # Sets the attribute task_uid
  #
  # @param value [Object] the value to set the attribute task_uid to.
  # @return [Object] the newly set value
  def task_uid=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://ddtrace//lib/datadog/core/environment/container.rb#14
Datadog::Core::Environment::Container::FARGATE_14_CONTAINER_REGEX = T.let(T.unsafe(nil), Regexp)

# source://ddtrace//lib/datadog/core/environment/container.rb#11
Datadog::Core::Environment::Container::PLATFORM_REGEX = T.let(T.unsafe(nil), Regexp)

# source://ddtrace//lib/datadog/core/environment/container.rb#12
Datadog::Core::Environment::Container::POD_REGEX = T.let(T.unsafe(nil), Regexp)

# source://ddtrace//lib/datadog/core/environment/container.rb#8
Datadog::Core::Environment::Container::UUID_PATTERN = T.let(T.unsafe(nil), String)

# Provides information about the execution environment on the current process.
#
# source://ddtrace//lib/datadog/core/environment/execution.rb#7
module Datadog::Core::Environment::Execution
  class << self
    # Is this process running in a development environment?
    # This can be used to make decisions about when to enable
    # background systems like worker threads or telemetry.
    #
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/core/environment/execution.rb#12
    def development?; end

    private

    # Check if Minitest is present and installed to run.
    #
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/core/environment/execution.rb#41
    def minitest?; end

    # Is this process running inside on a Readevalprint loop?
    # DEV: REPLs always set the program name to the exact REPL name.
    #
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/core/environment/execution.rb#25
    def repl?; end

    # RSpec always runs using the `rspec` file https://github.com/rspec/rspec-core/blob/main/exe/rspec
    #
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/core/environment/execution.rb#33
    def rspec?; end

    # Is this process running a test?
    #
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/core/environment/execution.rb#19
    def test?; end
  end
end

# source://ddtrace//lib/datadog/core/environment/ext.rb#9
module Datadog::Core::Environment::Ext; end

# e.g for CRuby '3.0.1', for JRuby '9.2.19.0', for TruffleRuby '21.1.0'
#
# source://ddtrace//lib/datadog/core/environment/ext.rb#11
Datadog::Core::Environment::Ext::ENGINE_VERSION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/environment/ext.rb#18
Datadog::Core::Environment::Ext::ENV_API_KEY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/environment/ext.rb#19
Datadog::Core::Environment::Ext::ENV_ENVIRONMENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/environment/ext.rb#20
Datadog::Core::Environment::Ext::ENV_SERVICE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/environment/ext.rb#21
Datadog::Core::Environment::Ext::ENV_SITE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/environment/ext.rb#22
Datadog::Core::Environment::Ext::ENV_TAGS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/environment/ext.rb#23
Datadog::Core::Environment::Ext::ENV_VERSION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/environment/ext.rb#24
Datadog::Core::Environment::Ext::FALLBACK_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/environment/ext.rb#31
Datadog::Core::Environment::Ext::LANG = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/environment/ext.rb#32
Datadog::Core::Environment::Ext::LANG_ENGINE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/environment/ext.rb#33
Datadog::Core::Environment::Ext::LANG_INTERPRETER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/environment/ext.rb#34
Datadog::Core::Environment::Ext::LANG_PLATFORM = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/environment/ext.rb#35
Datadog::Core::Environment::Ext::LANG_VERSION = T.let(T.unsafe(nil), String)

# e.g. 'ruby', 'jruby', 'truffleruby'
#
# source://ddtrace//lib/datadog/core/environment/ext.rb#36
Datadog::Core::Environment::Ext::RUBY_ENGINE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/environment/ext.rb#37
Datadog::Core::Environment::Ext::TAG_ENV = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/environment/ext.rb#38
Datadog::Core::Environment::Ext::TAG_SERVICE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/environment/ext.rb#39
Datadog::Core::Environment::Ext::TAG_VERSION = T.let(T.unsafe(nil), String)

# TODO: Migrate to Datadog::Tracing
#
# source://ddtrace//lib/datadog/core/environment/ext.rb#42
Datadog::Core::Environment::Ext::TRACER_VERSION = T.let(T.unsafe(nil), String)

# Retrieves garbage collection statistics
#
# source://ddtrace//lib/datadog/core/environment/gc.rb#7
module Datadog::Core::Environment::GC
  private

  # source://ddtrace//lib/datadog/core/environment/gc.rb#14
  def available?; end

  # source://ddtrace//lib/datadog/core/environment/gc.rb#10
  def stat; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/core/environment/gc.rb#14
    def available?; end

    # source://ddtrace//lib/datadog/core/environment/gc.rb#10
    def stat; end
  end
end

# For runtime identity
#
# source://ddtrace//lib/datadog/core/environment/identity.rb#13
module Datadog::Core::Environment::Identity
  extend ::Datadog::Core::Utils::Forking

  private

  # Retrieves number of classes from runtime
  #
  # source://ddtrace//lib/datadog/core/environment/identity.rb#19
  def id; end

  # source://ddtrace//lib/datadog/core/environment/identity.rb#32
  def lang; end

  # source://ddtrace//lib/datadog/core/environment/identity.rb#36
  def lang_engine; end

  # source://ddtrace//lib/datadog/core/environment/identity.rb#40
  def lang_interpreter; end

  # source://ddtrace//lib/datadog/core/environment/identity.rb#44
  def lang_platform; end

  # source://ddtrace//lib/datadog/core/environment/identity.rb#48
  def lang_version; end

  # source://ddtrace//lib/datadog/core/environment/identity.rb#28
  def pid; end

  # Returns tracer version, rubygems-style
  #
  # source://ddtrace//lib/datadog/core/environment/identity.rb#53
  def tracer_version; end

  # Returns tracer version, comforming to https://semver.org/spec/v2.0.0.html
  #
  # source://ddtrace//lib/datadog/core/environment/identity.rb#58
  def tracer_version_semver2; end

  class << self
    # Retrieves number of classes from runtime
    #
    # source://ddtrace//lib/datadog/core/environment/identity.rb#19
    def id; end

    # source://ddtrace//lib/datadog/core/environment/identity.rb#32
    def lang; end

    # source://ddtrace//lib/datadog/core/environment/identity.rb#36
    def lang_engine; end

    # source://ddtrace//lib/datadog/core/environment/identity.rb#40
    def lang_interpreter; end

    # source://ddtrace//lib/datadog/core/environment/identity.rb#44
    def lang_platform; end

    # source://ddtrace//lib/datadog/core/environment/identity.rb#48
    def lang_version; end

    # source://ddtrace//lib/datadog/core/environment/identity.rb#28
    def pid; end

    # Returns tracer version, rubygems-style
    #
    # source://ddtrace//lib/datadog/core/environment/identity.rb#53
    def tracer_version; end

    # Returns tracer version, comforming to https://semver.org/spec/v2.0.0.html
    #
    # source://ddtrace//lib/datadog/core/environment/identity.rb#58
    def tracer_version_semver2; end
  end
end

# source://ddtrace//lib/datadog/core/environment/identity.rb#72
Datadog::Core::Environment::Identity::SEMVER2_RE = T.let(T.unsafe(nil), Regexp)

# For gathering information about the platform
#
# source://ddtrace//lib/datadog/core/environment/platform.rb#9
module Datadog::Core::Environment::Platform
  private

  # @return [String] name of host; `uname -n`
  #
  # source://ddtrace//lib/datadog/core/environment/platform.rb#13
  def hostname; end

  # @return [String] name of kernel; `uname -s`
  #
  # source://ddtrace//lib/datadog/core/environment/platform.rb#18
  def kernel_name; end

  # @return [String] kernel release; `uname -r`
  #
  # source://ddtrace//lib/datadog/core/environment/platform.rb#23
  def kernel_release; end

  # @return [String] kernel version; `uname -v`
  #
  # source://ddtrace//lib/datadog/core/environment/platform.rb#32
  def kernel_version; end

  class << self
    # @return [String] name of host; `uname -n`
    #
    # source://ddtrace//lib/datadog/core/environment/platform.rb#13
    def hostname; end

    # @return [String] name of kernel; `uname -s`
    #
    # source://ddtrace//lib/datadog/core/environment/platform.rb#18
    def kernel_name; end

    # @return [String] kernel release; `uname -r`
    #
    # source://ddtrace//lib/datadog/core/environment/platform.rb#23
    def kernel_release; end

    # @return [String] kernel version; `uname -v`
    #
    # source://ddtrace//lib/datadog/core/environment/platform.rb#32
    def kernel_version; end
  end
end

# For runtime identity
#
# source://ddtrace//lib/datadog/core/environment/socket.rb#10
module Datadog::Core::Environment::Socket
  extend ::Datadog::Core::Utils::Forking

  private

  # source://ddtrace//lib/datadog/core/environment/socket.rb#15
  def hostname; end

  class << self
    # source://ddtrace//lib/datadog/core/environment/socket.rb#15
    def hostname; end
  end
end

# Retrieves number of threads from runtime
#
# source://ddtrace//lib/datadog/core/environment/thread_count.rb#7
module Datadog::Core::Environment::ThreadCount
  private

  # source://ddtrace//lib/datadog/core/environment/thread_count.rb#14
  def available?; end

  # source://ddtrace//lib/datadog/core/environment/thread_count.rb#10
  def value; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/core/environment/thread_count.rb#14
    def available?; end

    # source://ddtrace//lib/datadog/core/environment/thread_count.rb#10
    def value; end
  end
end

# Reports Ruby VM cache performance statistics.
# This currently encompasses cache invalidation counters and is CRuby-specific.
#
# JRuby emulates some CRuby global cache statistics, but they are synthetic and don't
# provide actionable performance information in the same way CRuby does.
# TruffleRuby does not have a global runtime cache invalidation cache.
#
# @see https://github.com/jruby/jruby/issues/4384#issuecomment-267069314
# @see http://archive.today/2021.09.10-205702/https://medium.com/graalvm/precise-method-and-constant-invalidation-in-truffleruby-4dd56c6bac1a
#
# source://ddtrace//lib/datadog/core/environment/vm_cache.rb#15
module Datadog::Core::Environment::VMCache
  private

  # source://ddtrace//lib/datadog/core/environment/vm_cache.rb#58
  def available?; end

  # Introduced in Ruby 3.2 to match an improved cache implementation.
  #
  # @see https://bugs.ruby-lang.org/issues/18589
  #
  # source://ddtrace//lib/datadog/core/environment/vm_cache.rb#47
  def constant_cache_invalidations; end

  # Introduced in Ruby 3.2 to match an improved cache implementation.
  #
  # @see https://bugs.ruby-lang.org/issues/18589
  #
  # source://ddtrace//lib/datadog/core/environment/vm_cache.rb#54
  def constant_cache_misses; end

  # Global constant cache "generation" counter.
  #
  # Whenever a constant creation busts the global constant cache
  # this value is incremented. This has a measurable performance impact
  # and thus show be avoided after application warm up.
  #
  # This was removed in Ruby 3.2.
  #
  # @see https://github.com/ruby/ruby/blob/master/doc/NEWS/NEWS-3.2.0.md#implementation-improvements
  #
  # source://ddtrace//lib/datadog/core/environment/vm_cache.rb#26
  def global_constant_state; end

  # Global method cache "generation" counter.
  #
  # Whenever a method creation busts the global method cache
  # this value is incremented. This has a measurable performance impact
  # and thus show be avoided after application warm up.
  #
  # Since Ruby 3.0, the method class is kept on a per-class basis,
  # largely mitigating global method cache busting. `global_method_state`
  # is thus not available since Ruby 3.0.
  #
  # @see https://bugs.ruby-lang.org/issues/16614
  #
  # source://ddtrace//lib/datadog/core/environment/vm_cache.rb#40
  def global_method_state; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/core/environment/vm_cache.rb#58
    def available?; end

    # Introduced in Ruby 3.2 to match an improved cache implementation.
    #
    # @see https://bugs.ruby-lang.org/issues/18589
    #
    # source://ddtrace//lib/datadog/core/environment/vm_cache.rb#47
    def constant_cache_invalidations; end

    # Introduced in Ruby 3.2 to match an improved cache implementation.
    #
    # @see https://bugs.ruby-lang.org/issues/18589
    #
    # source://ddtrace//lib/datadog/core/environment/vm_cache.rb#54
    def constant_cache_misses; end

    # Global constant cache "generation" counter.
    #
    # Whenever a constant creation busts the global constant cache
    # this value is incremented. This has a measurable performance impact
    # and thus show be avoided after application warm up.
    #
    # This was removed in Ruby 3.2.
    #
    # @see https://github.com/ruby/ruby/blob/master/doc/NEWS/NEWS-3.2.0.md#implementation-improvements
    #
    # source://ddtrace//lib/datadog/core/environment/vm_cache.rb#26
    def global_constant_state; end

    # Global method cache "generation" counter.
    #
    # Whenever a method creation busts the global method cache
    # this value is incremented. This has a measurable performance impact
    # and thus show be avoided after application warm up.
    #
    # Since Ruby 3.0, the method class is kept on a per-class basis,
    # largely mitigating global method cache busting. `global_method_state`
    # is thus not available since Ruby 3.0.
    #
    # @see https://bugs.ruby-lang.org/issues/16614
    #
    # source://ddtrace//lib/datadog/core/environment/vm_cache.rb#40
    def global_method_state; end
  end
end

# Defines helper methods for environment
#
# source://ddtrace//lib/datadog/core/environment/variable_helpers.rb#9
module Datadog::Core::Environment::VariableHelpers
  extend ::Datadog::Core::Environment::VariableHelpers

  # Reads an environment variable as a Boolean.
  #
  # @param var [String] environment variable
  # @param var [Array<String>] list of environment variables
  # @param default [Boolean] the default value if the keys in `var` are not present in the environment
  # @param deprecation_warning [Boolean] when `var` is a list, record a deprecation log when
  #   the first key in `var` is not used.
  # @return [Boolean] if the environment value is the string `true` or `1`
  # @return [default] if the environment value is not found
  #
  # source://ddtrace//lib/datadog/core/environment/variable_helpers.rb#21
  def env_to_bool(var, default = T.unsafe(nil), deprecation_warning: T.unsafe(nil)); end

  # Reads an environment variable as a Float.
  #
  # @param var [String] environment variable
  # @param var [Array<String>] list of environment variables
  # @param default [Float] the default value if the keys in `var` are not present in the environment
  # @param deprecation_warning [Boolean] when `var` is a list, record a deprecation log when
  #   the first key in `var` is not used.
  # @return [Float] if the environment value is a valid Float
  # @return [default] if the environment value is not found
  #
  # source://ddtrace//lib/datadog/core/environment/variable_helpers.rb#55
  def env_to_float(var, default = T.unsafe(nil), deprecation_warning: T.unsafe(nil)); end

  # Reads an environment variable as an Integer.
  #
  # @param var [String] environment variable
  # @param var [Array<String>] list of environment variables
  # @param default [Integer] the default value if the keys in `var` are not present in the environment
  # @param deprecation_warning [Boolean] when `var` is a list, record a deprecation log when
  #   the first key in `var` is not used.
  # @return [Integer] if the environment value is a valid Integer
  # @return [default] if the environment value is not found
  #
  # source://ddtrace//lib/datadog/core/environment/variable_helpers.rb#41
  def env_to_int(var, default = T.unsafe(nil), deprecation_warning: T.unsafe(nil)); end

  # Parses comma- or space-separated lists.
  #
  # If a comma is present, then the list is considered comma-separated.
  # Otherwise, it is considered space-separated.
  #
  # After the entries are separated, commas and whitespaces that are
  # either trailing or leading are trimmed.
  #
  # Empty entries, after trimmed, are also removed from the result.
  #
  # @param var [String] environment variable
  # @param var [Array<String>] list of environment variables
  # @param default [Array<Object>] the default value if the keys in `var` are not present in the environment
  # @param deprecation_warning [Boolean] when `var` is a list, record a deprecation log when
  #   the first key in `var` is not used.
  # @return [Array<Object>] if the environment value is a valid list
  # @return [default] if the environment value is not found
  #
  # source://ddtrace//lib/datadog/core/environment/variable_helpers.rb#77
  def env_to_list(var, default = T.unsafe(nil), comma_separated_only:, deprecation_warning: T.unsafe(nil)); end

  private

  # source://ddtrace//lib/datadog/core/environment/variable_helpers.rb#103
  def decode_array(var, deprecation_warning); end
end

# Reports YJIT primitive runtime statistics.
#
# source://ddtrace//lib/datadog/core/environment/yjit.rb#7
module Datadog::Core::Environment::YJIT
  private

  # source://ddtrace//lib/datadog/core/environment/yjit.rb#50
  def available?; end

  # Code GC count
  #
  # source://ddtrace//lib/datadog/core/environment/yjit.rb#36
  def code_gc_count; end

  # Size of memory region allocated for JIT code
  #
  # source://ddtrace//lib/datadog/core/environment/yjit.rb#41
  def code_region_size; end

  # GCed code size
  #
  # source://ddtrace//lib/datadog/core/environment/yjit.rb#26
  def freed_code_size; end

  # GCed pages
  #
  # source://ddtrace//lib/datadog/core/environment/yjit.rb#21
  def freed_page_count; end

  # Inline code size
  #
  # source://ddtrace//lib/datadog/core/environment/yjit.rb#11
  def inline_code_size; end

  # Live pages
  #
  # source://ddtrace//lib/datadog/core/environment/yjit.rb#31
  def live_page_count; end

  # Total number of object shapes
  #
  # source://ddtrace//lib/datadog/core/environment/yjit.rb#46
  def object_shape_count; end

  # Outlined code size
  #
  # source://ddtrace//lib/datadog/core/environment/yjit.rb#16
  def outlined_code_size; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/core/environment/yjit.rb#50
    def available?; end

    # Code GC count
    #
    # source://ddtrace//lib/datadog/core/environment/yjit.rb#36
    def code_gc_count; end

    # Size of memory region allocated for JIT code
    #
    # source://ddtrace//lib/datadog/core/environment/yjit.rb#41
    def code_region_size; end

    # GCed code size
    #
    # source://ddtrace//lib/datadog/core/environment/yjit.rb#26
    def freed_code_size; end

    # GCed pages
    #
    # source://ddtrace//lib/datadog/core/environment/yjit.rb#21
    def freed_page_count; end

    # Inline code size
    #
    # source://ddtrace//lib/datadog/core/environment/yjit.rb#11
    def inline_code_size; end

    # Live pages
    #
    # source://ddtrace//lib/datadog/core/environment/yjit.rb#31
    def live_page_count; end

    # Total number of object shapes
    #
    # source://ddtrace//lib/datadog/core/environment/yjit.rb#46
    def object_shape_count; end

    # Outlined code size
    #
    # source://ddtrace//lib/datadog/core/environment/yjit.rb#16
    def outlined_code_size; end
  end
end

# Error is a value-object responsible for sanitizing/encapsulating error data
#
# source://ddtrace//lib/datadog/core/error.rb#8
class Datadog::Core::Error
  # @return [Error] a new instance of Error
  #
  # source://ddtrace//lib/datadog/core/error.rb#87
  def initialize(type = T.unsafe(nil), message = T.unsafe(nil), backtrace = T.unsafe(nil)); end

  # Returns the value of attribute backtrace.
  #
  # source://ddtrace//lib/datadog/core/error.rb#9
  def backtrace; end

  # Returns the value of attribute message.
  #
  # source://ddtrace//lib/datadog/core/error.rb#9
  def message; end

  # Returns the value of attribute type.
  #
  # source://ddtrace//lib/datadog/core/error.rb#9
  def type; end

  class << self
    # source://ddtrace//lib/datadog/core/error.rb#12
    def build_from(value); end

    private

    # Outputs the following format for exceptions:
    #
    # ```
    # error_spec.rb:55:in `wrapper': wrapper layer (RuntimeError)
    # 	from error_spec.rb:40:in `wrapper'
    # 	from error_spec.rb:61:in `caller'
    #   ...
    # ```
    #
    # source://ddtrace//lib/datadog/core/error.rb#60
    def backtrace_for(ex, backtrace); end

    # Returns a stack trace with nested error causes and details.
    #
    # This manually implements Ruby >= 2.6 error output for two reasons:
    #
    # 1. It is not available in Ruby < 2.6.
    # 2. It's measurably faster to manually implement it in Ruby.
    #
    # This method mimics the exact output of
    # `ex.full_message(highlight: false, order: :top)`
    # but it's around 3x faster in our benchmark test
    # at `error_spec.rb`.
    #
    # source://ddtrace//lib/datadog/core/error.rb#35
    def full_backtrace(ex); end
  end
end

# source://ddtrace//lib/datadog/core/error.rb#95
Datadog::Core::Error::BlankError = T.let(T.unsafe(nil), Datadog::Core::Error)

# source://ddtrace//lib/datadog/core/error.rb#96
Datadog::Core::Error::ContainsMessage = T.let(T.unsafe(nil), Proc)

# Used to decorate Datadog module with additional behavior
#
# source://ddtrace//lib/datadog/core/extensions.rb#10
module Datadog::Core::Extensions
  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/core/extensions.rb#11
    def extended(base); end
  end
end

# source://ddtrace//lib/datadog/core/git/ext.rb#5
module Datadog::Core::Git; end

# Defines constants for Git tags
#
# source://ddtrace//lib/datadog/core/git/ext.rb#7
module Datadog::Core::Git::Ext; end

# source://ddtrace//lib/datadog/core/git/ext.rb#23
Datadog::Core::Git::Ext::ENV_BRANCH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/git/ext.rb#28
Datadog::Core::Git::Ext::ENV_COMMIT_AUTHOR_DATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/git/ext.rb#27
Datadog::Core::Git::Ext::ENV_COMMIT_AUTHOR_EMAIL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/git/ext.rb#26
Datadog::Core::Git::Ext::ENV_COMMIT_AUTHOR_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/git/ext.rb#31
Datadog::Core::Git::Ext::ENV_COMMIT_COMMITTER_DATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/git/ext.rb#30
Datadog::Core::Git::Ext::ENV_COMMIT_COMMITTER_EMAIL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/git/ext.rb#29
Datadog::Core::Git::Ext::ENV_COMMIT_COMMITTER_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/git/ext.rb#25
Datadog::Core::Git::Ext::ENV_COMMIT_MESSAGE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/git/ext.rb#22
Datadog::Core::Git::Ext::ENV_COMMIT_SHA = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/git/ext.rb#21
Datadog::Core::Git::Ext::ENV_REPOSITORY_URL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/git/ext.rb#24
Datadog::Core::Git::Ext::ENV_TAG = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/git/ext.rb#8
Datadog::Core::Git::Ext::TAG_BRANCH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/git/ext.rb#12
Datadog::Core::Git::Ext::TAG_COMMIT_AUTHOR_DATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/git/ext.rb#13
Datadog::Core::Git::Ext::TAG_COMMIT_AUTHOR_EMAIL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/git/ext.rb#14
Datadog::Core::Git::Ext::TAG_COMMIT_AUTHOR_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/git/ext.rb#15
Datadog::Core::Git::Ext::TAG_COMMIT_COMMITTER_DATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/git/ext.rb#16
Datadog::Core::Git::Ext::TAG_COMMIT_COMMITTER_EMAIL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/git/ext.rb#17
Datadog::Core::Git::Ext::TAG_COMMIT_COMMITTER_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/git/ext.rb#18
Datadog::Core::Git::Ext::TAG_COMMIT_MESSAGE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/git/ext.rb#19
Datadog::Core::Git::Ext::TAG_COMMIT_SHA = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/git/ext.rb#9
Datadog::Core::Git::Ext::TAG_REPOSITORY_URL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/git/ext.rb#10
Datadog::Core::Git::Ext::TAG_TAG = T.let(T.unsafe(nil), String)

# A header collection implementation that looks up headers in a Hash.
#
# source://ddtrace//lib/datadog/core/header_collection.rb#30
class Datadog::Core::HashHeaderCollection < ::Datadog::Core::HeaderCollection
  # @return [HashHeaderCollection] a new instance of HashHeaderCollection
  #
  # source://ddtrace//lib/datadog/core/header_collection.rb#31
  def initialize(hash); end

  # source://ddtrace//lib/datadog/core/header_collection.rb#38
  def get(header_name); end
end

# A some-what abstract class representing a collection of headers.
#
# Use the `HeaderCollection.from_hash` function to create a header collection from a `Hash`.
# Another option is to use `HashHeaderCollection` directly.
#
# source://ddtrace//lib/datadog/core/header_collection.rb#9
class Datadog::Core::HeaderCollection
  # Gets a single value of the header with the given name, case insensitive.
  #
  # @param header_name [String] Name of the header to get the value of.
  #
  # source://ddtrace//lib/datadog/core/header_collection.rb#15
  def get(header_name); end

  class << self
    # Create a header collection that retrieves headers from the given Hash.
    #
    # This can be useful for testing or other trivial use cases.
    #
    # @param hash [Hash] Hash with the headers.
    #
    # source://ddtrace//lib/datadog/core/header_collection.rb#24
    def from_hash(hash); end
  end
end

# A custom logger with minor enhancements:
# - progname defaults to ddtrace to clearly identify Datadog dd-trace-rb related messages
# - adds last caller stack-trace info to know where the message comes from
#
# source://ddtrace//lib/datadog/core/logger.rb#9
class Datadog::Core::Logger < ::Logger
  # @return [Logger] a new instance of Logger
  #
  # source://ddtrace//lib/datadog/core/logger.rb#13
  def initialize(*args, &block); end

  # source://ddtrace//lib/datadog/core/logger.rb#19
  def add(severity, message = T.unsafe(nil), progname = T.unsafe(nil), &block); end

  # source://ddtrace//lib/datadog/core/logger.rb#19
  def log(severity, message = T.unsafe(nil), progname = T.unsafe(nil), &block); end
end

# TODO: Consider renaming this to 'datadog'
#
# source://ddtrace//lib/datadog/core/logger.rb#11
Datadog::Core::Logger::PREFIX = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/logging/ext.rb#5
module Datadog::Core::Logging; end

# source://ddtrace//lib/datadog/core/logging/ext.rb#6
module Datadog::Core::Logging::Ext; end

# The technology from which the log originated.
#
# @see https://docs.datadoghq.com/api/latest/logs/#send-logs
#
# source://ddtrace//lib/datadog/core/logging/ext.rb#9
Datadog::Core::Logging::Ext::DD_SOURCE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/metrics/ext.rb#5
module Datadog::Core::Metrics; end

# Acts as client for sending metrics (via Statsd)
# Wraps a Statsd client with default tags and additional configuration.
#
# source://ddtrace//lib/datadog/core/metrics/client.rb#16
class Datadog::Core::Metrics::Client
  include ::Datadog::Core::Metrics::Options
  extend ::Datadog::Core::Metrics::Options
  extend ::Datadog::Core::Metrics::Helpers

  # @return [Client] a new instance of Client
  #
  # source://ddtrace//lib/datadog/core/metrics/client.rb#23
  def initialize(statsd: T.unsafe(nil), enabled: T.unsafe(nil), **_); end

  # source://ddtrace//lib/datadog/core/metrics/client.rb#164
  def close; end

  # source://ddtrace//lib/datadog/core/metrics/client.rb#81
  def configure(options = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/core/metrics/client.rb#90
  def count(stat, value = T.unsafe(nil), options = T.unsafe(nil), &block); end

  # source://ddtrace//lib/datadog/core/metrics/client.rb#51
  def default_hostname; end

  # source://ddtrace//lib/datadog/core/metrics/client.rb#55
  def default_port; end

  # source://ddtrace//lib/datadog/core/metrics/client.rb#59
  def default_statsd_client; end

  # source://ddtrace//lib/datadog/core/metrics/client.rb#103
  def distribution(stat, value = T.unsafe(nil), options = T.unsafe(nil), &block); end

  # source://ddtrace//lib/datadog/core/metrics/client.rb#47
  def enabled=(enabled); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/metrics/client.rb#43
  def enabled?; end

  # source://ddtrace//lib/datadog/core/metrics/client.rb#128
  def gauge(stat, value = T.unsafe(nil), options = T.unsafe(nil), &block); end

  # source://ddtrace//lib/datadog/core/metrics/client.rb#116
  def increment(stat, options = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/core/metrics/client.rb#160
  def send_metrics(metrics); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/metrics/client.rb#86
  def send_stats?; end

  # Returns the value of attribute statsd.
  #
  # source://ddtrace//lib/datadog/core/metrics/client.rb#21
  def statsd; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/metrics/client.rb#34
  def supported?; end

  # source://ddtrace//lib/datadog/core/metrics/client.rb#141
  def time(stat, options = T.unsafe(nil)); end

  private

  # source://ddtrace//lib/datadog/core/metrics/client.rb#170
  def dogstatsd_version; end

  # source://ddtrace//lib/datadog/core/metrics/client.rb#186
  def ignored_statsd_warning; end
end

# source://ddtrace//lib/datadog/core/metrics/client.rb#183
Datadog::Core::Metrics::Client::IGNORED_STATSD_ONLY_ONCE = T.let(T.unsafe(nil), Datadog::Core::Utils::OnlyOnce)

# source://ddtrace//lib/datadog/core/metrics/ext.rb#7
module Datadog::Core::Metrics::Ext; end

# source://ddtrace//lib/datadog/core/metrics/ext.rb#8
Datadog::Core::Metrics::Ext::DEFAULT_HOST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/metrics/ext.rb#9
Datadog::Core::Metrics::Ext::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)

# source://ddtrace//lib/datadog/core/metrics/ext.rb#11
Datadog::Core::Metrics::Ext::TAG_LANG = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/metrics/ext.rb#12
Datadog::Core::Metrics::Ext::TAG_LANG_INTERPRETER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/metrics/ext.rb#13
Datadog::Core::Metrics::Ext::TAG_LANG_VERSION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/metrics/ext.rb#14
Datadog::Core::Metrics::Ext::TAG_TRACER_VERSION = T.let(T.unsafe(nil), String)

# For defining and adding helpers to metrics
#
# source://ddtrace//lib/datadog/core/metrics/helpers.rb#7
module Datadog::Core::Metrics::Helpers
  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#15
  def count(name, stat); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#15
  def distribution(name, stat); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#15
  def gauge(name, stat); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#15
  def increment(name, stat); end

  # source://ddtrace//lib/datadog/core/metrics/helpers.rb#15
  def time(name, stat); end
end

# source://ddtrace//lib/datadog/core/metrics/logging.rb#7
module Datadog::Core::Metrics::Logging; end

# Surrogate for Datadog::Statsd to log elsewhere
#
# source://ddtrace//lib/datadog/core/metrics/logging.rb#9
class Datadog::Core::Metrics::Logging::Adapter
  # @return [Adapter] a new instance of Adapter
  #
  # source://ddtrace//lib/datadog/core/metrics/logging.rb#12
  def initialize(logger = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/core/metrics/logging.rb#23
  def count(stat, value, options = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/core/metrics/logging.rb#27
  def distribution(stat, value, options = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/core/metrics/logging.rb#35
  def gauge(stat, value, options = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/core/metrics/logging.rb#31
  def increment(stat, options = T.unsafe(nil)); end

  # Returns the value of attribute logger.
  #
  # source://ddtrace//lib/datadog/core/metrics/logging.rb#10
  def logger; end

  # Sets the attribute logger
  #
  # @param value the value to set the attribute logger to.
  #
  # source://ddtrace//lib/datadog/core/metrics/logging.rb#10
  def logger=(_arg0); end
end

# source://ddtrace//lib/datadog/core/metrics/metric.rb#6
class Datadog::Core::Metrics::Metric < ::Struct
  # @return [Metric] a new instance of Metric
  #
  # source://ddtrace//lib/datadog/core/metrics/metric.rb#7
  def initialize(*args); end

  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  def name=(_); end

  # Returns the value of attribute options
  #
  # @return [Object] the current value of options
  def options; end

  # Sets the attribute options
  #
  # @param value [Object] the value to set the attribute options to.
  # @return [Object] the newly set value
  def options=(_); end

  # Returns the value of attribute type
  #
  # @return [Object] the current value of type
  def type; end

  # Sets the attribute type
  #
  # @param value [Object] the value to set the attribute type to.
  # @return [Object] the newly set value
  def type=(_); end

  # Returns the value of attribute value
  #
  # @return [Object] the current value of value
  def value; end

  # Sets the attribute value
  #
  # @param value [Object] the value to set the attribute value to.
  # @return [Object] the newly set value
  def value=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# For defining and adding default options to metrics
#
# source://ddtrace//lib/datadog/core/metrics/options.rb#9
module Datadog::Core::Metrics::Options
  # source://ddtrace//lib/datadog/core/metrics/options.rb#32
  def default_metric_options; end

  # source://ddtrace//lib/datadog/core/metrics/options.rb#19
  def metric_options(options = T.unsafe(nil)); end
end

# source://ddtrace//lib/datadog/core/metrics/options.rb#10
Datadog::Core::Metrics::Options::DEFAULT = T.let(T.unsafe(nil), Hash)

# source://ddtrace//lib/datadog/core/metrics/options.rb#11
Datadog::Core::Metrics::Options::DEFAULT_TAGS = T.let(T.unsafe(nil), Array)

# A {Datadog::Core::Pin} sets metadata on a particular object.
#
# This is useful if you want the object to reflect
# customized behavior or attributes, like an eigenclass.
#
# source://ddtrace//lib/datadog/core/pin.rb#7
class Datadog::Core::Pin
  # @return [Pin] a new instance of Pin
  #
  # source://ddtrace//lib/datadog/core/pin.rb#25
  def initialize(**options); end

  # source://ddtrace//lib/datadog/core/pin.rb#29
  def [](name); end

  # source://ddtrace//lib/datadog/core/pin.rb#33
  def []=(name, value); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/pin.rb#37
  def key?(name); end

  # source://ddtrace//lib/datadog/core/pin.rb#42
  def onto(obj); end

  # source://ddtrace//lib/datadog/core/pin.rb#63
  def to_s; end

  private

  # Returns the value of attribute options.
  #
  # source://ddtrace//lib/datadog/core/pin.rb#70
  def options; end

  # Sets the attribute options
  #
  # @param value the value to set the attribute options to.
  #
  # source://ddtrace//lib/datadog/core/pin.rb#70
  def options=(_arg0); end

  class << self
    # source://ddtrace//lib/datadog/core/pin.rb#8
    def get_from(obj); end

    # source://ddtrace//lib/datadog/core/pin.rb#14
    def set_on(obj, **options); end
  end
end

# Module to interact with core remote component
#
# source://ddtrace//lib/datadog/core/remote/ext.rb#5
module Datadog::Core::Remote
  class << self
    # source://ddtrace//lib/datadog/core/remote.rb#8
    def active_remote; end

    private

    # source://ddtrace//lib/datadog/core/remote.rb#14
    def components; end

    # source://ddtrace//lib/datadog/core/remote.rb#18
    def remote; end
  end
end

# Client communicates with the agent and sync remote configuration
#
# source://ddtrace//lib/datadog/core/remote/client/capabilities.rb#9
class Datadog::Core::Remote::Client
  # @return [Client] a new instance of Client
  #
  # source://ddtrace//lib/datadog/core/remote/client.rb#18
  def initialize(transport, capabilities, repository: T.unsafe(nil)); end

  # Returns the value of attribute dispatcher.
  #
  # source://ddtrace//lib/datadog/core/remote/client.rb#16
  def dispatcher; end

  # Returns the value of attribute id.
  #
  # source://ddtrace//lib/datadog/core/remote/client.rb#16
  def id; end

  # Returns the value of attribute repository.
  #
  # source://ddtrace//lib/datadog/core/remote/client.rb#16
  def repository; end

  # source://ddtrace//lib/datadog/core/remote/client.rb#32
  def sync; end

  # Returns the value of attribute transport.
  #
  # source://ddtrace//lib/datadog/core/remote/client.rb#16
  def transport; end

  private

  # source://ddtrace//lib/datadog/core/remote/client.rb#185
  def gem_spec(name); end

  # source://ddtrace//lib/datadog/core/remote/client.rb#189
  def native_platform; end

  # source://ddtrace//lib/datadog/core/remote/client.rb#119
  def payload; end

  # source://ddtrace//lib/datadog/core/remote/client.rb#181
  def ruby_engine_version; end

  # source://ddtrace//lib/datadog/core/remote/client.rb#173
  def service_name; end

  # source://ddtrace//lib/datadog/core/remote/client.rb#177
  def tracer_version_semver2; end
end

# Capbailities
#
# source://ddtrace//lib/datadog/core/remote/client/capabilities.rb#11
class Datadog::Core::Remote::Client::Capabilities
  # @return [Capabilities] a new instance of Capabilities
  #
  # source://ddtrace//lib/datadog/core/remote/client/capabilities.rb#14
  def initialize(settings); end

  # Returns the value of attribute base64_capabilities.
  #
  # source://ddtrace//lib/datadog/core/remote/client/capabilities.rb#12
  def base64_capabilities; end

  # Returns the value of attribute capabilities.
  #
  # source://ddtrace//lib/datadog/core/remote/client/capabilities.rb#12
  def capabilities; end

  # Returns the value of attribute products.
  #
  # source://ddtrace//lib/datadog/core/remote/client/capabilities.rb#12
  def products; end

  # Returns the value of attribute receivers.
  #
  # source://ddtrace//lib/datadog/core/remote/client/capabilities.rb#12
  def receivers; end

  private

  # source://ddtrace//lib/datadog/core/remote/client/capabilities.rb#50
  def capabilities_to_base64; end

  # source://ddtrace//lib/datadog/core/remote/client/capabilities.rb#26
  def register(settings); end

  # source://ddtrace//lib/datadog/core/remote/client/capabilities.rb#38
  def register_capabilities(capabilities); end

  # source://ddtrace//lib/datadog/core/remote/client/capabilities.rb#46
  def register_products(products); end

  # source://ddtrace//lib/datadog/core/remote/client/capabilities.rb#42
  def register_receivers(receivers); end
end

# source://ddtrace//lib/datadog/core/remote/client.rb#228
class Datadog::Core::Remote::Client::GemSpecificationFallback < ::Struct
  def platform; end
  def platform=(_); end
  def version; end
  def version=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://ddtrace//lib/datadog/core/remote/client.rb#14
class Datadog::Core::Remote::Client::SyncError < ::StandardError; end

# source://ddtrace//lib/datadog/core/remote/client.rb#13
class Datadog::Core::Remote::Client::TransportError < ::StandardError; end

# Configures the HTTP transport to communicate with the agent
# to fetch and sync the remote configuration
#
# source://ddtrace//lib/datadog/core/remote/component.rb#15
class Datadog::Core::Remote::Component
  # @return [Component] a new instance of Component
  #
  # source://ddtrace//lib/datadog/core/remote/component.rb#20
  def initialize(settings, capabilities, agent_settings); end

  # If the worker is not initialized, initialize it.
  #
  # Then, waits for one client sync to be executed if `kind` is `:once`.
  #
  # source://ddtrace//lib/datadog/core/remote/component.rb#83
  def barrier(_kind); end

  # Returns the value of attribute client.
  #
  # source://ddtrace//lib/datadog/core/remote/component.rb#18
  def client; end

  # source://ddtrace//lib/datadog/core/remote/component.rb#88
  def shutdown!; end

  # Starts the Remote Configuration worker without waiting for first run
  #
  # source://ddtrace//lib/datadog/core/remote/component.rb#71
  def start; end

  # Is the Remote Configuration worker running?
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/remote/component.rb#76
  def started?; end

  class << self
    # Because the agent might not be available yet, we can't perform agent-specific checks yet, as they
    # would prevent remote configuration from ever running.
    #
    # Those checks are instead performed inside the worker loop.
    # This allows users to upgrade their agent while keeping their application running.
    #
    # source://ddtrace//lib/datadog/core/remote/component.rb#140
    def build(settings, agent_settings); end
  end
end

# second
#
# source://ddtrace//lib/datadog/core/remote/component.rb#16
Datadog::Core::Remote::Component::BARRIER_TIMEOUT = T.let(T.unsafe(nil), Float)

# Barrier provides a mechanism to fence execution until a condition happens
#
# source://ddtrace//lib/datadog/core/remote/component.rb#93
class Datadog::Core::Remote::Component::Barrier
  # @return [Barrier] a new instance of Barrier
  #
  # source://ddtrace//lib/datadog/core/remote/component.rb#94
  def initialize(timeout = T.unsafe(nil)); end

  # Release all current waiters
  #
  # source://ddtrace//lib/datadog/core/remote/component.rb#123
  def lift; end

  # Wait for first lift to happen, otherwise don't wait
  #
  # source://ddtrace//lib/datadog/core/remote/component.rb#103
  def wait_once(timeout = T.unsafe(nil)); end
end

# Configuration
#
# source://ddtrace//lib/datadog/core/remote/configuration/path.rb#6
class Datadog::Core::Remote::Configuration; end

# Content stores the information associated with a specific Configuration::Path
#
# source://ddtrace//lib/datadog/core/remote/configuration/content.rb#11
class Datadog::Core::Remote::Configuration::Content
  # @return [Content] a new instance of Content
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/content.rb#24
  def initialize(path:, data:); end

  # Sets this configuration as successfully applied.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/content.rb#42
  def applied; end

  # Returns the value of attribute apply_error.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/content.rb#21
  def apply_error; end

  # Returns the value of attribute apply_state.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/content.rb#21
  def apply_state; end

  # Returns the value of attribute data.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/content.rb#21
  def data; end

  # Sets this configuration as not successfully applied, with
  # a message describing the error.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/content.rb#49
  def errored(error_message); end

  # Returns the value of attribute hashes.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/content.rb#21
  def hashes; end

  # source://ddtrace//lib/datadog/core/remote/configuration/content.rb#33
  def hexdigest(type); end

  # source://ddtrace//lib/datadog/core/remote/configuration/content.rb#37
  def length; end

  # Returns the value of attribute path.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/content.rb#21
  def path; end

  # Returns the value of attribute version.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/content.rb#22
  def version; end

  # Sets the attribute version
  #
  # @param value the value to set the attribute version to.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/content.rb#22
  def version=(_arg0); end

  private

  # source://ddtrace//lib/datadog/core/remote/configuration/content.rb#68
  def compute_and_store_hash(type); end

  class << self
    # source://ddtrace//lib/datadog/core/remote/configuration/content.rb#13
    def parse(hash); end

    private

    def new(*_arg0); end
  end
end

# source://ddtrace//lib/datadog/core/remote/configuration/content.rb#54
module Datadog::Core::Remote::Configuration::Content::ApplyState; end

# Set when the configuration has been successfully applied.
#
# source://ddtrace//lib/datadog/core/remote/configuration/content.rb#60
Datadog::Core::Remote::Configuration::Content::ApplyState::ACKNOWLEDGED = T.let(T.unsafe(nil), Integer)

# Set when the configuration has been unsuccessfully applied.
#
# source://ddtrace//lib/datadog/core/remote/configuration/content.rb#63
Datadog::Core::Remote::Configuration::Content::ApplyState::ERROR = T.let(T.unsafe(nil), Integer)

# Default state of configurations.
# Set until the component consuming the configuration has acknowledged it was applied.
#
# source://ddtrace//lib/datadog/core/remote/configuration/content.rb#57
Datadog::Core::Remote::Configuration::Content::ApplyState::UNACKNOWLEDGED = T.let(T.unsafe(nil), Integer)

# ContentList stores a list of Conetnt instances
# It provides convinient methods for finding content base on Configuration::Path and Configuration::Target
#
# source://ddtrace//lib/datadog/core/remote/configuration/content.rb#77
class Datadog::Core::Remote::Configuration::ContentList < ::Array
  # source://ddtrace//lib/datadog/core/remote/configuration/content.rb#88
  def [](path); end

  # source://ddtrace//lib/datadog/core/remote/configuration/content.rb#92
  def []=(path, content); end

  # source://ddtrace//lib/datadog/core/remote/configuration/content.rb#96
  def delete(path); end

  # source://ddtrace//lib/datadog/core/remote/configuration/content.rb#84
  def find_content(path, target); end

  # source://ddtrace//lib/datadog/core/remote/configuration/content.rb#104
  def paths; end

  class << self
    # source://ddtrace//lib/datadog/core/remote/configuration/content.rb#79
    def parse(array); end
  end
end

# Stores and validates different cryptographic hash functions
#
# source://ddtrace//lib/datadog/core/remote/configuration/digest.rb#23
class Datadog::Core::Remote::Configuration::Digest
  # @return [Digest] a new instance of Digest
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/digest.rb#50
  def initialize(type, hexdigest); end

  # source://ddtrace//lib/datadog/core/remote/configuration/digest.rb#55
  def check(content); end

  # Returns the value of attribute hexdigest.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/digest.rb#25
  def hexdigest; end

  # Returns the value of attribute type.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/digest.rb#25
  def type; end

  class << self
    # source://ddtrace//lib/datadog/core/remote/configuration/digest.rb#30
    def hexdigest(type, data); end
  end
end

# source://ddtrace//lib/datadog/core/remote/configuration/digest.rb#27
Datadog::Core::Remote::Configuration::Digest::DIGEST_CHUNK = T.let(T.unsafe(nil), Integer)

# source://ddtrace//lib/datadog/core/remote/configuration/digest.rb#24
class Datadog::Core::Remote::Configuration::Digest::InvalidHashTypeError < ::StandardError; end

# Represent a list of Configuration::Digest
#
# source://ddtrace//lib/datadog/core/remote/configuration/digest.rb#10
class Datadog::Core::Remote::Configuration::DigestList < ::Array
  # source://ddtrace//lib/datadog/core/remote/configuration/digest.rb#17
  def check(content); end

  class << self
    # source://ddtrace//lib/datadog/core/remote/configuration/digest.rb#12
    def parse(hash); end
  end
end

# Path stores path information
#
# source://ddtrace//lib/datadog/core/remote/configuration/path.rb#8
class Datadog::Core::Remote::Configuration::Path
  # @return [Path] a new instance of Path
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/path.rb#55
  def initialize(source:, product:, config_id:, name:, org_id: T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/core/remote/configuration/path.rb#73
  def ==(other); end

  # Returns the value of attribute config_id.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/path.rb#53
  def config_id; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/path.rb#83
  def eql?(other); end

  # source://ddtrace//lib/datadog/core/remote/configuration/path.rb#79
  def hash; end

  # Returns the value of attribute name.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/path.rb#53
  def name; end

  # Returns the value of attribute org_id.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/path.rb#53
  def org_id; end

  # Returns the value of attribute product.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/path.rb#53
  def product; end

  # Returns the value of attribute source.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/path.rb#53
  def source; end

  # source://ddtrace//lib/datadog/core/remote/configuration/path.rb#65
  def to_s; end

  class << self
    # @raise [ParseError]
    #
    # source://ddtrace//lib/datadog/core/remote/configuration/path.rb#28
    def parse(path); end

    private

    def new(*_arg0); end
  end
end

# source://ddtrace//lib/datadog/core/remote/configuration/path.rb#9
class Datadog::Core::Remote::Configuration::Path::ParseError < ::StandardError; end

# Repository
#
# source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#10
class Datadog::Core::Remote::Configuration::Repository
  # @return [Repository] a new instance of Repository
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#21
  def initialize; end

  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#32
  def [](path); end

  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#44
  def commit(transaction); end

  # Returns the value of attribute contents.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#11
  def contents; end

  # Returns the value of attribute opaque_backend_state.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#11
  def opaque_backend_state; end

  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#28
  def paths; end

  # Returns the value of attribute root_version.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#11
  def root_version; end

  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#62
  def state; end

  # Returns the value of attribute targets_version.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#11
  def targets_version; end

  # @yield [_self, transaction]
  # @yieldparam _self [Datadog::Core::Remote::Configuration::Repository] the object that the method was called on
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#36
  def transaction; end
end

# source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#231
module Datadog::Core::Remote::Configuration::Repository::Change; end

# Delete change
#
# source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#233
class Datadog::Core::Remote::Configuration::Repository::Change::Deleted
  # @return [Deleted] a new instance of Deleted
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#236
  def initialize(path, previous); end

  # Returns the value of attribute path.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#234
  def path; end

  # Returns the value of attribute previous.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#234
  def previous; end
end

# Insert change
#
# source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#243
class Datadog::Core::Remote::Configuration::Repository::Change::Inserted
  # @return [Inserted] a new instance of Inserted
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#246
  def initialize(path, content); end

  # Returns the value of attribute content.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#244
  def content; end

  # Returns the value of attribute path.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#244
  def path; end
end

# Update change
#
# source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#253
class Datadog::Core::Remote::Configuration::Repository::Change::Updated
  # @return [Updated] a new instance of Updated
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#256
  def initialize(path, content, previous); end

  # Returns the value of attribute content.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#254
  def content; end

  # Returns the value of attribute path.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#254
  def path; end

  # Returns the value of attribute previous.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#254
  def previous; end
end

# Store list of Changes
#
# source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#265
class Datadog::Core::Remote::Configuration::Repository::ChangeSet < ::Array
  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#270
  def add(path, previous, content); end

  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#278
  def deleted(path, previous); end

  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#282
  def inserted(path, content); end

  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#266
  def paths; end

  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#286
  def updated(path, content, previous); end
end

# source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#19
Datadog::Core::Remote::Configuration::Repository::INITIAL_TARGETS_VERSION = T.let(T.unsafe(nil), Integer)

# Operation
#
# source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#148
module Datadog::Core::Remote::Configuration::Repository::Operation; end

# Delete contents base on path
#
# source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#150
class Datadog::Core::Remote::Configuration::Repository::Operation::Delete
  # @return [Delete] a new instance of Delete
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#153
  def initialize(path); end

  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#158
  def apply(repository); end

  # Returns the value of attribute path.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#151
  def path; end
end

# Insert content into the reporistory contents
#
# source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#168
class Datadog::Core::Remote::Configuration::Repository::Operation::Insert
  # @return [Insert] a new instance of Insert
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#171
  def initialize(path, target, content); end

  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#178
  def apply(repository); end

  # Returns the value of attribute content.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#169
  def content; end

  # Returns the value of attribute path.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#169
  def path; end

  # Returns the value of attribute target.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#169
  def target; end
end

# Set repository metadata
#
# source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#210
class Datadog::Core::Remote::Configuration::Repository::Operation::Set
  # @return [Set] a new instance of Set
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#213
  def initialize(**options); end

  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#219
  def apply(repository); end

  # Returns the value of attribute opaque_backend_state.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#211
  def opaque_backend_state; end

  # Returns the value of attribute targets_version.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#211
  def targets_version; end
end

# Update existimng repository's contents
#
# source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#189
class Datadog::Core::Remote::Configuration::Repository::Operation::Update
  # @return [Update] a new instance of Update
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#192
  def initialize(path, target, content); end

  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#199
  def apply(repository); end

  # Returns the value of attribute content.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#190
  def content; end

  # Returns the value of attribute path.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#190
  def path; end

  # Returns the value of attribute target.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#190
  def target; end
end

# State store the repository state
#
# source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#67
class Datadog::Core::Remote::Configuration::Repository::State
  # @return [State] a new instance of State
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#77
  def initialize(repository); end

  # Returns the value of attribute cached_target_files.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#68
  def cached_target_files; end

  # Returns the value of attribute config_states.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#68
  def config_states; end

  # Returns the value of attribute error.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#68
  def error; end

  # Returns the value of attribute has_error.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#68
  def has_error; end

  # Returns the value of attribute opaque_backend_state.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#68
  def opaque_backend_state; end

  # Returns the value of attribute root_version.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#68
  def root_version; end

  # Returns the value of attribute targets_version.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#68
  def targets_version; end

  private

  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#104
  def contents_to_cached_target_files(contents); end

  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#90
  def contents_to_config_states(contents); end
end

# Encapsulates transaction operations
#
# source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#123
class Datadog::Core::Remote::Configuration::Repository::Transaction
  # @return [Transaction] a new instance of Transaction
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#126
  def initialize; end

  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#130
  def delete(path); end

  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#134
  def insert(path, target, content); end

  # Returns the value of attribute operations.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#124
  def operations; end

  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#142
  def set(**options); end

  # source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#138
  def update(path, target, content); end
end

# source://ddtrace//lib/datadog/core/remote/configuration/repository.rb#17
Datadog::Core::Remote::Configuration::Repository::UNVERIFIED_ROOT_VERSION = T.let(T.unsafe(nil), Integer)

# Target stores digest information
#
# source://ddtrace//lib/datadog/core/remote/configuration/target.rb#46
class Datadog::Core::Remote::Configuration::Target
  # @return [Target] a new instance of Target
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/target.rb#59
  def initialize(digests:, length:, version:); end

  # source://ddtrace//lib/datadog/core/remote/configuration/target.rb#67
  def check(content); end

  # Returns the value of attribute digests.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/target.rb#57
  def digests; end

  # Returns the value of attribute length.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/target.rb#57
  def length; end

  # Returns the value of attribute version.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/target.rb#57
  def version; end

  class << self
    # source://ddtrace//lib/datadog/core/remote/configuration/target.rb#48
    def parse(hash); end

    private

    def new(*_arg0); end
  end
end

# TargetMap stores information regarding Configuration::Path and Configuration::Target
#
# source://ddtrace//lib/datadog/core/remote/configuration/target.rb#11
class Datadog::Core::Remote::Configuration::TargetMap < ::Hash
  # @return [TargetMap] a new instance of TargetMap
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/target.rb#35
  def initialize; end

  # Returns the value of attribute opaque_backend_state.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/target.rb#33
  def opaque_backend_state; end

  # Returns the value of attribute version.
  #
  # source://ddtrace//lib/datadog/core/remote/configuration/target.rb#33
  def version; end

  class << self
    # source://ddtrace//lib/datadog/core/remote/configuration/target.rb#13
    def parse(hash); end

    private

    def new(*_arg0); end
  end
end

# Repository update dispatcher
#
# source://ddtrace//lib/datadog/core/remote/dispatcher.rb#7
class Datadog::Core::Remote::Dispatcher
  # @return [Dispatcher] a new instance of Dispatcher
  #
  # source://ddtrace//lib/datadog/core/remote/dispatcher.rb#10
  def initialize; end

  # source://ddtrace//lib/datadog/core/remote/dispatcher.rb#14
  def dispatch(changes, repository); end

  # Returns the value of attribute receivers.
  #
  # source://ddtrace//lib/datadog/core/remote/dispatcher.rb#8
  def receivers; end
end

# Matcher checks if the path matches
#
# source://ddtrace//lib/datadog/core/remote/dispatcher.rb#39
class Datadog::Core::Remote::Dispatcher::Matcher
  # @return [Matcher] a new instance of Matcher
  #
  # source://ddtrace//lib/datadog/core/remote/dispatcher.rb#40
  def initialize(&block); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/remote/dispatcher.rb#44
  def match?(path); end
end

# Matches on the produc's path
#
# source://ddtrace//lib/datadog/core/remote/dispatcher.rb#49
class Datadog::Core::Remote::Dispatcher::Matcher::Product < ::Datadog::Core::Remote::Dispatcher::Matcher
  # @return [Product] a new instance of Product
  #
  # source://ddtrace//lib/datadog/core/remote/dispatcher.rb#50
  def initialize(products); end
end

# Store Matcher and block to be executed on a match
#
# source://ddtrace//lib/datadog/core/remote/dispatcher.rb#23
class Datadog::Core::Remote::Dispatcher::Receiver
  # @return [Receiver] a new instance of Receiver
  #
  # source://ddtrace//lib/datadog/core/remote/dispatcher.rb#24
  def initialize(matcher, &block); end

  # source://ddtrace//lib/datadog/core/remote/dispatcher.rb#33
  def call(repository, changes); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/remote/dispatcher.rb#29
  def match?(path); end
end

# source://ddtrace//lib/datadog/core/remote/ext.rb#6
module Datadog::Core::Remote::Ext; end

# source://ddtrace//lib/datadog/core/remote/ext.rb#7
Datadog::Core::Remote::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/remote/ext.rb#8
Datadog::Core::Remote::Ext::ENV_POLL_INTERVAL_SECONDS = T.let(T.unsafe(nil), String)

# Endpoint negotiation
#
# source://ddtrace//lib/datadog/core/remote/negotiation.rb#9
class Datadog::Core::Remote::Negotiation
  # @return [Negotiation] a new instance of Negotiation
  #
  # source://ddtrace//lib/datadog/core/remote/negotiation.rb#10
  def initialize(_settings, agent_settings); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/remote/negotiation.rb#18
  def endpoint?(path); end

  private

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/remote/negotiation.rb#64
  def network_error?(error); end
end

# Worker executes a block every interval on a separate Thread
#
# source://ddtrace//lib/datadog/core/remote/worker.rb#7
class Datadog::Core::Remote::Worker
  # @raise [ArgumentError]
  # @return [Worker] a new instance of Worker
  #
  # source://ddtrace//lib/datadog/core/remote/worker.rb#8
  def initialize(interval:, &block); end

  # source://ddtrace//lib/datadog/core/remote/worker.rb#22
  def start; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/remote/worker.rb#64
  def started?; end

  # source://ddtrace//lib/datadog/core/remote/worker.rb#41
  def stop; end

  private

  # source://ddtrace//lib/datadog/core/remote/worker.rb#70
  def acquire_lock; end

  # source://ddtrace//lib/datadog/core/remote/worker.rb#88
  def call; end

  # source://ddtrace//lib/datadog/core/remote/worker.rb#78
  def poll(interval); end

  # source://ddtrace//lib/datadog/core/remote/worker.rb#74
  def release_lock; end
end

# source://ddtrace//lib/datadog/core/runtime/ext.rb#5
module Datadog::Core::Runtime; end

# source://ddtrace//lib/datadog/core/runtime/ext.rb#7
module Datadog::Core::Runtime::Ext; end

# Metrics
#
# source://ddtrace//lib/datadog/core/runtime/ext.rb#14
module Datadog::Core::Runtime::Ext::Metrics; end

# source://ddtrace//lib/datadog/core/runtime/ext.rb#15
Datadog::Core::Runtime::Ext::Metrics::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/runtime/ext.rb#17
Datadog::Core::Runtime::Ext::Metrics::METRIC_CLASS_COUNT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/runtime/ext.rb#22
Datadog::Core::Runtime::Ext::Metrics::METRIC_CONSTANT_CACHE_INVALIDATIONS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/runtime/ext.rb#23
Datadog::Core::Runtime::Ext::Metrics::METRIC_CONSTANT_CACHE_MISSES = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/runtime/ext.rb#18
Datadog::Core::Runtime::Ext::Metrics::METRIC_GC_PREFIX = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/runtime/ext.rb#20
Datadog::Core::Runtime::Ext::Metrics::METRIC_GLOBAL_CONSTANT_STATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/runtime/ext.rb#21
Datadog::Core::Runtime::Ext::Metrics::METRIC_GLOBAL_METHOD_STATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/runtime/ext.rb#19
Datadog::Core::Runtime::Ext::Metrics::METRIC_THREAD_COUNT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/runtime/ext.rb#24
Datadog::Core::Runtime::Ext::Metrics::METRIC_YJIT_CODE_GC_COUNT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/runtime/ext.rb#25
Datadog::Core::Runtime::Ext::Metrics::METRIC_YJIT_CODE_REGION_SIZE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/runtime/ext.rb#26
Datadog::Core::Runtime::Ext::Metrics::METRIC_YJIT_FREED_CODE_SIZE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/runtime/ext.rb#27
Datadog::Core::Runtime::Ext::Metrics::METRIC_YJIT_FREED_PAGE_COUNT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/runtime/ext.rb#28
Datadog::Core::Runtime::Ext::Metrics::METRIC_YJIT_INLINE_CODE_SIZE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/runtime/ext.rb#29
Datadog::Core::Runtime::Ext::Metrics::METRIC_YJIT_LIVE_PAGE_COUNT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/runtime/ext.rb#30
Datadog::Core::Runtime::Ext::Metrics::METRIC_YJIT_OBJECT_SHAPE_COUNT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/runtime/ext.rb#31
Datadog::Core::Runtime::Ext::Metrics::METRIC_YJIT_OUTLINED_CODE_SIZE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/runtime/ext.rb#33
Datadog::Core::Runtime::Ext::Metrics::TAG_SERVICE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/runtime/ext.rb#8
Datadog::Core::Runtime::Ext::TAG_ID = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/runtime/ext.rb#9
Datadog::Core::Runtime::Ext::TAG_LANG = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/runtime/ext.rb#10
Datadog::Core::Runtime::Ext::TAG_PROCESS_ID = T.let(T.unsafe(nil), String)

# For generating runtime metrics
#
# source://ddtrace//lib/datadog/core/runtime/metrics.rb#14
class Datadog::Core::Runtime::Metrics < ::Datadog::Core::Metrics::Client
  # @return [Metrics] a new instance of Metrics
  #
  # source://ddtrace//lib/datadog/core/runtime/metrics.rb#15
  def initialize(**options); end

  # source://ddtrace//lib/datadog/core/runtime/metrics.rb#98
  def default_metric_options; end

  # Flush all runtime metrics to Statsd client
  #
  # source://ddtrace//lib/datadog/core/runtime/metrics.rb#40
  def flush; end

  # source://ddtrace//lib/datadog/core/runtime/metrics.rb#86
  def gc_metrics; end

  # Associate service with runtime metrics
  #
  # source://ddtrace//lib/datadog/core/runtime/metrics.rb#25
  def register_service(service); end

  # source://ddtrace//lib/datadog/core/runtime/metrics.rb#92
  def try_flush; end

  private

  # source://ddtrace//lib/datadog/core/runtime/metrics.rb#115
  def compile_service_tags!; end

  # source://ddtrace//lib/datadog/core/runtime/metrics.rb#141
  def flush_yjit_stats; end

  # source://ddtrace//lib/datadog/core/runtime/metrics.rb#137
  def gauge_if_not_nil(metric_name, metric_value); end

  # source://ddtrace//lib/datadog/core/runtime/metrics.rb#121
  def nested_gc_metric(prefix, k, v); end

  # Returns the value of attribute service_tags.
  #
  # source://ddtrace//lib/datadog/core/runtime/metrics.rb#111
  def service_tags; end

  # Returns the value of attribute services.
  #
  # source://ddtrace//lib/datadog/core/runtime/metrics.rb#111
  def services; end

  # source://ddtrace//lib/datadog/core/runtime/metrics.rb#133
  def to_metric_name(str); end
end

# source://ddtrace//lib/datadog/core/telemetry/ext.rb#5
module Datadog::Core::Telemetry; end

# Telemetry entrypoint, coordinates sending telemetry events at various points in app lifecycle.
#
# source://ddtrace//lib/datadog/core/telemetry/client.rb#11
class Datadog::Core::Telemetry::Client
  include ::Datadog::Core::Utils::Forking::ClassExtensions
  include ::Datadog::Core::Utils::Forking

  # @param enabled [Boolean] Determines whether telemetry events should be sent to the API
  # @param heartbeat_interval_seconds [Float] How frequently heartbeats will be reported, in seconds.
  # @return [Client] a new instance of Client
  #
  # source://ddtrace//lib/datadog/core/utils/forking.rb#47
  def initialize(*args, **kwargs, &block); end

  # Report configuration changes caused by Remote Configuration.
  #
  # source://ddtrace//lib/datadog/core/telemetry/client.rb#71
  def client_configuration_change!(changes); end

  # source://ddtrace//lib/datadog/core/telemetry/client.rb#32
  def disable!; end

  # source://ddtrace//lib/datadog/core/telemetry/client.rb#51
  def emit_closing!; end

  # Returns the value of attribute emitter.
  #
  # source://ddtrace//lib/datadog/core/telemetry/client.rb#12
  def emitter; end

  # Returns the value of attribute enabled.
  #
  # source://ddtrace//lib/datadog/core/telemetry/client.rb#12
  def enabled; end

  # source://ddtrace//lib/datadog/core/telemetry/client.rb#64
  def integrations_change!; end

  # source://ddtrace//lib/datadog/core/telemetry/client.rb#37
  def started!; end

  # source://ddtrace//lib/datadog/core/telemetry/client.rb#57
  def stop!; end

  # Returns the value of attribute unsupported.
  #
  # source://ddtrace//lib/datadog/core/telemetry/client.rb#12
  def unsupported; end

  # Returns the value of attribute worker.
  #
  # source://ddtrace//lib/datadog/core/telemetry/client.rb#12
  def worker; end

  private

  # source://ddtrace//lib/datadog/core/telemetry/client.rb#79
  def heartbeat!; end
end

# Module defining methods for collecting metadata for telemetry
#
# source://ddtrace//lib/datadog/core/telemetry/collector.rb#20
module Datadog::Core::Telemetry::Collector
  include ::Datadog::Core::Configuration

  # Forms a hash of configuration key value pairs to be sent in the additional payload
  #
  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#25
  def additional_payload; end

  # Forms a telemetry application object
  #
  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#30
  def application; end

  # Forms a hash of standard key value pairs to be sent in the app-started event configuration
  #
  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#45
  def configurations; end

  # Forms a telemetry app-started dependencies object
  #
  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#56
  def dependencies; end

  # Forms a telemetry host object
  #
  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#66
  def host; end

  # Forms a telemetry app-started integrations object
  #
  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#77
  def integrations; end

  # Returns the runtime ID of the current process
  #
  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#93
  def runtime_id; end

  # Returns the current as a UNIX timestamp in seconds
  #
  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#98
  def tracer_time; end

  private

  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#124
  def additional_payload_variables; end

  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#183
  def agent_transport; end

  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#179
  def appsec; end

  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#155
  def env; end

  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#145
  def format_configuration_value(value); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#196
  def instrumented?(integration); end

  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#192
  def instrumented_integrations; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#204
  def integration_auto_instrument?(integration); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#208
  def integration_compatible?(integration); end

  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#212
  def integration_version(integration); end

  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#167
  def library_version; end

  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#216
  def patch_error(integration); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#200
  def patched?(integration); end

  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#171
  def products; end

  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#175
  def profiler; end

  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#159
  def service_name; end

  # source://ddtrace//lib/datadog/core/telemetry/collector.rb#163
  def service_version; end
end

# source://ddtrace//lib/datadog/core/telemetry/collector.rb#104
Datadog::Core::Telemetry::Collector::TARGET_OPTIONS = T.let(T.unsafe(nil), Array)

# Class that emits telemetry events
#
# source://ddtrace//lib/datadog/core/telemetry/emitter.rb#10
class Datadog::Core::Telemetry::Emitter
  extend ::Datadog::Core::Utils::Forking

  # @param sequence [Datadog::Core::Utils::Sequence] Sequence object that stores and increments a counter
  # @param http_transport [Datadog::Core::Telemetry::Http::Transport] Transport object that can be used to send
  #   telemetry requests via the agent
  # @return [Emitter] a new instance of Emitter
  #
  # source://ddtrace//lib/datadog/core/telemetry/emitter.rb#18
  def initialize(http_transport: T.unsafe(nil)); end

  # Returns the value of attribute http_transport.
  #
  # source://ddtrace//lib/datadog/core/telemetry/emitter.rb#11
  def http_transport; end

  # Retrieves and emits a TelemetryRequest object based on the request type specified
  #
  # @param request_type [String] the type of telemetry request to collect data for
  # @param data [Object] arbitrary object to be passed to the respective `request_type` handler
  #
  # source://ddtrace//lib/datadog/core/telemetry/emitter.rb#25
  def request(request_type, data: T.unsafe(nil)); end

  class << self
    # Initializes a Sequence object to track seq_id if not already initialized; else returns stored
    # Sequence object
    #
    # source://ddtrace//lib/datadog/core/telemetry/emitter.rb#41
    def sequence; end
  end
end

# Class defining methods to construct a Telemetry event
#
# source://ddtrace//lib/datadog/core/telemetry/event.rb#12
class Datadog::Core::Telemetry::Event
  include ::Datadog::Core::Configuration
  include ::Datadog::Core::Telemetry::Collector

  # @return [Event] a new instance of Event
  #
  # source://ddtrace//lib/datadog/core/telemetry/event.rb#20
  def initialize; end

  # Returns the value of attribute api_version.
  #
  # source://ddtrace//lib/datadog/core/telemetry/event.rb#17
  def api_version; end

  # Forms a TelemetryRequest object based on the event request_type
  #
  # @param request_type [String] the type of telemetry request to collect data for
  # @param seq_id [Integer] the ID of the request; incremented each time a telemetry request is sent to the API
  # @param data [Object] arbitrary object to be passed to the respective `request_type` handler
  #
  # source://ddtrace//lib/datadog/core/telemetry/event.rb#28
  def telemetry_request(request_type:, seq_id:, data: T.unsafe(nil)); end

  private

  # DEV: During the transition from V1 to V2, the backend accepts many V2
  # DEV: payloads through the V1 transport protocol.
  # DEV: The `app-client-configuration-change` payload is one of them.
  # DEV: Once V2 is fully implemented, `Telemetry::V2::AppClientConfigurationChange`
  # DEV: should be reusable without major modifications.
  #
  # source://ddtrace//lib/datadog/core/telemetry/event.rb#76
  def app_client_configuration_change(data); end

  # source://ddtrace//lib/datadog/core/telemetry/event.rb#67
  def app_integrations_change; end

  # source://ddtrace//lib/datadog/core/telemetry/event.rb#58
  def app_started; end

  # source://ddtrace//lib/datadog/core/telemetry/event.rb#43
  def payload(request_type, data); end
end

# source://ddtrace//lib/datadog/core/telemetry/event.rb#15
Datadog::Core::Telemetry::Event::API_VERSION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/telemetry/ext.rb#6
module Datadog::Core::Telemetry::Ext; end

# source://ddtrace//lib/datadog/core/telemetry/ext.rb#7
Datadog::Core::Telemetry::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/telemetry/ext.rb#8
Datadog::Core::Telemetry::Ext::ENV_HEARTBEAT_INTERVAL = T.let(T.unsafe(nil), String)

# Periodically (every DEFAULT_INTERVAL_SECONDS) sends a heartbeat event to the telemetry API.
#
# source://ddtrace//lib/datadog/core/telemetry/heartbeat.rb#10
class Datadog::Core::Telemetry::Heartbeat < ::Datadog::Core::Worker
  include ::Datadog::Core::Workers::IntervalLoop::PrependedMethods
  include ::Datadog::Core::Workers::Async::Thread::PrependedMethods
  include ::Datadog::Core::Workers::Polling::PrependedMethods
  include ::Datadog::Core::Workers::Polling
  include ::Datadog::Core::Workers::IntervalLoop
  include ::Datadog::Core::Workers::Async::Thread

  # @return [Heartbeat] a new instance of Heartbeat
  #
  # source://ddtrace//lib/datadog/core/telemetry/heartbeat.rb#13
  def initialize(heartbeat_interval_seconds:, enabled: T.unsafe(nil), &block); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/telemetry/heartbeat.rb#23
  def loop_wait_before_first_iteration?; end

  private

  # source://ddtrace//lib/datadog/core/telemetry/heartbeat.rb#29
  def start; end
end

# source://ddtrace//lib/datadog/core/telemetry/http/env.rb#6
module Datadog::Core::Telemetry::Http; end

# source://ddtrace//lib/datadog/core/telemetry/http/adapters/net.rb#7
module Datadog::Core::Telemetry::Http::Adapters; end

# Class defining methods to make http requests via NET
#
# source://ddtrace//lib/datadog/core/telemetry/http/adapters/net.rb#9
class Datadog::Core::Telemetry::Http::Adapters::Net
  # @return [Net] a new instance of Net
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/adapters/net.rb#18
  def initialize(hostname:, port: T.unsafe(nil), timeout: T.unsafe(nil), ssl: T.unsafe(nil)); end

  # Returns the value of attribute hostname.
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/adapters/net.rb#10
  def hostname; end

  # source://ddtrace//lib/datadog/core/telemetry/http/adapters/net.rb#25
  def open(&block); end

  # Returns the value of attribute port.
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/adapters/net.rb#10
  def port; end

  # source://ddtrace//lib/datadog/core/telemetry/http/adapters/net.rb#34
  def post(env); end

  # Returns the value of attribute ssl.
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/adapters/net.rb#10
  def ssl; end

  # Returns the value of attribute timeout.
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/adapters/net.rb#10
  def timeout; end
end

# source://ddtrace//lib/datadog/core/telemetry/http/adapters/net.rb#16
Datadog::Core::Telemetry::Http::Adapters::Net::DEFAULT_TIMEOUT = T.let(T.unsafe(nil), Integer)

# Data structure for an HTTP Response
#
# source://ddtrace//lib/datadog/core/telemetry/http/adapters/net.rb#51
class Datadog::Core::Telemetry::Http::Adapters::Net::Response
  include ::Datadog::Core::Telemetry::Http::Response

  # @return [Response] a new instance of Response
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/adapters/net.rb#56
  def initialize(http_response); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/adapters/net.rb#90
  def client_error?; end

  # source://ddtrace//lib/datadog/core/telemetry/http/adapters/net.rb#66
  def code; end

  # Returns the value of attribute http_response.
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/adapters/net.rb#54
  def http_response; end

  # source://ddtrace//lib/datadog/core/telemetry/http/adapters/net.rb#102
  def inspect; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/adapters/net.rb#84
  def not_found?; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/adapters/net.rb#72
  def ok?; end

  # source://ddtrace//lib/datadog/core/telemetry/http/adapters/net.rb#60
  def payload; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/adapters/net.rb#96
  def server_error?; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/adapters/net.rb#78
  def unsupported?; end
end

# Data structure for an HTTP request
#
# source://ddtrace//lib/datadog/core/telemetry/http/env.rb#8
class Datadog::Core::Telemetry::Http::Env
  # Returns the value of attribute body.
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/env.rb#9
  def body; end

  # Sets the attribute body
  #
  # @param value the value to set the attribute body to.
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/env.rb#9
  def body=(_arg0); end

  # source://ddtrace//lib/datadog/core/telemetry/http/env.rb#13
  def headers; end

  # Sets the attribute headers
  #
  # @param value the value to set the attribute headers to.
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/env.rb#11
  def headers=(_arg0); end

  # Returns the value of attribute path.
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/env.rb#9
  def path; end

  # Sets the attribute path
  #
  # @param value the value to set the attribute path to.
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/env.rb#9
  def path=(_arg0); end
end

# source://ddtrace//lib/datadog/core/telemetry/http/ext.rb#7
module Datadog::Core::Telemetry::Http::Ext; end

# source://ddtrace//lib/datadog/core/telemetry/http/ext.rb#17
Datadog::Core::Telemetry::Http::Ext::AGENT_ENDPOINT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/telemetry/http/ext.rb#15
Datadog::Core::Telemetry::Http::Ext::API_VERSION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/telemetry/http/ext.rb#14
Datadog::Core::Telemetry::Http::Ext::CONTENT_TYPE_APPLICATION_JSON = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/telemetry/http/ext.rb#10
Datadog::Core::Telemetry::Http::Ext::HEADER_CONTENT_LENGTH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/telemetry/http/ext.rb#9
Datadog::Core::Telemetry::Http::Ext::HEADER_CONTENT_TYPE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/telemetry/http/ext.rb#8
Datadog::Core::Telemetry::Http::Ext::HEADER_DD_API_KEY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/telemetry/http/ext.rb#11
Datadog::Core::Telemetry::Http::Ext::HEADER_DD_TELEMETRY_API_VERSION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/telemetry/http/ext.rb#12
Datadog::Core::Telemetry::Http::Ext::HEADER_DD_TELEMETRY_REQUEST_TYPE = T.let(T.unsafe(nil), String)

# A generic error response for internal errors
#
# source://ddtrace//lib/datadog/core/telemetry/http/response.rb#44
class Datadog::Core::Telemetry::Http::InternalErrorResponse
  include ::Datadog::Core::Telemetry::Http::Response

  # @return [InternalErrorResponse] a new instance of InternalErrorResponse
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/response.rb#49
  def initialize(error); end

  # Returns the value of attribute error.
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/response.rb#47
  def error; end

  # source://ddtrace//lib/datadog/core/telemetry/http/response.rb#57
  def inspect; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/response.rb#53
  def internal_error?; end
end

# Module for base HTTP response
#
# source://ddtrace//lib/datadog/core/telemetry/http/response.rb#6
module Datadog::Core::Telemetry::Http::Response
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/response.rb#23
  def client_error?; end

  # source://ddtrace//lib/datadog/core/telemetry/http/response.rb#35
  def inspect; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/response.rb#31
  def internal_error?; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/response.rb#19
  def not_found?; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/response.rb#11
  def ok?; end

  # source://ddtrace//lib/datadog/core/telemetry/http/response.rb#7
  def payload; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/response.rb#27
  def server_error?; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/response.rb#15
  def unsupported?; end
end

# Class to send telemetry data to Telemetry API
# Currently only supports the HTTP protocol.
#
# source://ddtrace//lib/datadog/core/telemetry/http/transport.rb#14
class Datadog::Core::Telemetry::Http::Transport
  # @return [Transport] a new instance of Transport
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/transport.rb#21
  def initialize; end

  # Returns the value of attribute host.
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/transport.rb#15
  def host; end

  # Returns the value of attribute path.
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/transport.rb#15
  def path; end

  # Returns the value of attribute port.
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/transport.rb#15
  def port; end

  # source://ddtrace//lib/datadog/core/telemetry/http/transport.rb#29
  def request(request_type:, payload:); end

  # Returns the value of attribute ssl.
  #
  # source://ddtrace//lib/datadog/core/telemetry/http/transport.rb#15
  def ssl; end

  private

  # source://ddtrace//lib/datadog/core/telemetry/http/transport.rb#48
  def adapter; end

  # source://ddtrace//lib/datadog/core/telemetry/http/transport.rb#39
  def headers(request_type:, api_version: T.unsafe(nil)); end
end

# source://ddtrace//lib/datadog/core/telemetry/v1/application.rb#6
module Datadog::Core::Telemetry::V1; end

# Describes payload for telemetry V1 API app-integrations-change event
#
# source://ddtrace//lib/datadog/core/telemetry/v1/app_event.rb#8
class Datadog::Core::Telemetry::V1::AppEvent
  # @param additional_payload [Array<Telemetry::V1::Configuration>] List of Additional payload to track (any key
  #   value not mentioned and doesn't fit under a metric)
  # @param configuration [Array<Telemetry::V1::Configuration>] List of Tracer related configuration data
  # @param dependencies [Array<Telemetry::V1::Dependency>] List of all loaded modules requested by the app
  # @param integrations [Array<Telemetry::V1::Integration>] List of integrations that are available within the app
  #   and applicable to be traced
  # @return [AppEvent] a new instance of AppEvent
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/app_event.rb#21
  def initialize(additional_payload: T.unsafe(nil), configuration: T.unsafe(nil), dependencies: T.unsafe(nil), integrations: T.unsafe(nil)); end

  # Returns the value of attribute additional_payload.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/app_event.rb#9
  def additional_payload; end

  # Returns the value of attribute configuration.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/app_event.rb#9
  def configuration; end

  # Returns the value of attribute dependencies.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/app_event.rb#9
  def dependencies; end

  # Returns the value of attribute integrations.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/app_event.rb#9
  def integrations; end

  # source://ddtrace//lib/datadog/core/telemetry/v1/app_event.rb#28
  def to_h; end

  private

  # source://ddtrace//lib/datadog/core/telemetry/v1/app_event.rb#45
  def map_array(arr); end

  # source://ddtrace//lib/datadog/core/telemetry/v1/app_event.rb#39
  def map_hash(hash); end
end

# Describes attributes for application environment object
#
# source://ddtrace//lib/datadog/core/telemetry/v1/application.rb#8
class Datadog::Core::Telemetry::V1::Application
  # @param env [String] Service's environment
  # @param language_name [String] 'ruby'
  # @param language_version [String] Version of language used
  # @param products [Telemetry::V1::Product] Contains information about specific products added to the environment
  # @param runtime_name [String] Runtime being used
  # @param runtime_patches [String] String of patches applied to the runtime
  # @param runtime_version [String] Runtime version; potentially the same as :language_version
  # @param service_name [String] Services name (DD_SERVICE)
  # @param service_version [String] Services version (DD_VERSION)
  # @param tracer_version [String] Version of the used tracer
  # @return [Application] a new instance of Application
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/application.rb#38
  def initialize(language_name:, language_version:, service_name:, tracer_version:, env: T.unsafe(nil), products: T.unsafe(nil), runtime_name: T.unsafe(nil), runtime_patches: T.unsafe(nil), runtime_version: T.unsafe(nil), service_version: T.unsafe(nil)); end

  # Returns the value of attribute env.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/application.rb#16
  def env; end

  # Returns the value of attribute language_name.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/application.rb#16
  def language_name; end

  # Returns the value of attribute language_version.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/application.rb#16
  def language_version; end

  # Returns the value of attribute products.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/application.rb#16
  def products; end

  # Returns the value of attribute runtime_name.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/application.rb#16
  def runtime_name; end

  # Returns the value of attribute runtime_patches.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/application.rb#16
  def runtime_patches; end

  # Returns the value of attribute runtime_version.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/application.rb#16
  def runtime_version; end

  # Returns the value of attribute service_name.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/application.rb#16
  def service_name; end

  # Returns the value of attribute service_version.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/application.rb#16
  def service_version; end

  # source://ddtrace//lib/datadog/core/telemetry/v1/application.rb#60
  def to_h; end

  # Returns the value of attribute tracer_version.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/application.rb#16
  def tracer_version; end

  private

  # Validates required arguments passed to the class on initialization are not nil
  #
  # @raise [ArgumentError]
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/application.rb#82
  def validate(language_name:, language_version:, service_name:, tracer_version:); end
end

# source://ddtrace//lib/datadog/core/telemetry/v1/application.rb#11
Datadog::Core::Telemetry::V1::Application::ERROR_NIL_LANGUAGE_NAME_MESSAGE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/telemetry/v1/application.rb#12
Datadog::Core::Telemetry::V1::Application::ERROR_NIL_LANGUAGE_VERSION_MESSAGE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/telemetry/v1/application.rb#13
Datadog::Core::Telemetry::V1::Application::ERROR_NIL_SERVICE_NAME_MESSAGE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/telemetry/v1/application.rb#14
Datadog::Core::Telemetry::V1::Application::ERROR_NIL_TRACER_VERSION_MESSAGE = T.let(T.unsafe(nil), String)

# Describes attributes for dependency object
#
# source://ddtrace//lib/datadog/core/telemetry/v1/dependency.rb#8
class Datadog::Core::Telemetry::V1::Dependency
  # @param name [String] Module name
  # @param version [String] Version of resolved module
  # @param hash [String] Dependency hash, in case `version` is not available
  # @raise [ArgumentError]
  # @return [Dependency] a new instance of Dependency
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/dependency.rb#21
  def initialize(name:, version: T.unsafe(nil), hash: T.unsafe(nil)); end

  # Returns the value of attribute hash.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/dependency.rb#13
  def hash; end

  # Returns the value of attribute name.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/dependency.rb#13
  def name; end

  # source://ddtrace//lib/datadog/core/telemetry/v1/dependency.rb#30
  def to_h; end

  # Returns the value of attribute version.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/dependency.rb#13
  def version; end
end

# source://ddtrace//lib/datadog/core/telemetry/v1/dependency.rb#11
Datadog::Core::Telemetry::V1::Dependency::ERROR_NIL_NAME_MESSAGE = T.let(T.unsafe(nil), String)

# Describes attributes for host object
#
# source://ddtrace//lib/datadog/core/telemetry/v1/host.rb#10
class Datadog::Core::Telemetry::V1::Host
  # @param container_id [String] Docker container ID
  # @param hostname [String] uname -n
  # @param kernel_name [String] uname -s
  # @param kernel_release [String] uname -r
  # @param kernel_version [String] uname -v
  # @param os [String] uname -o
  # @param os_version [String] Version of OS running
  # @return [Host] a new instance of Host
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/host.rb#29
  def initialize(container_id: T.unsafe(nil), hostname: T.unsafe(nil), kernel_name: T.unsafe(nil), kernel_release: T.unsafe(nil), kernel_version: T.unsafe(nil), os_version: T.unsafe(nil), os: T.unsafe(nil)); end

  # Returns the value of attribute container_id.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/host.rb#13
  def container_id; end

  # Returns the value of attribute hostname.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/host.rb#13
  def hostname; end

  # Returns the value of attribute kernel_name.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/host.rb#13
  def kernel_name; end

  # Returns the value of attribute kernel_release.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/host.rb#13
  def kernel_release; end

  # Returns the value of attribute kernel_version.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/host.rb#13
  def kernel_version; end

  # Returns the value of attribute os.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/host.rb#13
  def os; end

  # Returns the value of attribute os_version.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/host.rb#13
  def os_version; end

  # source://ddtrace//lib/datadog/core/telemetry/v1/host.rb#42
  def to_h; end
end

# Describes attributes for integration object
#
# source://ddtrace//lib/datadog/core/telemetry/v1/integration.rb#8
class Datadog::Core::Telemetry::V1::Integration
  # @param enabled [Boolean] Whether integration is enabled at time of request
  # @param name [String] Integration name
  # @param auto_enabled [Boolean] If integration is not enabled by default, but by user choice
  # @param compatible [Boolean] If integration is available, but incompatible
  # @param error [String] Error message if integration fails to load
  # @param version [String] Integration version (if specified in app-started, it should be for other events too)
  # @return [Integration] a new instance of Integration
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/integration.rb#28
  def initialize(enabled:, name:, auto_enabled: T.unsafe(nil), compatible: T.unsafe(nil), error: T.unsafe(nil), version: T.unsafe(nil)); end

  # Returns the value of attribute auto_enabled.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/integration.rb#14
  def auto_enabled; end

  # Returns the value of attribute compatible.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/integration.rb#14
  def compatible; end

  # Returns the value of attribute enabled.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/integration.rb#14
  def enabled; end

  # Returns the value of attribute error.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/integration.rb#14
  def error; end

  # Returns the value of attribute name.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/integration.rb#14
  def name; end

  # source://ddtrace//lib/datadog/core/telemetry/v1/integration.rb#38
  def to_h; end

  # Returns the value of attribute version.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/integration.rb#14
  def version; end

  private

  # Validates all required arguments passed to the class on initialization are not nil
  #
  # @raise [ArgumentError]
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/integration.rb#56
  def validate(enabled:, name:); end
end

# source://ddtrace//lib/datadog/core/telemetry/v1/integration.rb#11
Datadog::Core::Telemetry::V1::Integration::ERROR_NIL_ENABLED_MESSAGE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/telemetry/v1/integration.rb#12
Datadog::Core::Telemetry::V1::Integration::ERROR_NIL_NAME_MESSAGE = T.let(T.unsafe(nil), String)

# Describes attributes for products object
#
# source://ddtrace//lib/datadog/core/telemetry/v1/product.rb#10
class Datadog::Core::Telemetry::V1::Product
  # @param appsec [Telemetry::V1::AppSec] Holds custom information about the appsec product
  # @param profiler [Telemetry::V1::Profiler] Holds custom information about the profiler product
  # @return [Product] a new instance of Product
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/product.rb#19
  def initialize(appsec: T.unsafe(nil), profiler: T.unsafe(nil)); end

  # Returns the value of attribute appsec.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/product.rb#13
  def appsec; end

  # Returns the value of attribute profiler.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/product.rb#13
  def profiler; end

  # source://ddtrace//lib/datadog/core/telemetry/v1/product.rb#24
  def to_h; end
end

# Describes attributes for telemetry API request
#
# source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#8
class Datadog::Core::Telemetry::V1::TelemetryRequest
  # @param api_version [String] Requested API version, `v1`
  # @param application [Telemetry::V1::Application] Object that contains information about the environment of the
  #   application
  # @param host [Telemetry::V1::Host] Object that holds host related information
  # @param payload [Telemetry::V1::AppEvent] The payload of the request, type impacted by :request_type
  # @param request_type [String] Requested API function impacting the Payload type, `app-started`
  # @param runtime_id [String] V4 UUID that represents a tracer session
  # @param seq_id [Integer] Counter that should be auto incremented every time an API call is being made
  # @param tracer_time [Integer] Unix timestamp (in seconds) of when the message is being sent
  # @param debug [Boolean] Flag that enables payload debug mode
  # @param session_id [String] V4 UUID that represents the session of the top level tracer process, often same\
  #   as runtime_id
  # @return [TelemetryRequest] a new instance of TelemetryRequest
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#44
  def initialize(api_version:, application:, host:, payload:, request_type:, runtime_id:, seq_id:, tracer_time:, debug: T.unsafe(nil), session_id: T.unsafe(nil)); end

  # Returns the value of attribute api_version.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#20
  def api_version; end

  # Returns the value of attribute application.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#20
  def application; end

  # Returns the value of attribute debug.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#20
  def debug; end

  # Returns the value of attribute host.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#20
  def host; end

  # Returns the value of attribute payload.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#20
  def payload; end

  # Returns the value of attribute request_type.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#20
  def request_type; end

  # Returns the value of attribute runtime_id.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#20
  def runtime_id; end

  # Returns the value of attribute seq_id.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#20
  def seq_id; end

  # Returns the value of attribute session_id.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#20
  def session_id; end

  # source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#70
  def to_h; end

  # Returns the value of attribute tracer_time.
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#20
  def tracer_time; end

  private

  # Validates all required arguments passed to the class on initialization are not nil
  #
  # @raise [ArgumentError]
  #
  # source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#92
  def validate(api_version:, application:, host:, payload:, request_type:, runtime_id:, seq_id:, tracer_time:); end
end

# source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#11
Datadog::Core::Telemetry::V1::TelemetryRequest::ERROR_NIL_API_VERSION_MESSAGE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#12
Datadog::Core::Telemetry::V1::TelemetryRequest::ERROR_NIL_APPLICATION_MESSAGE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#13
Datadog::Core::Telemetry::V1::TelemetryRequest::ERROR_NIL_HOST_MESSAGE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#14
Datadog::Core::Telemetry::V1::TelemetryRequest::ERROR_NIL_PAYLOAD_MESSAGE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#15
Datadog::Core::Telemetry::V1::TelemetryRequest::ERROR_NIL_REQUEST_TYPE_MESSAGE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#16
Datadog::Core::Telemetry::V1::TelemetryRequest::ERROR_NIL_RUNTIME_ID_MESSAGE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#17
Datadog::Core::Telemetry::V1::TelemetryRequest::ERROR_NIL_SEQ_ID_MESSAGE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/telemetry/v1/telemetry_request.rb#18
Datadog::Core::Telemetry::V1::TelemetryRequest::ERROR_NIL_TRACER_TIME_MESSAGE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/core/telemetry/v2/request.rb#6
module Datadog::Core::Telemetry::V2; end

# Telemetry 'app-client-configuration-change' event.
# This request should contain client library configuration that have changes since the app-started event.
#
# source://ddtrace//lib/datadog/core/telemetry/v2/app_client_configuration_change.rb#11
class Datadog::Core::Telemetry::V2::AppClientConfigurationChange < ::Datadog::Core::Telemetry::V2::Request
  # @return [AppClientConfigurationChange] a new instance of AppClientConfigurationChange
  #
  # source://ddtrace//lib/datadog/core/telemetry/v2/app_client_configuration_change.rb#12
  def initialize(configuration_changes, origin: T.unsafe(nil)); end

  # @see [Request#to_h]
  #
  # source://ddtrace//lib/datadog/core/telemetry/v2/app_client_configuration_change.rb#20
  def to_h; end

  private

  # source://ddtrace//lib/datadog/core/telemetry/v2/app_client_configuration_change.rb#26
  def payload; end
end

# Base request object for Telemetry V2.
#
# `#to_h` is the main API, which returns a Ruby
# Hash that will be serialized as JSON.
#
# source://ddtrace//lib/datadog/core/telemetry/v2/request.rb#11
class Datadog::Core::Telemetry::V2::Request
  # @param request_type [String] the Telemetry request type, which dictates how the Hash payload should be processed
  # @return [Request] a new instance of Request
  #
  # source://ddtrace//lib/datadog/core/telemetry/v2/request.rb#13
  def initialize(request_type); end

  # Converts this request to a Hash that will
  # be serialized as JSON.
  #
  # @return [Hash]
  #
  # source://ddtrace//lib/datadog/core/telemetry/v2/request.rb#20
  def to_h; end
end

# source://ddtrace//lib/datadog/core/transport/http/api/spec.rb#5
module Datadog::Core::Transport; end

# source://ddtrace//lib/datadog/core/transport/config.rb#9
module Datadog::Core::Transport::Config; end

# Data transfer object for encoded traces
#
# source://ddtrace//lib/datadog/core/transport/config.rb#11
class Datadog::Core::Transport::Config::EncodedParcel
  include ::Datadog::Transport::Parcel

  # source://ddtrace//lib/datadog/core/transport/config.rb#14
  def count; end
end

# Config request
#
# source://ddtrace//lib/datadog/core/transport/config.rb#20
class Datadog::Core::Transport::Config::Request < ::Datadog::Transport::Request; end

# Config response
#
# source://ddtrace//lib/datadog/core/transport/config.rb#24
module Datadog::Core::Transport::Config::Response
  # Returns the value of attribute client_configs.
  #
  # source://ddtrace//lib/datadog/core/transport/config.rb#25
  def client_configs; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/transport/config.rb#27
  def empty?; end

  # Returns the value of attribute roots.
  #
  # source://ddtrace//lib/datadog/core/transport/config.rb#25
  def roots; end

  # Returns the value of attribute target_files.
  #
  # source://ddtrace//lib/datadog/core/transport/config.rb#25
  def target_files; end

  # Returns the value of attribute targets.
  #
  # source://ddtrace//lib/datadog/core/transport/config.rb#25
  def targets; end
end

# Config transport
#
# source://ddtrace//lib/datadog/core/transport/config.rb#33
class Datadog::Core::Transport::Config::Transport
  # @return [Transport] a new instance of Transport
  #
  # source://ddtrace//lib/datadog/core/transport/config.rb#36
  def initialize(apis, default_api); end

  # Returns the value of attribute apis.
  #
  # source://ddtrace//lib/datadog/core/transport/config.rb#34
  def apis; end

  # Returns the value of attribute client.
  #
  # source://ddtrace//lib/datadog/core/transport/config.rb#34
  def client; end

  # source://ddtrace//lib/datadog/core/transport/config.rb#51
  def current_api; end

  # Returns the value of attribute current_api_id.
  #
  # source://ddtrace//lib/datadog/core/transport/config.rb#34
  def current_api_id; end

  # Returns the value of attribute default_api.
  #
  # source://ddtrace//lib/datadog/core/transport/config.rb#34
  def default_api; end

  # there is only one transport! it's negotiation!
  #
  # source://ddtrace//lib/datadog/core/transport/config.rb#43
  def send_config(payload); end
end

# Namespace for HTTP transport components
#
# source://ddtrace//lib/datadog/core/transport/http/api/spec.rb#6
module Datadog::Core::Transport::HTTP
  private

  # source://ddtrace//lib/datadog/core/transport/http.rb#131
  def default_adapter; end

  # source://ddtrace//lib/datadog/core/transport/http.rb#116
  def default_headers; end

  # source://ddtrace//lib/datadog/core/transport/http.rb#135
  def default_hostname(logger: T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/core/transport/http.rb#144
  def default_port(logger: T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/core/transport/http.rb#153
  def default_url(logger: T.unsafe(nil)); end

  # Builds a new Transport::HTTP::Client
  #
  # source://ddtrace//lib/datadog/core/transport/http.rb#54
  def new(klass, &block); end

  # Builds a new Transport::HTTP::Client with default settings
  # Pass a block to override any settings.
  #
  # source://ddtrace//lib/datadog/core/transport/http.rb#60
  def root(agent_settings: T.unsafe(nil), **options); end

  # Builds a new Transport::HTTP::Client with default settings
  # Pass a block to override any settings.
  #
  # source://ddtrace//lib/datadog/core/transport/http.rb#89
  def v7(agent_settings: T.unsafe(nil), **options); end

  class << self
    # source://ddtrace//lib/datadog/core/transport/http.rb#131
    def default_adapter; end

    # source://ddtrace//lib/datadog/core/transport/http.rb#116
    def default_headers; end

    # source://ddtrace//lib/datadog/core/transport/http.rb#135
    def default_hostname(logger: T.unsafe(nil)); end

    # source://ddtrace//lib/datadog/core/transport/http.rb#144
    def default_port(logger: T.unsafe(nil)); end

    # source://ddtrace//lib/datadog/core/transport/http.rb#153
    def default_url(logger: T.unsafe(nil)); end

    # Builds a new Transport::HTTP::Client
    #
    # source://ddtrace//lib/datadog/core/transport/http.rb#54
    def new(klass, &block); end

    # Builds a new Transport::HTTP::Client with default settings
    # Pass a block to override any settings.
    #
    # source://ddtrace//lib/datadog/core/transport/http.rb#60
    def root(agent_settings: T.unsafe(nil), **options); end

    # Builds a new Transport::HTTP::Client with default settings
    # Pass a block to override any settings.
    #
    # source://ddtrace//lib/datadog/core/transport/http.rb#89
    def v7(agent_settings: T.unsafe(nil), **options); end
  end
end

# Namespace for API components
#
# source://ddtrace//lib/datadog/core/transport/http/api/spec.rb#7
module Datadog::Core::Transport::HTTP::API
  private

  # source://ddtrace//lib/datadog/core/transport/http/api.rb#38
  def defaults; end

  class << self
    # source://ddtrace//lib/datadog/core/transport/http/api.rb#38
    def defaults; end
  end
end

# An API configured with adapter and routes
#
# source://ddtrace//lib/datadog/core/transport/http/api/instance.rb#9
class Datadog::Core::Transport::HTTP::API::Instance
  include ::Datadog::Core::Transport::HTTP::Negotiation::API::Instance
  include ::Datadog::Core::Transport::HTTP::Config::API::Instance

  # @return [Instance] a new instance of Instance
  #
  # source://ddtrace//lib/datadog/core/transport/http/api/instance.rb#15
  def initialize(spec, adapter, options = T.unsafe(nil)); end

  # Returns the value of attribute adapter.
  #
  # source://ddtrace//lib/datadog/core/transport/http/api/instance.rb#10
  def adapter; end

  # source://ddtrace//lib/datadog/core/transport/http/api/instance.rb#25
  def call(env); end

  # source://ddtrace//lib/datadog/core/transport/http/api/instance.rb#21
  def encoder; end

  # Returns the value of attribute headers.
  #
  # source://ddtrace//lib/datadog/core/transport/http/api/instance.rb#10
  def headers; end

  # Returns the value of attribute spec.
  #
  # source://ddtrace//lib/datadog/core/transport/http/api/instance.rb#10
  def spec; end
end

# Default API versions
#
# source://ddtrace//lib/datadog/core/transport/http/api.rb#33
Datadog::Core::Transport::HTTP::API::ROOT = T.let(T.unsafe(nil), String)

# Specification for an HTTP API
# Defines behaviors without specific configuration details.
#
# source://ddtrace//lib/datadog/core/transport/http/api/spec.rb#10
class Datadog::Core::Transport::HTTP::API::Spec
  include ::Datadog::Core::Transport::HTTP::Negotiation::API::Spec
  include ::Datadog::Core::Transport::HTTP::Config::API::Spec

  # @return [Spec] a new instance of Spec
  # @yield [_self]
  # @yieldparam _self [Datadog::Core::Transport::HTTP::API::Spec] the object that the method was called on
  #
  # source://ddtrace//lib/datadog/core/transport/http/api/spec.rb#11
  def initialize; end
end

# source://ddtrace//lib/datadog/core/transport/http/api.rb#34
Datadog::Core::Transport::HTTP::API::V7 = T.let(T.unsafe(nil), String)

# Builds new instances of Transport::HTTP::Client
#
# source://ddtrace//lib/datadog/core/transport/http/builder.rb#46
class Datadog::Core::Transport::HTTP::Builder
  # @return [Builder] a new instance of Builder
  # @yield [_self]
  # @yieldparam _self [Datadog::Core::Transport::HTTP::Builder] the object that the method was called on
  #
  # source://ddtrace//lib/datadog/core/transport/http/builder.rb#56
  def initialize; end

  # source://ddtrace//lib/datadog/core/transport/http/builder.rb#71
  def adapter(config, *args, **kwargs); end

  # Adds a new API to the client
  # Valid options:
  #  - :adapter
  #  - :default
  #  - :fallback
  #  - :headers
  #
  # source://ddtrace//lib/datadog/core/transport/http/builder.rb#98
  def api(key, spec, options = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/core/transport/http/builder.rb#151
  def api_instance_class; end

  # Returns the value of attribute api_options.
  #
  # source://ddtrace//lib/datadog/core/transport/http/builder.rb#49
  def api_options; end

  # Returns the value of attribute apis.
  #
  # source://ddtrace//lib/datadog/core/transport/http/builder.rb#49
  def apis; end

  # Returns the value of attribute default_adapter.
  #
  # source://ddtrace//lib/datadog/core/transport/http/builder.rb#49
  def default_adapter; end

  # Returns the value of attribute default_api.
  #
  # source://ddtrace//lib/datadog/core/transport/http/builder.rb#49
  def default_api; end

  # @raise [UnknownApiError]
  #
  # source://ddtrace//lib/datadog/core/transport/http/builder.rb#111
  def default_api=(key); end

  # Returns the value of attribute default_headers.
  #
  # source://ddtrace//lib/datadog/core/transport/http/builder.rb#49
  def default_headers; end

  # source://ddtrace//lib/datadog/core/transport/http/builder.rb#88
  def headers(values = T.unsafe(nil)); end

  # @raise [NoApisError]
  #
  # source://ddtrace//lib/datadog/core/transport/http/builder.rb#123
  def to_api_instances; end

  # @raise [NoDefaultApiError]
  #
  # source://ddtrace//lib/datadog/core/transport/http/builder.rb#117
  def to_transport(klass); end
end

# Raised when an adapter cannot be resolved for an API instance.
#
# source://ddtrace//lib/datadog/core/transport/http/builder.rb#186
class Datadog::Core::Transport::HTTP::Builder::NoAdapterForApiError < ::StandardError
  # @return [NoAdapterForApiError] a new instance of NoAdapterForApiError
  #
  # source://ddtrace//lib/datadog/core/transport/http/builder.rb#189
  def initialize(key); end

  # Returns the value of attribute key.
  #
  # source://ddtrace//lib/datadog/core/transport/http/builder.rb#187
  def key; end

  # source://ddtrace//lib/datadog/core/transport/http/builder.rb#195
  def message; end
end

# Raised when built without defining APIs.
#
# source://ddtrace//lib/datadog/core/transport/http/builder.rb#201
class Datadog::Core::Transport::HTTP::Builder::NoApisError < ::StandardError
  # source://ddtrace//lib/datadog/core/transport/http/builder.rb#202
  def message; end
end

# Raised when client built without defining a default API.
#
# source://ddtrace//lib/datadog/core/transport/http/builder.rb#208
class Datadog::Core::Transport::HTTP::Builder::NoDefaultApiError < ::StandardError
  # source://ddtrace//lib/datadog/core/transport/http/builder.rb#209
  def message; end
end

# source://ddtrace//lib/datadog/core/transport/http/builder.rb#47
Datadog::Core::Transport::HTTP::Builder::REGISTRY = T.let(T.unsafe(nil), Datadog::Transport::HTTP::Adapters::Registry)

# Raised when the identifier cannot be matched to an adapter.
#
# source://ddtrace//lib/datadog/core/transport/http/builder.rb#171
class Datadog::Core::Transport::HTTP::Builder::UnknownAdapterError < ::StandardError
  # @return [UnknownAdapterError] a new instance of UnknownAdapterError
  #
  # source://ddtrace//lib/datadog/core/transport/http/builder.rb#174
  def initialize(type); end

  # source://ddtrace//lib/datadog/core/transport/http/builder.rb#180
  def message; end

  # Returns the value of attribute type.
  #
  # source://ddtrace//lib/datadog/core/transport/http/builder.rb#172
  def type; end
end

# Raised when the API key does not match known APIs.
#
# source://ddtrace//lib/datadog/core/transport/http/builder.rb#156
class Datadog::Core::Transport::HTTP::Builder::UnknownApiError < ::StandardError
  # @return [UnknownApiError] a new instance of UnknownApiError
  #
  # source://ddtrace//lib/datadog/core/transport/http/builder.rb#159
  def initialize(key); end

  # Returns the value of attribute key.
  #
  # source://ddtrace//lib/datadog/core/transport/http/builder.rb#157
  def key; end

  # source://ddtrace//lib/datadog/core/transport/http/builder.rb#165
  def message; end
end

# Routes, encodes, and sends tracer data to the trace agent via HTTP.
#
# source://ddtrace//lib/datadog/core/transport/http/client.rb#15
class Datadog::Core::Transport::HTTP::Client
  include ::Datadog::Core::Transport::HTTP::Negotiation::Client
  include ::Datadog::Core::Transport::HTTP::Config::Client

  # @return [Client] a new instance of Client
  #
  # source://ddtrace//lib/datadog/core/transport/http/client.rb#18
  def initialize(api); end

  # Returns the value of attribute api.
  #
  # source://ddtrace//lib/datadog/core/transport/http/client.rb#16
  def api; end

  # source://ddtrace//lib/datadog/core/transport/http/client.rb#38
  def build_env(request); end

  # source://ddtrace//lib/datadog/core/transport/http/client.rb#22
  def send_request(request, &block); end
end

# HTTP transport behavior for remote configuration
#
# source://ddtrace//lib/datadog/core/transport/http/config.rb#32
module Datadog::Core::Transport::HTTP::Config; end

# source://ddtrace//lib/datadog/core/transport/http/config.rb#185
module Datadog::Core::Transport::HTTP::Config::API; end

# Endpoint for remote configuration
#
# source://ddtrace//lib/datadog/core/transport/http/config.rb#243
class Datadog::Core::Transport::HTTP::Config::API::Endpoint < ::Datadog::Transport::HTTP::API::Endpoint
  # @return [Endpoint] a new instance of Endpoint
  #
  # source://ddtrace//lib/datadog/core/transport/http/config.rb#248
  def initialize(path, encoder); end

  # source://ddtrace//lib/datadog/core/transport/http/config.rb#253
  def call(env, &block); end

  # Returns the value of attribute encoder.
  #
  # source://ddtrace//lib/datadog/core/transport/http/config.rb#246
  def encoder; end
end

# source://ddtrace//lib/datadog/core/transport/http/config.rb#244
Datadog::Core::Transport::HTTP::Config::API::Endpoint::HEADER_CONTENT_TYPE = T.let(T.unsafe(nil), String)

# Extensions for HTTP API Instance
#
# source://ddtrace//lib/datadog/core/transport/http/config.rb#217
module Datadog::Core::Transport::HTTP::Config::API::Instance
  # @raise [ConfigNotSupportedError]
  #
  # source://ddtrace//lib/datadog/core/transport/http/config.rb#218
  def send_config(env); end
end

# Raised when traces sent to API that does not support traces
#
# source://ddtrace//lib/datadog/core/transport/http/config.rb#227
class Datadog::Core::Transport::HTTP::Config::API::Instance::ConfigNotSupportedError < ::StandardError
  # @return [ConfigNotSupportedError] a new instance of ConfigNotSupportedError
  #
  # source://ddtrace//lib/datadog/core/transport/http/config.rb#230
  def initialize(spec); end

  # source://ddtrace//lib/datadog/core/transport/http/config.rb#236
  def message; end

  # Returns the value of attribute spec.
  #
  # source://ddtrace//lib/datadog/core/transport/http/config.rb#228
  def spec; end
end

# Extensions for HTTP API Spec
#
# source://ddtrace//lib/datadog/core/transport/http/config.rb#187
module Datadog::Core::Transport::HTTP::Config::API::Spec
  # Returns the value of attribute config.
  #
  # source://ddtrace//lib/datadog/core/transport/http/config.rb#188
  def config; end

  # source://ddtrace//lib/datadog/core/transport/http/config.rb#190
  def config=(endpoint); end

  # @raise [NoConfigEndpointDefinedError]
  #
  # source://ddtrace//lib/datadog/core/transport/http/config.rb#194
  def send_config(env, &block); end
end

# Raised when traces sent but no traces endpoint is defined
#
# source://ddtrace//lib/datadog/core/transport/http/config.rb#201
class Datadog::Core::Transport::HTTP::Config::API::Spec::NoConfigEndpointDefinedError < ::StandardError
  # @return [NoConfigEndpointDefinedError] a new instance of NoConfigEndpointDefinedError
  #
  # source://ddtrace//lib/datadog/core/transport/http/config.rb#204
  def initialize(spec); end

  # source://ddtrace//lib/datadog/core/transport/http/config.rb#210
  def message; end

  # Returns the value of attribute spec.
  #
  # source://ddtrace//lib/datadog/core/transport/http/config.rb#202
  def spec; end
end

# Extensions for HTTP client
#
# source://ddtrace//lib/datadog/core/transport/http/config.rb#177
module Datadog::Core::Transport::HTTP::Config::Client
  # source://ddtrace//lib/datadog/core/transport/http/config.rb#178
  def send_config_payload(request); end
end

# Response from HTTP transport for remote configuration
#
# source://ddtrace//lib/datadog/core/transport/http/config.rb#34
class Datadog::Core::Transport::HTTP::Config::Response
  include ::Datadog::Transport::HTTP::Response
  include ::Datadog::Core::Transport::Config::Response

  # @raise [TypeError]
  # @return [Response] a new instance of Response
  #
  # source://ddtrace//lib/datadog/core/transport/http/config.rb#38
  def initialize(http_response, options = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/core/transport/http/config.rb#129
  def inspect; end
end

# When value decoding fails
#
# source://ddtrace//lib/datadog/core/transport/http/config.rb#158
class Datadog::Core::Transport::HTTP::Config::Response::DecodeError < ::StandardError
  # @return [DecodeError] a new instance of DecodeError
  #
  # source://ddtrace//lib/datadog/core/transport/http/config.rb#159
  def initialize(key, value); end
end

# When an expected key is missing
#
# source://ddtrace//lib/datadog/core/transport/http/config.rb#140
class Datadog::Core::Transport::HTTP::Config::Response::KeyError < ::StandardError
  # @return [KeyError] a new instance of KeyError
  #
  # source://ddtrace//lib/datadog/core/transport/http/config.rb#141
  def initialize(key); end
end

# When value parsing fails
#
# source://ddtrace//lib/datadog/core/transport/http/config.rb#167
class Datadog::Core::Transport::HTTP::Config::Response::ParseError < ::StandardError
  # @return [ParseError] a new instance of ParseError
  #
  # source://ddtrace//lib/datadog/core/transport/http/config.rb#168
  def initialize(key, value); end
end

# When an expected value type is incorrect
#
# source://ddtrace//lib/datadog/core/transport/http/config.rb#149
class Datadog::Core::Transport::HTTP::Config::Response::TypeError < ::StandardError
  # @return [TypeError] a new instance of TypeError
  #
  # source://ddtrace//lib/datadog/core/transport/http/config.rb#150
  def initialize(type, value); end
end

# NOTE: Due to... legacy reasons... This class likes having a default `AgentSettings` instance to fall back to.
# Because we generate this instance with an empty instance of `Settings`, the resulting `AgentSettings` below
# represents only settings specified via environment variables + the usual defaults.
#
# DO NOT USE THIS IN NEW CODE, as it ignores any settings specified by users via `Datadog.configure`.
#
# source://ddtrace//lib/datadog/core/transport/http.rb#46
Datadog::Core::Transport::HTTP::DO_NOT_USE_ENVIRONMENT_AGENT_SETTINGS = T.let(T.unsafe(nil), Datadog::Core::Configuration::AgentSettingsResolver::AgentSettings)

# HTTP transport behavior for agent feature negotiation
#
# source://ddtrace//lib/datadog/core/transport/http/negotiation.rb#31
module Datadog::Core::Transport::HTTP::Negotiation; end

# source://ddtrace//lib/datadog/core/transport/http/negotiation.rb#57
module Datadog::Core::Transport::HTTP::Negotiation::API; end

# Endpoint for negotiation
#
# source://ddtrace//lib/datadog/core/transport/http/negotiation.rb#115
class Datadog::Core::Transport::HTTP::Negotiation::API::Endpoint < ::Datadog::Transport::HTTP::API::Endpoint
  # @return [Endpoint] a new instance of Endpoint
  #
  # source://ddtrace//lib/datadog/core/transport/http/negotiation.rb#116
  def initialize(path); end

  # source://ddtrace//lib/datadog/core/transport/http/negotiation.rb#120
  def call(env, &block); end
end

# Extensions for HTTP API Instance
#
# source://ddtrace//lib/datadog/core/transport/http/negotiation.rb#89
module Datadog::Core::Transport::HTTP::Negotiation::API::Instance
  # @raise [NegotiationNotSupportedError]
  #
  # source://ddtrace//lib/datadog/core/transport/http/negotiation.rb#90
  def send_info(env); end
end

# Raised when traces sent to API that does not support traces
#
# source://ddtrace//lib/datadog/core/transport/http/negotiation.rb#99
class Datadog::Core::Transport::HTTP::Negotiation::API::Instance::NegotiationNotSupportedError < ::StandardError
  # @return [NegotiationNotSupportedError] a new instance of NegotiationNotSupportedError
  #
  # source://ddtrace//lib/datadog/core/transport/http/negotiation.rb#102
  def initialize(spec); end

  # source://ddtrace//lib/datadog/core/transport/http/negotiation.rb#108
  def message; end

  # Returns the value of attribute spec.
  #
  # source://ddtrace//lib/datadog/core/transport/http/negotiation.rb#100
  def spec; end
end

# Extensions for HTTP API Spec
#
# source://ddtrace//lib/datadog/core/transport/http/negotiation.rb#59
module Datadog::Core::Transport::HTTP::Negotiation::API::Spec
  # Returns the value of attribute info.
  #
  # source://ddtrace//lib/datadog/core/transport/http/negotiation.rb#60
  def info; end

  # source://ddtrace//lib/datadog/core/transport/http/negotiation.rb#62
  def info=(endpoint); end

  # @raise [NoNegotiationEndpointDefinedError]
  #
  # source://ddtrace//lib/datadog/core/transport/http/negotiation.rb#66
  def send_info(env, &block); end
end

# Raised when traces sent but no traces endpoint is defined
#
# source://ddtrace//lib/datadog/core/transport/http/negotiation.rb#73
class Datadog::Core::Transport::HTTP::Negotiation::API::Spec::NoNegotiationEndpointDefinedError < ::StandardError
  # @return [NoNegotiationEndpointDefinedError] a new instance of NoNegotiationEndpointDefinedError
  #
  # source://ddtrace//lib/datadog/core/transport/http/negotiation.rb#76
  def initialize(spec); end

  # source://ddtrace//lib/datadog/core/transport/http/negotiation.rb#82
  def message; end

  # Returns the value of attribute spec.
  #
  # source://ddtrace//lib/datadog/core/transport/http/negotiation.rb#74
  def spec; end
end

# Extensions for HTTP client
#
# source://ddtrace//lib/datadog/core/transport/http/negotiation.rb#49
module Datadog::Core::Transport::HTTP::Negotiation::Client
  # source://ddtrace//lib/datadog/core/transport/http/negotiation.rb#50
  def send_info_payload(request); end
end

# Response from HTTP transport for agent feature negotiation
#
# source://ddtrace//lib/datadog/core/transport/http/negotiation.rb#33
class Datadog::Core::Transport::HTTP::Negotiation::Response
  include ::Datadog::Transport::HTTP::Response
  include ::Datadog::Core::Transport::Negotiation::Response

  # @return [Response] a new instance of Response
  #
  # source://ddtrace//lib/datadog/core/transport/http/negotiation.rb#37
  def initialize(http_response, options = T.unsafe(nil)); end
end

# source://ddtrace//lib/datadog/core/transport/negotiation.rb#27
module Datadog::Core::Transport::Negotiation; end

# Negotiation request
#
# source://ddtrace//lib/datadog/core/transport/negotiation.rb#29
class Datadog::Core::Transport::Negotiation::Request < ::Datadog::Transport::Request; end

# Negotiation response
#
# source://ddtrace//lib/datadog/core/transport/negotiation.rb#33
module Datadog::Core::Transport::Negotiation::Response
  # Returns the value of attribute config.
  #
  # source://ddtrace//lib/datadog/core/transport/negotiation.rb#34
  def config; end

  # Returns the value of attribute endpoints.
  #
  # source://ddtrace//lib/datadog/core/transport/negotiation.rb#34
  def endpoints; end

  # Returns the value of attribute version.
  #
  # source://ddtrace//lib/datadog/core/transport/negotiation.rb#34
  def version; end
end

# Negotiation transport
#
# source://ddtrace//lib/datadog/core/transport/negotiation.rb#38
class Datadog::Core::Transport::Negotiation::Transport
  # @return [Transport] a new instance of Transport
  #
  # source://ddtrace//lib/datadog/core/transport/negotiation.rb#41
  def initialize(apis, default_api); end

  # Returns the value of attribute apis.
  #
  # source://ddtrace//lib/datadog/core/transport/negotiation.rb#39
  def apis; end

  # Returns the value of attribute client.
  #
  # source://ddtrace//lib/datadog/core/transport/negotiation.rb#39
  def client; end

  # source://ddtrace//lib/datadog/core/transport/negotiation.rb#53
  def current_api; end

  # Returns the value of attribute current_api_id.
  #
  # source://ddtrace//lib/datadog/core/transport/negotiation.rb#39
  def current_api_id; end

  # Returns the value of attribute default_api.
  #
  # source://ddtrace//lib/datadog/core/transport/negotiation.rb#39
  def default_api; end

  # source://ddtrace//lib/datadog/core/transport/negotiation.rb#47
  def send_info; end
end

# Utils contains low-level utilities, typically to provide pseudo-random trace IDs.
#
# source://ddtrace//lib/datadog/core/utils/safe_dup.rb#5
module Datadog::Core::Utils
  extend ::Datadog::Core::Utils::Forking

  class << self
    # Extracts hostname and port from
    # a string that contains both, separated by ':'.
    #
    # @return [String, Integer] hostname and port
    # @return [nil] if format did not match
    #
    # source://ddtrace//lib/datadog/core/utils.rb#84
    def extract_host_port(host_port); end

    # Stringifies `value` and ensures the outcome is
    # string is no longer than `size`.
    # `omission` replaces the end of the output if
    # `value.to_s` does not fit in `size`, to signify
    # truncation.
    #
    # If `omission.size` is larger than `size`, the output
    # will still be `omission.size` in length.
    #
    # source://ddtrace//lib/datadog/core/utils.rb#21
    def truncate(value, size, omission = T.unsafe(nil)); end

    # Ensure `str` is a valid UTF-8, ready to be
    # sent through the tracer transport.
    #
    # @param str [String, #to_s] object to be converted to a UTF-8 string
    # @param binary [Boolean] whether to expect binary data in the `str` parameter
    # @param placeholder [String] string to be returned when encoding fails
    # @return a UTF-8 string version of `str`
    #
    # source://ddtrace//lib/datadog/core/utils.rb#45
    def utf8_encode(str, binary: T.unsafe(nil), placeholder: T.unsafe(nil)); end

    # source://ddtrace//lib/datadog/core/utils.rb#68
    def without_warnings; end
  end
end

# Helper methods for parsing string values into Numeric
#
# source://ddtrace//lib/datadog/core/utils/duration.rb#7
module Datadog::Core::Utils::Duration
  class << self
    # source://ddtrace//lib/datadog/core/utils/duration.rb#8
    def call(value, base: T.unsafe(nil)); end
  end
end

# source://ddtrace//lib/datadog/core/utils.rb#10
Datadog::Core::Utils::EMPTY_STRING = T.let(T.unsafe(nil), String)

# Helper methods for managing forking behavior
#
# source://ddtrace//lib/datadog/core/utils/forking.rb#5
module Datadog::Core::Utils::Forking
  # source://ddtrace//lib/datadog/core/utils/forking.rb#18
  def after_fork!; end

  # source://ddtrace//lib/datadog/core/utils/forking.rb#36
  def fork_pid; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/utils/forking.rb#28
  def forked?; end

  # source://ddtrace//lib/datadog/core/utils/forking.rb#32
  def update_fork_pid!; end

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/core/utils/forking.rb#10
    def extended(base); end

    # @private
    #
    # source://ddtrace//lib/datadog/core/utils/forking.rb#6
    def included(base); end
  end
end

# Adds additional functionality for Classes that implement Forking
#
# source://ddtrace//lib/datadog/core/utils/forking.rb#41
module Datadog::Core::Utils::Forking::ClassExtensions
  # source://ddtrace//lib/datadog/core/utils/forking.rb#47
  def initialize(*args, **kwargs, &block); end
end

# Refinements for {Hash}.
#
# source://ddtrace//lib/datadog/core/utils/hash.rb#7
module Datadog::Core::Utils::Hash; end

# A minimal {Hash} wrapper that provides case-insensitive access
# to hash keys, without the overhead of copying the original hash.
#
# This class should be used when the original hash is short lived *and*
# each hash key is only accesses a few times.
# For other cases, create a copy of the original hash with the keys
# normalized adequate to your use case.
#
# source://ddtrace//lib/datadog/core/utils/hash.rb#37
class Datadog::Core::Utils::Hash::CaseInsensitiveWrapper
  # @raise [ArgumentError]
  # @return [CaseInsensitiveWrapper] a new instance of CaseInsensitiveWrapper
  #
  # source://ddtrace//lib/datadog/core/utils/hash.rb#38
  def initialize(hash); end

  # source://ddtrace//lib/datadog/core/utils/hash.rb#44
  def [](key); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/utils/hash.rb#64
  def empty?; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/utils/hash.rb#54
  def key?(key); end

  # source://ddtrace//lib/datadog/core/utils/hash.rb#68
  def length; end

  # source://ddtrace//lib/datadog/core/utils/hash.rb#72
  def original_hash; end
end

# This refinement ensures modern rubies are allowed to use newer,
# simpler, and more performant APIs.
#
# source://ddtrace//lib/datadog/core/utils/hash.rb#10
module Datadog::Core::Utils::Hash::Refinement; end

# Common Network utility functions.
#
# source://ddtrace//lib/datadog/core/utils/network.rb#10
module Datadog::Core::Utils::Network
  class << self
    # @param IP [String] value.
    # @return [String] IP value without the port and the zone indentifier.
    # @return [nil] when no valid IP value found.
    #
    # source://ddtrace//lib/datadog/core/utils/network.rb#42
    def stripped_ip(ip); end

    # Returns a client IP associated with the request if it was
    #   retrieved successfully.
    #
    # @param headers [Datadog::Core::HeaderCollection, #get, nil] The request headers
    # @param list [Array<String>] of headers to check.
    # @return [String] IP value without the port and the zone indentifier.
    # @return [nil] when no valid IP value found.
    #
    # source://ddtrace//lib/datadog/core/utils/network.rb#33
    def stripped_ip_from_request_headers(headers, ip_headers_to_check: T.unsafe(nil)); end

    private

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/core/utils/network.rb#115
    def global_ip?(parsed_ip); end

    # source://ddtrace//lib/datadog/core/utils/network.rb#68
    def ip_header(headers, ip_headers_to_check); end

    # @param IP [String] value.
    # @return [IPaddr]
    # @return [nil] when no valid IP value found.
    #
    # source://ddtrace//lib/datadog/core/utils/network.rb#52
    def ip_to_ipaddr(ip); end

    # Returns whether the given value is more likely to be an IPv4 than an IPv6 address.
    #
    # This is done by checking if a dot (`'.'`) character appears before a colon (`':'`) in the value.
    # The rationale is that in valid IPv6 addresses, colons will always preced dots,
    #   and in valid IPv4 addresses dots will always preced colons.
    #
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/core/utils/network.rb#92
    def likely_ipv4?(value); end

    # TODO: remove once we drop support for ruby 2.1, 2.2, 2.3, 2.4
    # replace with ip.link_local?
    #
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/core/utils/network.rb#127
    def link_local?(ip); end

    # TODO: remove once we drop support for ruby 2.1, 2.2, 2.3, 2.4
    # replace with ip.loopback
    #
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/core/utils/network.rb#133
    def loopback?(ip); end

    # TODO: remove once we drop support for ruby 2.1, 2.2, 2.3, 2.4
    # replace with ip.private?
    #
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/core/utils/network.rb#121
    def private?(ip); end

    # source://ddtrace//lib/datadog/core/utils/network.rb#111
    def strip_ipv4_port(ip); end

    # source://ddtrace//lib/datadog/core/utils/network.rb#103
    def strip_ipv6_port(ip); end

    # source://ddtrace//lib/datadog/core/utils/network.rb#99
    def strip_zone_specifier(ipv6); end
  end
end

# source://ddtrace//lib/datadog/core/utils/network.rb#11
Datadog::Core::Utils::Network::DEFAULT_IP_HEADERS_NAMES = T.let(T.unsafe(nil), Array)

# Helper class to execute something only once such as not repeating warning logs, and instrumenting classes
# only once.
#
# Thread-safe when used correctly (e.g. be careful of races when lazily initializing instances of this class).
#
# Note: In its current state, this class is not Ractor-safe.
# In https://github.com/DataDog/dd-trace-rb/pull/1398#issuecomment-797378810 we have a discussion of alternatives,
# including an alternative implementation that is Ractor-safe once spent.
#
# source://ddtrace//lib/datadog/core/utils/only_once.rb#14
class Datadog::Core::Utils::OnlyOnce
  # @return [OnlyOnce] a new instance of OnlyOnce
  #
  # source://ddtrace//lib/datadog/core/utils/only_once.rb#15
  def initialize; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/utils/only_once.rb#30
  def ran?; end

  # source://ddtrace//lib/datadog/core/utils/only_once.rb#20
  def run; end

  private

  # source://ddtrace//lib/datadog/core/utils/only_once.rb#36
  def reset_ran_once_state_for_tests; end
end

# Helper methods for safer dup
#
# source://ddtrace//lib/datadog/core/utils/safe_dup.rb#7
module Datadog::Core::Utils::SafeDup
  class << self
    # source://ddtrace//lib/datadog/core/utils/safe_dup.rb#26
    def frozen_dup(v); end

    # source://ddtrace//lib/datadog/core/utils/safe_dup.rb#10
    def frozen_or_dup(v); end
  end
end

# Generates values from a consistent sequence
#
# source://ddtrace//lib/datadog/core/utils/sequence.rb#7
class Datadog::Core::Utils::Sequence
  # @return [Sequence] a new instance of Sequence
  #
  # source://ddtrace//lib/datadog/core/utils/sequence.rb#8
  def initialize(seed = T.unsafe(nil), &block); end

  # source://ddtrace//lib/datadog/core/utils/sequence.rb#14
  def next; end

  # source://ddtrace//lib/datadog/core/utils/sequence.rb#20
  def reset!; end
end

# Common database-related utility functions.
#
# source://ddtrace//lib/datadog/core/utils/time.rb#7
module Datadog::Core::Utils::Time
  private

  # source://ddtrace//lib/datadog/core/utils/time.rb#44
  def as_utc_epoch_ns(time); end

  # Current monotonic time
  #
  # @param unit [Symbol] unit for the resulting value, same as ::Process#clock_gettime, defaults to :float_second
  # @return [Numeric] timestamp in the requested unit, since some unspecified starting point
  #
  # source://ddtrace//lib/datadog/core/utils/time.rb#14
  def get_time(unit = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/core/utils/time.rb#37
  def measure(unit = T.unsafe(nil)); end

  # Current wall time.
  #
  # @return [Time] current time object
  #
  # source://ddtrace//lib/datadog/core/utils/time.rb#21
  def now; end

  # Overrides the implementation of `#now
  # with the provided callable.
  #
  # Overriding the method `#now` instead of
  # indirectly calling `block` removes
  # one level of method call overhead.
  #
  # @param block [Proc] block that returns a `Time` object representing the current wall time
  #
  # source://ddtrace//lib/datadog/core/utils/time.rb#33
  def now_provider=(block); end

  class << self
    # source://ddtrace//lib/datadog/core/utils/time.rb#44
    def as_utc_epoch_ns(time); end

    # Current monotonic time
    #
    # @param unit [Symbol] unit for the resulting value, same as ::Process#clock_gettime, defaults to :float_second
    # @return [Numeric] timestamp in the requested unit, since some unspecified starting point
    #
    # source://ddtrace//lib/datadog/core/utils/time.rb#14
    def get_time(unit = T.unsafe(nil)); end

    # source://ddtrace//lib/datadog/core/utils/time.rb#37
    def measure(unit = T.unsafe(nil)); end

    # Current wall time.
    #
    # @return [Time] current time object
    #
    # source://ddtrace//lib/datadog/core/utils/time.rb#21
    def now; end

    # Overrides the implementation of `#now
    # with the provided callable.
    #
    # Overriding the method `#now` instead of
    # indirectly calling `block` removes
    # one level of method call overhead.
    #
    # @param block [Proc] block that returns a `Time` object representing the current wall time
    #
    # source://ddtrace//lib/datadog/core/utils/time.rb#33
    def now_provider=(block); end
  end
end

# source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#9
module Datadog::Core::Vendor; end

# vendor code from https://github.com/ruby/ipaddr/blob/master/lib/ipaddr.rb
# Ruby version below 2.5 does not have the IpAddr#private? method
# We have to vendor the code because ruby versions below 2.5 did not extract ipaddr as a gem
# So we can not specify a specific version for ipaddr for ruby versions: 2.1, 2.2, 2.3, 2.4
#
# source://ddtrace//lib/datadog/core/vendor/ipaddr.rb#32
module Datadog::Core::Vendor::IPAddr
  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/core/vendor/ipaddr.rb#49
    def link_local?(ip); end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/core/vendor/ipaddr.rb#62
    def loopback?(ip); end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/core/vendor/ipaddr.rb#34
    def private?(ip); end
  end
end

# source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#10
module Datadog::Core::Vendor::Multipart; end

# source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#11
module Datadog::Core::Vendor::Multipart::Post; end

# source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#20
class Datadog::Core::Vendor::Multipart::Post::CompositeReadIO
  # Create a new composite-read IO from the arguments, all of which should
  # respond to #read in a manner consistent with IO.
  #
  # @return [CompositeReadIO] a new instance of CompositeReadIO
  #
  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#23
  def initialize(*ios); end

  # Read from IOs in order until `length` bytes have been received.
  #
  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#29
  def read(length = T.unsafe(nil), outbuf = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#46
  def rewind; end

  private

  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#57
  def advance_io; end

  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#53
  def current_io; end
end

# source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/multipartable.rb#16
module Datadog::Core::Vendor::Multipart::Post::Multipartable
  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/multipartable.rb#31
  def initialize(path, params, headers = T.unsafe(nil), boundary = T.unsafe(nil)); end

  # Returns the value of attribute boundary.
  #
  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/multipartable.rb#53
  def boundary; end

  class << self
    # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/multipartable.rb#17
    def secure_boundary; end
  end
end

# source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#12
module Datadog::Core::Vendor::Multipart::Post::Parts; end

# Represents the epilogue or closing boundary.
#
# source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#124
class Datadog::Core::Vendor::Multipart::Post::Parts::EpiloguePart
  include ::Datadog::Core::Vendor::Multipart::Post::Parts::Part

  # @return [EpiloguePart] a new instance of EpiloguePart
  #
  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#127
  def initialize(boundary); end
end

# Represents a part to be filled from file IO.
#
# source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#69
class Datadog::Core::Vendor::Multipart::Post::Parts::FilePart
  include ::Datadog::Core::Vendor::Multipart::Post::Parts::Part

  # @param boundary [String]
  # @param name [#to_s]
  # @param io [IO]
  # @param headers [Hash]
  # @return [FilePart] a new instance of FilePart
  #
  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#78
  def initialize(boundary, name, io, headers = T.unsafe(nil)); end

  # @param boundary [String]
  # @param name [#to_s]
  # @param filename [String]
  # @param type [String]
  # @param content_len [Integer]
  # @param opts [Hash]
  #
  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#93
  def build_head(boundary, name, filename, type, content_len, opts = T.unsafe(nil)); end

  # Returns the value of attribute length.
  #
  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#72
  def length; end
end

# Represents a parametric part to be filled with given value.
#
# source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#37
class Datadog::Core::Vendor::Multipart::Post::Parts::ParamPart
  include ::Datadog::Core::Vendor::Multipart::Post::Parts::Part

  # @param boundary [String]
  # @param name [#to_s]
  # @param value [String]
  # @param headers [Hash] Content-Type and Content-ID are used, if present.
  # @return [ParamPart] a new instance of ParamPart
  #
  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#44
  def initialize(boundary, name, value, headers = T.unsafe(nil)); end

  # @param boundary [String]
  # @param name [#to_s]
  # @param value [String]
  # @param headers [Hash] Content-Type is used, if present.
  #
  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#57
  def build_part(boundary, name, value, headers = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#49
  def length; end
end

# source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#13
module Datadog::Core::Vendor::Multipart::Post::Parts::Part
  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#27
  def length; end

  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#31
  def to_io; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#23
    def file?(value); end

    # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/parts.rb#14
    def new(boundary, name, value, headers = T.unsafe(nil)); end
  end
end

# Convenience methods for dealing with files and IO that are to be uploaded.
#
# source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#63
class Datadog::Core::Vendor::Multipart::Post::UploadIO
  # Create an upload IO suitable for including in the params hash of a
  # Net::HTTP::Post::Multipart.
  #
  # Can take two forms. The first accepts a filename and content type, and
  # opens the file for reading (to be closed by finalizer).
  #
  # The second accepts an already-open IO, but also requires a third argument,
  # the filename from which it was opened (particularly useful/recommended if
  # uploading directly from a form in a framework, which often save the file to
  # an arbitrarily named RackMultipart file in /tmp).
  #
  # @example
  #   UploadIO.new("file.txt", "text/plain")
  #   UploadIO.new(file_io, "text/plain", "file.txt")
  # @return [UploadIO] a new instance of UploadIO
  #
  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#80
  def initialize(filename_or_io, content_type, filename = T.unsafe(nil), opts = T.unsafe(nil)); end

  # Returns the value of attribute content_type.
  #
  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#64
  def content_type; end

  # Returns the value of attribute io.
  #
  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#64
  def io; end

  # Returns the value of attribute local_path.
  #
  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#64
  def local_path; end

  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#106
  def method_missing(*args); end

  # Returns the value of attribute opts.
  #
  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#64
  def opts; end

  # Returns the value of attribute original_filename.
  #
  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#64
  def original_filename; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#110
  def respond_to?(meth, include_all = T.unsafe(nil)); end

  class << self
    # @raise [ArgumentError]
    #
    # source://ddtrace//lib/datadog/core/vendor/multipart-post/multipart/post/composite_read_io.rb#100
    def convert!(io, content_type, original_filename, local_path); end
  end
end

# source://ddtrace//lib/datadog/core/vendor/multipart-post/net/http/post/multipart.rb#17
module Datadog::Core::Vendor::Net; end

# source://ddtrace//lib/datadog/core/vendor/multipart-post/net/http/post/multipart.rb#18
class Datadog::Core::Vendor::Net::HTTP; end

# source://ddtrace//lib/datadog/core/vendor/multipart-post/net/http/post/multipart.rb#25
class Datadog::Core::Vendor::Net::HTTP::Post; end

# source://ddtrace//lib/datadog/core/vendor/multipart-post/net/http/post/multipart.rb#26
class Datadog::Core::Vendor::Net::HTTP::Post::Multipart < ::Net::HTTP::Post
  include ::Datadog::Core::Vendor::Multipart::Post::Multipartable
end

# source://ddtrace//lib/datadog/core/vendor/multipart-post/net/http/post/multipart.rb#19
class Datadog::Core::Vendor::Net::HTTP::Put; end

# source://ddtrace//lib/datadog/core/vendor/multipart-post/net/http/post/multipart.rb#20
class Datadog::Core::Vendor::Net::HTTP::Put::Multipart < ::Net::HTTP::Put
  include ::Datadog::Core::Vendor::Multipart::Post::Multipartable
end

# Base class for work tasks
#
# source://ddtrace//lib/datadog/core/worker.rb#6
class Datadog::Core::Worker
  # @return [Worker] a new instance of Worker
  #
  # source://ddtrace//lib/datadog/core/worker.rb#10
  def initialize(&block); end

  # source://ddtrace//lib/datadog/core/worker.rb#14
  def perform(*args); end

  # Returns the value of attribute task.
  #
  # source://ddtrace//lib/datadog/core/worker.rb#7
  def task; end

  protected

  # Sets the attribute task
  #
  # @param value the value to set the attribute task to.
  #
  # source://ddtrace//lib/datadog/core/worker.rb#20
  def task=(_arg0); end
end

# source://ddtrace//lib/datadog/core/workers/async.rb#5
module Datadog::Core::Workers; end

# source://ddtrace//lib/datadog/core/workers/async.rb#6
module Datadog::Core::Workers::Async; end

# Adds threading behavior to workers
# to run tasks asynchronously.
#
# source://ddtrace//lib/datadog/core/workers/async.rb#9
module Datadog::Core::Workers::Async::Thread
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/workers/async.rb#71
  def completed?; end

  # Returns the value of attribute error.
  #
  # source://ddtrace//lib/datadog/core/workers/async.rb#29
  def error; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/workers/async.rb#65
  def error?; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/workers/async.rb#75
  def failed?; end

  # source://ddtrace//lib/datadog/core/workers/async.rb#83
  def fork_policy; end

  # Sets the attribute fork_policy
  #
  # @param value the value to set the attribute fork_policy to.
  #
  # source://ddtrace//lib/datadog/core/workers/async.rb#33
  def fork_policy=(_arg0); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/workers/async.rb#79
  def forked?; end

  # source://ddtrace//lib/datadog/core/workers/async.rb#36
  def join(timeout = T.unsafe(nil)); end

  # Returns the value of attribute result.
  #
  # source://ddtrace//lib/datadog/core/workers/async.rb#29
  def result; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/workers/async.rb#51
  def run_async?; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/workers/async.rb#61
  def running?; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/workers/async.rb#57
  def started?; end

  # source://ddtrace//lib/datadog/core/workers/async.rb#42
  def terminate; end

  protected

  # source://ddtrace//lib/datadog/core/workers/async.rb#96
  def after_fork; end

  # source://ddtrace//lib/datadog/core/workers/async.rb#92
  def mutex; end

  # Sets the attribute result
  #
  # @param value the value to set the attribute result to.
  #
  # source://ddtrace//lib/datadog/core/workers/async.rb#89
  def result=(_arg0); end

  private

  # source://ddtrace//lib/datadog/core/workers/async.rb#105
  def mutex_after_fork; end

  # Returns the value of attribute pid.
  #
  # source://ddtrace//lib/datadog/core/workers/async.rb#102
  def pid; end

  # source://ddtrace//lib/datadog/core/workers/async.rb#167
  def restart_after_fork(&block); end

  # source://ddtrace//lib/datadog/core/workers/async.rb#113
  def start_async(&block); end

  # source://ddtrace//lib/datadog/core/workers/async.rb#130
  def start_worker; end

  # source://ddtrace//lib/datadog/core/workers/async.rb#154
  def stop_fork; end

  # source://ddtrace//lib/datadog/core/workers/async.rb#109
  def worker; end

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/core/workers/async.rb#18
    def included(base); end
  end
end

# source://ddtrace//lib/datadog/core/workers/async.rb#11
Datadog::Core::Workers::Async::Thread::FORK_POLICY_RESTART = T.let(T.unsafe(nil), Symbol)

# source://ddtrace//lib/datadog/core/workers/async.rb#10
Datadog::Core::Workers::Async::Thread::FORK_POLICY_STOP = T.let(T.unsafe(nil), Symbol)

# This single shared mutex is used to avoid concurrency issues during the
# initialization of per-instance lazy-initialized mutexes.
#
# source://ddtrace//lib/datadog/core/workers/async.rb#16
Datadog::Core::Workers::Async::Thread::MUTEX_INIT = T.let(T.unsafe(nil), Thread::Mutex)

# Methods that must be prepended
#
# source://ddtrace//lib/datadog/core/workers/async.rb#23
module Datadog::Core::Workers::Async::Thread::PrependedMethods
  # source://ddtrace//lib/datadog/core/workers/async.rb#24
  def perform(*args); end
end

# source://ddtrace//lib/datadog/core/workers/async.rb#12
Datadog::Core::Workers::Async::Thread::SHUTDOWN_TIMEOUT = T.let(T.unsafe(nil), Integer)

# Adds looping behavior to workers, with a sleep
# interval between each loop.
#
# source://ddtrace//lib/datadog/core/workers/interval_loop.rb#8
module Datadog::Core::Workers::IntervalLoop
  # source://ddtrace//lib/datadog/core/workers/interval_loop.rb#69
  def loop_back_off!; end

  # source://ddtrace//lib/datadog/core/workers/interval_loop.rb#57
  def loop_back_off_max; end

  # source://ddtrace//lib/datadog/core/workers/interval_loop.rb#53
  def loop_back_off_ratio; end

  # source://ddtrace//lib/datadog/core/workers/interval_loop.rb#49
  def loop_base_interval; end

  # Should perform_loop just straight into work, or start by waiting?
  #
  # The use case is if we want to report some information (like profiles) from time to time, we may not want to
  # report empty/zero/some residual value immediately when the worker starts.
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/workers/interval_loop.rb#77
  def loop_wait_before_first_iteration?; end

  # source://ddtrace//lib/datadog/core/workers/interval_loop.rb#61
  def loop_wait_time; end

  # source://ddtrace//lib/datadog/core/workers/interval_loop.rb#65
  def loop_wait_time=(value); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/workers/interval_loop.rb#43
  def run_loop?; end

  # source://ddtrace//lib/datadog/core/workers/interval_loop.rb#28
  def stop_loop; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/workers/interval_loop.rb#39
  def work_pending?; end

  protected

  # Sets the attribute loop_back_off_max
  #
  # @param value the value to set the attribute loop_back_off_max to.
  #
  # source://ddtrace//lib/datadog/core/workers/interval_loop.rb#83
  def loop_back_off_max=(_arg0); end

  # Sets the attribute loop_back_off_ratio
  #
  # @param value the value to set the attribute loop_back_off_ratio to.
  #
  # source://ddtrace//lib/datadog/core/workers/interval_loop.rb#83
  def loop_back_off_ratio=(_arg0); end

  # Sets the attribute loop_base_interval
  #
  # @param value the value to set the attribute loop_base_interval to.
  #
  # source://ddtrace//lib/datadog/core/workers/interval_loop.rb#83
  def loop_base_interval=(_arg0); end

  # source://ddtrace//lib/datadog/core/workers/interval_loop.rb#88
  def mutex; end

  private

  # source://ddtrace//lib/datadog/core/workers/interval_loop.rb#94
  def perform_loop; end

  # source://ddtrace//lib/datadog/core/workers/interval_loop.rb#117
  def shutdown; end

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/core/workers/interval_loop.rb#17
    def included(base); end
  end
end

# source://ddtrace//lib/datadog/core/workers/interval_loop.rb#10
Datadog::Core::Workers::IntervalLoop::BACK_OFF_MAX = T.let(T.unsafe(nil), Integer)

# source://ddtrace//lib/datadog/core/workers/interval_loop.rb#9
Datadog::Core::Workers::IntervalLoop::BACK_OFF_RATIO = T.let(T.unsafe(nil), Float)

# source://ddtrace//lib/datadog/core/workers/interval_loop.rb#11
Datadog::Core::Workers::IntervalLoop::BASE_INTERVAL = T.let(T.unsafe(nil), Integer)

# This single shared mutex is used to avoid concurrency issues during the
# initialization of per-instance lazy-initialized mutexes.
#
# source://ddtrace//lib/datadog/core/workers/interval_loop.rb#15
Datadog::Core::Workers::IntervalLoop::MUTEX_INIT = T.let(T.unsafe(nil), Thread::Mutex)

# Methods that must be prepended
#
# source://ddtrace//lib/datadog/core/workers/interval_loop.rb#22
module Datadog::Core::Workers::IntervalLoop::PrependedMethods
  # source://ddtrace//lib/datadog/core/workers/interval_loop.rb#23
  def perform(*args); end
end

# Adds polling (async looping) behavior to workers
#
# source://ddtrace//lib/datadog/core/workers/polling.rb#8
module Datadog::Core::Workers::Polling
  include ::Datadog::Core::Workers::IntervalLoop
  include ::Datadog::Core::Workers::Async::Thread

  # Allow worker to be started
  #
  # source://ddtrace//lib/datadog/core/workers/polling.rb#50
  def enabled=(value); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/core/workers/polling.rb#43
  def enabled?; end

  # source://ddtrace//lib/datadog/core/workers/polling.rb#24
  def stop(force_stop = T.unsafe(nil), timeout = T.unsafe(nil)); end

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/core/workers/polling.rb#11
    def included(base); end
  end
end

# Methods that must be prepended
#
# source://ddtrace//lib/datadog/core/workers/polling.rb#18
module Datadog::Core::Workers::Polling::PrependedMethods
  # source://ddtrace//lib/datadog/core/workers/polling.rb#19
  def perform(*args); end
end

# source://ddtrace//lib/datadog/core/workers/polling.rb#9
Datadog::Core::Workers::Polling::SHUTDOWN_TIMEOUT = T.let(T.unsafe(nil), Integer)

# Emits runtime metrics asynchronously on a timed loop
#
# source://ddtrace//lib/datadog/core/workers/runtime_metrics.rb#13
class Datadog::Core::Workers::RuntimeMetrics < ::Datadog::Core::Worker
  include ::Datadog::Core::Workers::IntervalLoop::PrependedMethods
  include ::Datadog::Core::Workers::Async::Thread::PrependedMethods
  include ::Datadog::Core::Workers::Polling::PrependedMethods
  include ::Datadog::Core::Workers::Polling
  include ::Datadog::Core::Workers::IntervalLoop
  include ::Datadog::Core::Workers::Async::Thread

  # @return [RuntimeMetrics] a new instance of RuntimeMetrics
  #
  # source://ddtrace//lib/datadog/core/workers/runtime_metrics.rb#23
  def initialize(options = T.unsafe(nil)); end

  # Returns the value of attribute metrics.
  #
  # source://ddtrace//lib/datadog/core/workers/runtime_metrics.rb#20
  def metrics; end

  # source://ddtrace//lib/datadog/core/workers/polling.rb#19
  def perform(*args); end

  # source://ddtrace//lib/datadog/core/workers/runtime_metrics.rb#42
  def register_service(service); end

  # TODO: `close_metrics` is only needed because
  # Datadog::Core::Configuration::Components directly manipulates
  # the lifecycle of Runtime::Metrics.statsd instances.
  # This should be avoided, as it prevents this class from
  # ensuring correct resource decommission of its internal
  # dependencies.
  #
  # source://ddtrace//lib/datadog/core/workers/runtime_metrics.rb#53
  def stop(*args, close_metrics: T.unsafe(nil)); end
end

# source://ddtrace//lib/datadog/core/workers/runtime_metrics.rb#18
Datadog::Core::Workers::RuntimeMetrics::DEFAULT_BACK_OFF_MAX = T.let(T.unsafe(nil), Integer)

# In seconds
#
# source://ddtrace//lib/datadog/core/workers/runtime_metrics.rb#17
Datadog::Core::Workers::RuntimeMetrics::DEFAULT_FLUSH_INTERVAL = T.let(T.unsafe(nil), Integer)

# Datadog::Kit holds public-facing APIs for higher level user-facing
# features, these features not belonging to a specific product. Contrary to
# Datadog::Core, Kit depends on products.
#
# source://ddtrace//lib/datadog/kit/identity.rb#6
module Datadog::Kit; end

# Tracking identity via traces
#
# source://ddtrace//lib/datadog/kit/identity.rb#8
module Datadog::Kit::Identity
  class << self
    # Attach user information to the trace
    #
    #
    # @param trace [TraceOperation] Trace to attach data to. Defaults to
    #   active trace.
    # @param span [SpanOperation] Span to attach data to. Defaults to
    #   active span on trace. Note that this should be a service entry span.
    #   When AppSec is enabled, the expected span and trace are automatically
    #   used as defaults.
    # @param id [String] Mandatory. Username or client id extracted
    #   from the access token or Authorization header in the inbound request
    #   from outside the system.
    # @param email [String] Email of the authenticated user associated
    #   to the trace.
    # @param name [String] User-friendly name. To be displayed in the
    #   UI if set.
    # @param session_id [String] Session ID of the authenticated user.
    # @param role [String] Actual/assumed role the client is making
    #   the request under extracted from token or application security
    #   context.
    # @param scope [String] Scopes or granted authorities the client
    #   currently possesses extracted from token or application security
    #   context. The value would come from the scope associated with an OAuth
    #   2.0 Access Token or an attribute value in a SAML 2.0 Assertion.
    # @param others [Hash<Symbol, String>] Additional free-form
    #   user information to attach to the trace.
    # @raise [ArgumentError]
    #
    # source://ddtrace//lib/datadog/kit/identity.rb#38
    def set_user(trace = T.unsafe(nil), span = T.unsafe(nil), id:, email: T.unsafe(nil), name: T.unsafe(nil), session_id: T.unsafe(nil), role: T.unsafe(nil), scope: T.unsafe(nil), **others); end

    private

    # @raise [ArgumentError]
    # @yield [trace, span]
    #
    # source://ddtrace//lib/datadog/kit/identity.rb#80
    def set_trace_and_span_context(method, trace = T.unsafe(nil), span = T.unsafe(nil)); end
  end
end

# Datadog Continuous Profiler implementation: https://docs.datadoghq.com/profiler/
#
# source://ddtrace//lib/datadog/profiling/ext.rb#4
module Datadog::Profiling
  class << self
    # source://ddtrace//lib/datadog/profiling.rb#63
    def allocation_count; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/profiling.rb#69
    def enabled?; end

    # Starts the profiler, if the profiler is supported by in
    # this runtime environment and if the profiler has been enabled
    # in configuration.
    #
    # @return [Boolean] `true` if the profiler has successfully started, otherwise `false`.
    #
    # source://ddtrace//lib/datadog/profiling.rb#32
    def start_if_enabled; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/profiling.rb#11
    def supported?; end

    # source://ddtrace//lib/datadog/profiling.rb#15
    def unsupported_reason; end

    private

    # All requires for the profiler should be directly added here; and everything should be loaded eagerly.
    # (Currently there's a few exceptions for the old profiler, but we should avoid other exceptions.)
    #
    # All of the profiler should be loaded and ready to go when this method returns `true`.
    #
    # source://ddtrace//lib/datadog/profiling.rb#190
    def load_profiling; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/profiling.rb#80
    def native_library_compilation_skipped?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/profiling.rb#160
    def native_library_failed_to_load?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/profiling.rb#119
    def protobuf_already_loaded?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/profiling.rb#124
    def protobuf_failed_to_load?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/profiling.rb#100
    def protobuf_gem_unavailable?; end

    # The `google-protobuf` gem depends on a native component, and its creators helpfully tried to provide precompiled
    # versions of this extension on rubygems.org.
    #
    # Unfortunately, for a long time, the supported Ruby versions metadata on these precompiled versions of the extension
    # was not correctly set. (This is fixed in newer versions -- but not all Ruby versions we want to support can use
    # these.)
    #
    # Thus, the gem can still be installed, but can be in a broken state. To avoid breaking customer applications, we
    # use this helper to load it and gracefully handle failures.
    #
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/profiling.rb#139
    def protobuf_loaded_successfully?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/profiling.rb#109
    def protobuf_version_unsupported?; end

    # source://ddtrace//lib/datadog/profiling.rb#74
    def replace_noop_allocation_count; end

    # source://ddtrace//lib/datadog/profiling.rb#174
    def try_loading_native_library; end

    # source://ddtrace//lib/datadog/profiling.rb#86
    def try_reading_skipped_reason_file(file_api = T.unsafe(nil)); end
  end
end

# Responsible for wiring up the Profiler for execution
#
# source://ddtrace//lib/datadog/profiling/component.rb#6
module Datadog::Profiling::Component
  class << self
    # Passing in a `nil` tracer is supported and will disable the following profiling features:
    # * Code Hotspots panel in the trace viewer, as well as scoping a profile down to a span
    # * Endpoint aggregation in the profiler UX, including normalization (resource per endpoint call)
    #
    # source://ddtrace//lib/datadog/profiling/component.rb#10
    def build_profiler_component(settings:, agent_settings:, optional_tracer:); end

    private

    # source://ddtrace//lib/datadog/profiling/component.rb#104
    def build_profiler_exporter(settings, recorder, no_signals_workaround_enabled:); end

    # source://ddtrace//lib/datadog/profiling/component.rb#100
    def build_profiler_old_recorder(settings); end

    # source://ddtrace//lib/datadog/profiling/component.rb#115
    def build_profiler_oldstack_collector(settings, old_recorder, tracer); end

    # source://ddtrace//lib/datadog/profiling/component.rb#128
    def build_profiler_transport(settings, agent_settings); end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/profiling/component.rb#138
    def enable_gc_profiling?(settings); end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/profiling/component.rb#154
    def enable_new_profiler?(settings); end

    # Versions of libmysqlclient prior to 8.0.0 are known to have buggy handling of system call interruptions.
    # The profiler can sometimes cause system call interruptions, and so this combination can cause queries to fail.
    #
    # See https://bugs.mysql.com/bug.php?id=83109 and
    # https://docs.datadoghq.com/profiler/profiler_troubleshooting/ruby/#unexpected-run-time-failures-and-errors-from-ruby-gems-that-use-native-extensions-in-dd-trace-rb-1110
    # for details.
    #
    # The `mysql2` gem's `info` method can be used to determine which `libmysqlclient` version is in use, and thus to
    # detect if it's safe for the profiler to use signals or if we need to employ a fallback.
    #
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/profiling/component.rb#248
    def incompatible_libmysqlclient_version?(settings); end

    # The old profiler's pprof support conflicts with the ruby-cloud-profiler gem.
    #
    # This is not a problem for almost all customers, since we now default everyone to use the new CPU Profiling 2.0
    # profiler. But the issue was still triggered, because currently we still _load_ both the old and new profiling
    # code paths.
    #
    # To work around this issue, and because we plan on deleting the old profiler soon, rather than poking at the
    # pprof support code, we only load the conflicting file when the old profiler is in use. This way customers using
    # the new profiler will not be affected by the issue any longer.
    #
    # source://ddtrace//lib/datadog/profiling/component.rb#302
    def load_pprof_support; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/profiling/component.rb#165
    def no_signals_workaround_enabled?(settings); end
  end
end

# source://ddtrace//lib/datadog/profiling/ext.rb#5
module Datadog::Profiling::Ext; end

# source://ddtrace//lib/datadog/profiling/ext.rb#9
Datadog::Profiling::Ext::ENV_AGENTLESS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#6
Datadog::Profiling::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#10
Datadog::Profiling::Ext::ENV_ENDPOINT_COLLECTION_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#8
Datadog::Profiling::Ext::ENV_MAX_FRAMES = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#7
Datadog::Profiling::Ext::ENV_UPLOAD_TIMEOUT = T.let(T.unsafe(nil), String)

# TODO: Consider removing this once the Ruby-based pprof encoding is removed and replaced by libdatadog
#
# source://ddtrace//lib/datadog/profiling/ext.rb#13
module Datadog::Profiling::Ext::Pprof; end

# source://ddtrace//lib/datadog/profiling/ext.rb#14
Datadog::Profiling::Ext::Pprof::LABEL_KEY_LOCAL_ROOT_SPAN_ID = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#15
Datadog::Profiling::Ext::Pprof::LABEL_KEY_SPAN_ID = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#16
Datadog::Profiling::Ext::Pprof::LABEL_KEY_THREAD_ID = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#17
Datadog::Profiling::Ext::Pprof::LABEL_KEY_TRACE_ENDPOINT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#18
Datadog::Profiling::Ext::Pprof::SAMPLE_VALUE_NO_VALUE = T.let(T.unsafe(nil), Integer)

# source://ddtrace//lib/datadog/profiling/ext.rb#19
Datadog::Profiling::Ext::Pprof::VALUE_TYPE_CPU = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#20
Datadog::Profiling::Ext::Pprof::VALUE_TYPE_WALL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#21
Datadog::Profiling::Ext::Pprof::VALUE_UNIT_NANOSECONDS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#24
module Datadog::Profiling::Ext::Transport; end

# source://ddtrace//lib/datadog/profiling/ext.rb#25
module Datadog::Profiling::Ext::Transport::HTTP; end

# source://ddtrace//lib/datadog/profiling/ext.rb#40
Datadog::Profiling::Ext::Transport::HTTP::CODE_PROVENANCE_FILENAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#26
Datadog::Profiling::Ext::Transport::HTTP::FORM_FIELD_TAG_ENV = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#27
Datadog::Profiling::Ext::Transport::HTTP::FORM_FIELD_TAG_HOST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#28
Datadog::Profiling::Ext::Transport::HTTP::FORM_FIELD_TAG_LANGUAGE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#29
Datadog::Profiling::Ext::Transport::HTTP::FORM_FIELD_TAG_PID = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#30
Datadog::Profiling::Ext::Transport::HTTP::FORM_FIELD_TAG_PROFILER_VERSION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#31
Datadog::Profiling::Ext::Transport::HTTP::FORM_FIELD_TAG_RUNTIME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#32
Datadog::Profiling::Ext::Transport::HTTP::FORM_FIELD_TAG_RUNTIME_ENGINE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#33
Datadog::Profiling::Ext::Transport::HTTP::FORM_FIELD_TAG_RUNTIME_ID = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#34
Datadog::Profiling::Ext::Transport::HTTP::FORM_FIELD_TAG_RUNTIME_PLATFORM = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#35
Datadog::Profiling::Ext::Transport::HTTP::FORM_FIELD_TAG_RUNTIME_VERSION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#36
Datadog::Profiling::Ext::Transport::HTTP::FORM_FIELD_TAG_SERVICE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#37
Datadog::Profiling::Ext::Transport::HTTP::FORM_FIELD_TAG_VERSION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling/ext.rb#39
Datadog::Profiling::Ext::Transport::HTTP::PPROF_DEFAULT_FILENAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/profiling.rb#8
Datadog::Profiling::GOOGLE_PROTOBUF_MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Datadog APM tracing public API.
#
# The Datadog team ensures that public methods in this module
# only receive backwards compatible changes, and breaking changes
# will only occur in new major versions releases.
#
# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#4
module Datadog::Tracing
  class << self
    # The active, unfinished span, representing the currently instrumented application section.
    #
    # The active span belongs to an {.active_trace}.
    #
    # @param key [Thread] Thread to retrieve trace from. Defaults to current thread. For internal use only.
    # @return [Datadog::Tracing::SpanOperation] the active span
    # @return [nil] if no trace is active, and thus no span is active
    #
    # source://ddtrace//lib/datadog/tracing.rb#50
    def active_span; end

    # The active, unfinished trace, representing the current instrumentation context.
    #
    # The active trace is fiber-local.
    #
    # @param key [Thread] Thread to retrieve trace from. Defaults to current thread. For internal use only.
    # @return [Datadog::Tracing::TraceSegment] the active trace
    # @return [nil] if no trace is active
    #
    # source://ddtrace//lib/datadog/tracing.rb#41
    def active_trace; end

    # @overload before_flush
    # @overload before_flush
    # @see file:docs/GettingStarted.md#configuring-the-transport-layer Configuring the transport layer
    #
    # source://ddtrace//lib/datadog/tracing.rb#117
    def before_flush(*processors, &processor_block); end

    # Setup a new trace to continue from where another
    # trace left off.
    #
    # Used to continue distributed or async traces.
    #
    # @param digest [Datadog::Tracing::TraceDigest] continue from the {Datadog::Tracing::TraceDigest}.
    # @param key [Thread] Thread to retrieve trace from. Defaults to current thread. For internal use only.
    # @return [Object] If a block is provided, the result of the block execution.
    # @return [Datadog::Tracing::TraceOperation] If no block, the active {Datadog::Tracing::TraceOperation}.
    # @yield Optional block where this {#continue_trace!} `digest` scope is active.
    #   If no block, the `digest` remains active after {#continue_trace!} returns.
    #
    # source://ddtrace//lib/datadog/tracing.rb#23
    def continue_trace!(digest, &block); end

    # Information about the currently active trace.
    #
    # The most common use cases are tagging log messages and metrics.
    #
    # @param key [Thread] Thread to retrieve trace from. Defaults to current thread. For internal use only.
    # @return [Datadog::Tracing::Correlation::Identifier] correlation object
    #
    # source://ddtrace//lib/datadog/tracing.rb#75
    def correlation; end

    # Is the tracer collecting telemetry data in this process?
    #
    # @return [Boolean] `true` if the tracer is collecting data in this process, otherwise `false`.
    #
    # source://ddtrace//lib/datadog/tracing.rb#123
    def enabled?; end

    # If an active trace is present, forces it to be retained by the Datadog backend.
    #
    # Any sampling logic will not be able to change this decision.
    #
    # If no trace is active, no action is taken.
    #
    # @return [void]
    #
    # source://ddtrace//lib/datadog/tracing.rb#60
    def keep!; end

    # Textual representation of {.correlation}, which can be
    # added to individual log lines in order to correlate them with the active
    # trace.
    #
    # Example:
    #
    # ```
    # MyLogger.log("#{Datadog::Tracing.log_correlation}] My message")
    # # dd.env=prod dd.service=auth dd.version=13.8 dd.trace_id=5458478252992251 dd.span_id=7117552347370098 My message
    # ```
    #
    # @return [String] correlation information
    #
    # source://ddtrace//lib/datadog/tracing.rb#95
    def log_correlation; end

    # The tracer's internal logger instance.
    # All tracing log output is handled by this object.
    #
    # The logger can be configured through {.configure},
    # through {Datadog::Core::Configuration::Settings::DSL::Logger} options.
    #
    # source://ddtrace//lib/datadog/tracing.rb#35
    def logger; end

    # If an active trace is present, forces it to be dropped and not stored by the Datadog backend.
    #
    # Any sampling logic will not be able to change this decision.
    #
    # If no trace is active, no action is taken.
    #
    # @return [void]
    #
    # source://ddtrace//lib/datadog/tracing.rb#68
    def reject!; end

    # Gracefully shuts down the tracer.
    #
    # The public tracing API will still respond to method calls as usual
    # but might not internally perform the expected internal work after shutdown.
    #
    # This avoids errors being raised across the host application
    # during shutdown while allowing for the graceful decommission of resources.
    #
    # {.shutdown!} cannot be reversed.
    #
    # source://ddtrace//lib/datadog/tracing.rb#109
    def shutdown!; end

    # Return a {Datadog::Tracing::SpanOperation span_op} and {Datadog::Tracing::TraceOperation trace_op}
    # that will trace an operation called `name`.
    #
    # You could trace your code using a <tt>do-block</tt> like:
    #
    # ```
    # tracer.trace('web.request') do |span_op, trace_op|
    #   span_op.service = 'my-web-site'
    #   span_op.resource = '/'
    #   span_op.set_tag('http.method', request.request_method)
    #   do_something()
    # end
    # ```
    #
    # The {#trace} method can also be used without a block in this way:
    # ```
    # span_op = tracer.trace('web.request', service: 'my-web-site')
    # do_something()
    # span_op.finish()
    # ```
    #
    # Remember that in this case, calling {Datadog::Tracing::SpanOperation#finish} is mandatory.
    #
    # When a Trace is started, {#trace} will store the created span; subsequent spans will
    # become its children and will inherit some properties:
    # ```
    # parent = tracer.trace('parent')   # has no parent span
    # child  = tracer.trace('child')    # is a child of 'parent'
    # child.finish()
    # parent.finish()
    # parent2 = tracer.trace('parent2') # has no parent span
    # parent2.finish()
    # ```
    #
    #
    # @param name [String] {Datadog::Tracing::Span} operation name.
    #   See {https://docs.datadoghq.com/tracing/guide/configuring-primary-operation/ Primary Operations in Services}.
    # @param continue_from [Datadog::Tracing::TraceDigest] continue a trace from a {Datadog::Tracing::TraceDigest}.
    #   Used for linking traces that are executed asynchronously.
    # @param on_error [Proc] a block that overrides error handling behavior for this operation.
    # @param resource [String] the resource this span refers, or `name` if it's missing
    # @param service [String] the service name for this span.
    # @param start_time [Time] time which the span should have started.
    # @param tags [Hash<String,String>] extra tags which should be added to the span.
    # @param type [String] the type of the span. See {Datadog::Tracing::Metadata::Ext::AppTypes}.
    # @return [Object] If a block is provided, returns the result of the block execution.
    # @return [Datadog::Tracing::SpanOperation] If no block is provided, returns the active,
    #   unfinished {Datadog::Tracing::SpanOperation}.
    # @yield Optional block where new newly created {Datadog::Tracing::SpanOperation} captures the execution.
    # @yieldparam span_op [Datadog::Tracing::SpanOperation] the newly created and active [Datadog::Tracing::SpanOperation]
    # @yieldparam trace_op [Datadog::Tracing::TraceOperation] the active [Datadog::Tracing::TraceOperation]
    #
    # source://ddtrace//lib/datadog/tracing.rb#17
    def trace(name, continue_from: T.unsafe(nil), **span_options, &block); end

    private

    # DEV: components hosts both tracing and profiling inner objects today
    #
    # source://ddtrace//lib/datadog/tracing.rb#133
    def components; end

    # source://ddtrace//lib/datadog/tracing.rb#137
    def tracer; end
  end
end

# Defines analytics behavior
#
# source://ddtrace//lib/datadog/tracing/analytics.rb#8
module Datadog::Tracing::Analytics
  class << self
    # source://ddtrace//lib/datadog/tracing/analytics.rb#16
    def set_measured(span_op, value = T.unsafe(nil)); end

    # source://ddtrace//lib/datadog/tracing/analytics.rb#10
    def set_sample_rate(span_op, sample_rate); end
  end
end

# Trace buffer that stores application traces, has a maximum size, and
# can be safely used concurrently with CRuby.
#
# @see Datadog::Core::Buffer::CRuby
#
# source://ddtrace//lib/datadog/tracing/buffer.rb#109
class Datadog::Tracing::CRubyTraceBuffer < ::Datadog::Core::Buffer::CRuby
  include ::Datadog::Tracing::MeasuredBuffer
end

# Common functions for supporting the `http.client_ip` span attribute.
#
# source://ddtrace//lib/datadog/tracing/client_ip.rb#11
module Datadog::Tracing::ClientIp
  class << self
    # source://ddtrace//lib/datadog/tracing/client_ip.rb#40
    def extract_client_ip(headers, remote_ip); end

    # Sets the `http.client_ip` tag on the given span.
    #
    # This function respects the user's settings: if they disable the client IP tagging,
    #   or provide a different IP header name.
    #
    # @param span [Span] The span that's associated with the request.
    # @param headers [HeaderCollection, #get, nil] A collection with the request headers.
    # @param remote_ip [String, nil] The remote IP the request associated with the span is sent to.
    #
    # source://ddtrace//lib/datadog/tracing/client_ip.rb#21
    def set_client_ip_tag(span, headers: T.unsafe(nil), remote_ip: T.unsafe(nil)); end

    # Forcefully sets the `http.client_ip` tag on the given span.
    #
    # This function ignores the user's `enabled` setting.
    #
    # @param span [Span] The span that's associated with the request.
    # @param headers [HeaderCollection, #get, nil] A collection with the request headers.
    # @param remote_ip [String, nil] The remote IP the request associated with the span is sent to.
    #
    # source://ddtrace//lib/datadog/tracing/client_ip.rb#34
    def set_client_ip_tag!(span, headers: T.unsafe(nil), remote_ip: T.unsafe(nil)); end

    private

    # source://ddtrace//lib/datadog/tracing/client_ip.rb#55
    def configuration; end
  end
end

# Tracing component
#
# source://ddtrace//lib/datadog/tracing/component.rb#12
module Datadog::Tracing::Component
  # TODO: Sampler should be a top-level component.
  # It is currently part of the Tracer initialization
  # process, but can take a variety of options (including
  # a fully custom instance) that makes the Tracer
  # initialization process complex.
  #
  # source://ddtrace//lib/datadog/tracing/component.rb#74
  def build_sampler(settings); end

  # source://ddtrace//lib/datadog/tracing/component.rb#172
  def build_span_sampler(settings); end

  # source://ddtrace//lib/datadog/tracing/component.rb#59
  def build_trace_flush(settings); end

  # source://ddtrace//lib/datadog/tracing/component.rb#24
  def build_tracer(settings, agent_settings); end

  # TODO: Writer should be a top-level component.
  # It is currently part of the Tracer initialization
  # process, but can take a variety of options (including
  # a fully custom instance) that makes the Tracer
  # initialization process complex.
  #
  # source://ddtrace//lib/datadog/tracing/component.rb#133
  def build_writer(settings, agent_settings); end

  # source://ddtrace//lib/datadog/tracing/component.rb#114
  def ensure_priority_sampling(sampler, settings); end

  # source://ddtrace//lib/datadog/tracing/component.rb#141
  def subscribe_to_writer_events!(writer, sampler_delegator, test_mode); end

  # Create new lambda for writer callback,
  # capture the current sampler in the callback closure.
  #
  # source://ddtrace//lib/datadog/tracing/component.rb#162
  def writer_update_priority_sampler_rates_callback(sampler); end

  private

  # source://ddtrace//lib/datadog/tracing/component.rb#212
  def build_test_mode_sampler; end

  # source://ddtrace//lib/datadog/tracing/component.rb#207
  def build_test_mode_trace_flush(settings); end

  # source://ddtrace//lib/datadog/tracing/component.rb#221
  def build_test_mode_writer(settings, agent_settings); end

  # source://ddtrace//lib/datadog/tracing/component.rb#200
  def build_tracer_tags(settings); end
end

# Methods that interact with component instance fields.
#
# source://ddtrace//lib/datadog/tracing/component.rb#14
module Datadog::Tracing::Component::InstanceMethods
  # Hot-swaps with a new sampler.
  # This operation acquires the Components lock to ensure
  # there is no concurrent modification of the sampler.
  #
  # source://ddtrace//lib/datadog/tracing/component.rb#18
  def reconfigure_live_sampler; end
end

# Sampler wrapper component, to allow for hot-swapping
# the sampler instance used by the tracer.
# Swapping samplers happens during Dynamic Configuration.
#
# source://ddtrace//lib/datadog/tracing/component.rb#180
class Datadog::Tracing::Component::SamplerDelegatorComponent
  # @return [SamplerDelegatorComponent] a new instance of SamplerDelegatorComponent
  #
  # source://ddtrace//lib/datadog/tracing/component.rb#183
  def initialize(sampler); end

  # source://ddtrace//lib/datadog/tracing/component.rb#187
  def sample!(trace); end

  # Returns the value of attribute sampler.
  #
  # source://ddtrace//lib/datadog/tracing/component.rb#181
  def sampler; end

  # Sets the attribute sampler
  #
  # @param value the value to set the attribute sampler to.
  #
  # source://ddtrace//lib/datadog/tracing/component.rb#181
  def sampler=(_arg0); end

  # source://ddtrace//lib/datadog/tracing/component.rb#191
  def update(*args, **kwargs); end
end

# source://ddtrace//lib/datadog/tracing/component.rb#156
Datadog::Tracing::Component::WRITER_RECORD_ENVIRONMENT_INFORMATION_CALLBACK = T.let(T.unsafe(nil), Proc)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#5
module Datadog::Tracing::Configuration; end

# Tracing Dynamic Configuration,
# powered by the Remote Configuration platform.
#
# source://ddtrace//lib/datadog/tracing/configuration/dynamic/option.rb#6
module Datadog::Tracing::Configuration::Dynamic; end

# Dynamic configuration for `DD_LOGS_INJECTION`.
#
# source://ddtrace//lib/datadog/tracing/configuration/dynamic.rb#12
class Datadog::Tracing::Configuration::Dynamic::LogInjectionEnabled < ::Datadog::Tracing::Configuration::Dynamic::SimpleOption
  # @return [LogInjectionEnabled] a new instance of LogInjectionEnabled
  #
  # source://ddtrace//lib/datadog/tracing/configuration/dynamic.rb#13
  def initialize; end
end

# List of all tracing dynamic configuration options supported.
#
# source://ddtrace//lib/datadog/tracing/configuration/dynamic.rb#57
Datadog::Tracing::Configuration::Dynamic::OPTIONS = T.let(T.unsafe(nil), Array)

# Maps a remote dynamic configuration to a location configuration option.
#
# source://ddtrace//lib/datadog/tracing/configuration/dynamic/option.rb#8
class Datadog::Tracing::Configuration::Dynamic::Option
  # @param name [String] dynamic configuration option name. This must match the remote configuration payload.
  # @return [Option] a new instance of Option
  #
  # source://ddtrace//lib/datadog/tracing/configuration/dynamic/option.rb#12
  def initialize(name, env_var); end

  # Reconfigures the provided option, setting its value to `value`.
  #
  # @param value [Object, nil] the new value for this option
  # @raise [NotImplementedError]
  #
  # source://ddtrace//lib/datadog/tracing/configuration/dynamic/option.rb#20
  def call(value); end

  # Returns the value of attribute env_var.
  #
  # source://ddtrace//lib/datadog/tracing/configuration/dynamic/option.rb#9
  def env_var; end

  # Returns the value of attribute name.
  #
  # source://ddtrace//lib/datadog/tracing/configuration/dynamic/option.rb#9
  def name; end
end

# A dynamic configuration option that can directly mapped to a `Datadog.configuration`
# option and changing such option is the only requirement to apply the configuration locally.
#
# source://ddtrace//lib/datadog/tracing/configuration/dynamic/option.rb#27
class Datadog::Tracing::Configuration::Dynamic::SimpleOption < ::Datadog::Tracing::Configuration::Dynamic::Option
  # DEV: `Datadog.configuration` cannot be an argument default value because
  # DEV: it is dynamic. Also, it is not yet declared when this method is parsed by Ruby.
  #
  # @param name [String] dynamic configuration option name. This must match the remote configuration payload.
  # @param env_var [String] the canonical environment variable that represents this option.
  #   This is used for telemetry reporting.
  # @param setting_key [Symbol] option from `Datadog.configuration.tracing` that will be modified
  # @return [SimpleOption] a new instance of SimpleOption
  #
  # source://ddtrace//lib/datadog/tracing/configuration/dynamic/option.rb#35
  def initialize(name, env_var, setting_key); end

  # Reconfigures the provided option, setting its value to `value`.
  #
  # @param value [Object, nil] the new value for this option
  #
  # source://ddtrace//lib/datadog/tracing/configuration/dynamic/option.rb#43
  def call(value); end

  protected

  # The base where `setting_key` will apply
  #
  # source://ddtrace//lib/datadog/tracing/configuration/dynamic/option.rb#64
  def configuration_object; end
end

# Dynamic configuration for `DD_TRACE_HEADER_TAGS`.
#
# source://ddtrace//lib/datadog/tracing/configuration/dynamic.rb#19
class Datadog::Tracing::Configuration::Dynamic::TracingHeaderTags < ::Datadog::Tracing::Configuration::Dynamic::SimpleOption
  # @return [TracingHeaderTags] a new instance of TracingHeaderTags
  #
  # source://ddtrace//lib/datadog/tracing/configuration/dynamic.rb#20
  def initialize; end

  # source://ddtrace//lib/datadog/tracing/configuration/dynamic.rb#24
  def call(tracing_header_tags); end
end

# Dynamic configuration for `DD_TRACE_SAMPLE_RATE`.
#
# source://ddtrace//lib/datadog/tracing/configuration/dynamic.rb#38
class Datadog::Tracing::Configuration::Dynamic::TracingSamplingRate < ::Datadog::Tracing::Configuration::Dynamic::SimpleOption
  # @return [TracingSamplingRate] a new instance of TracingSamplingRate
  #
  # source://ddtrace//lib/datadog/tracing/configuration/dynamic.rb#39
  def initialize; end

  # Ensures sampler is rebuilt and new configuration is applied
  #
  # source://ddtrace//lib/datadog/tracing/configuration/dynamic.rb#44
  def call(tracing_sampling_rate); end

  protected

  # source://ddtrace//lib/datadog/tracing/configuration/dynamic.rb#51
  def configuration_object; end
end

# Constants for configuration settings
# e.g. Env vars, default values, enums, etc...
#
# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#8
module Datadog::Tracing::Configuration::Ext; end

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#20
module Datadog::Tracing::Configuration::Ext::Analytics; end

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#21
Datadog::Tracing::Configuration::Ext::Analytics::ENV_TRACE_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#96
module Datadog::Tracing::Configuration::Ext::ClientIp; end

# TODO: deprecated, remove later
#
# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#98
Datadog::Tracing::Configuration::Ext::ClientIp::ENV_DISABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#97
Datadog::Tracing::Configuration::Ext::ClientIp::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#99
Datadog::Tracing::Configuration::Ext::ClientIp::ENV_HEADER_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#25
module Datadog::Tracing::Configuration::Ext::Correlation; end

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#26
Datadog::Tracing::Configuration::Ext::Correlation::ENV_LOGS_INJECTION_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#27
Datadog::Tracing::Configuration::Ext::Correlation::ENV_TRACE_ID_128_BIT_LOGGING_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#31
module Datadog::Tracing::Configuration::Ext::Distributed; end

# Sets both extract and inject propagation style tho the provided value.
# Has lower precedence than `DD_TRACE_PROPAGATION_STYLE_INJECT` or
# `DD_TRACE_PROPAGATION_STYLE_EXTRACT`.
#
# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#49
Datadog::Tracing::Configuration::Ext::Distributed::ENV_PROPAGATION_STYLE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#55
Datadog::Tracing::Configuration::Ext::Distributed::ENV_PROPAGATION_STYLE_EXTRACT = T.let(T.unsafe(nil), String)

# @deprecated Use `DD_TRACE_PROPAGATION_STYLE_EXTRACT` instead.
#
# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#57
Datadog::Tracing::Configuration::Ext::Distributed::ENV_PROPAGATION_STYLE_EXTRACT_OLD = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#51
Datadog::Tracing::Configuration::Ext::Distributed::ENV_PROPAGATION_STYLE_INJECT = T.let(T.unsafe(nil), String)

# @deprecated Use `DD_TRACE_PROPAGATION_STYLE_INJECT` instead.
#
# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#53
Datadog::Tracing::Configuration::Ext::Distributed::ENV_PROPAGATION_STYLE_INJECT_OLD = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#63
Datadog::Tracing::Configuration::Ext::Distributed::ENV_X_DATADOG_TAGS_MAX_LENGTH = T.let(T.unsafe(nil), String)

# @deprecated Use `b3multi` instead.
#
# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#37
Datadog::Tracing::Configuration::Ext::Distributed::PROPAGATION_STYLE_B3 = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#35
Datadog::Tracing::Configuration::Ext::Distributed::PROPAGATION_STYLE_B3_MULTI_HEADER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#39
Datadog::Tracing::Configuration::Ext::Distributed::PROPAGATION_STYLE_B3_SINGLE_HEADER = T.let(T.unsafe(nil), String)

# @deprecated Use `b3` instead.
#
# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#41
Datadog::Tracing::Configuration::Ext::Distributed::PROPAGATION_STYLE_B3_SINGLE_HEADER_OLD = T.let(T.unsafe(nil), String)

# Custom Datadog format
#
# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#33
Datadog::Tracing::Configuration::Ext::Distributed::PROPAGATION_STYLE_DATADOG = T.let(T.unsafe(nil), String)

# A no-op propagator. Compatible with OpenTelemetry's `none` propagator.
#
# @see https://opentelemetry.io/docs/concepts/sdk-configuration/general-sdk-configuration/#get_otel__propagators
#
# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#61
Datadog::Tracing::Configuration::Ext::Distributed::PROPAGATION_STYLE_NONE = T.let(T.unsafe(nil), String)

# W3C Trace Context
#
# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#44
Datadog::Tracing::Configuration::Ext::Distributed::PROPAGATION_STYLE_TRACE_CONTEXT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#9
Datadog::Tracing::Configuration::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#10
Datadog::Tracing::Configuration::Ext::ENV_HEADER_TAGS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#11
Datadog::Tracing::Configuration::Ext::ENV_TRACE_ID_128_BIT_GENERATION_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#67
module Datadog::Tracing::Configuration::Ext::NET; end

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#68
Datadog::Tracing::Configuration::Ext::NET::ENV_REPORT_HOSTNAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#72
module Datadog::Tracing::Configuration::Ext::Sampling; end

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#74
Datadog::Tracing::Configuration::Ext::Sampling::ENV_RATE_LIMIT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#75
Datadog::Tracing::Configuration::Ext::Sampling::ENV_RULES = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#73
Datadog::Tracing::Configuration::Ext::Sampling::ENV_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#78
module Datadog::Tracing::Configuration::Ext::Sampling::Span; end

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#79
Datadog::Tracing::Configuration::Ext::Sampling::Span::ENV_SPAN_SAMPLING_RULES = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#80
Datadog::Tracing::Configuration::Ext::Sampling::Span::ENV_SPAN_SAMPLING_RULES_FILE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#14
module Datadog::Tracing::Configuration::Ext::SpanAttributeSchema; end

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#15
Datadog::Tracing::Configuration::Ext::SpanAttributeSchema::ENV_GLOBAL_DEFAULT_SERVICE_NAME_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#16
Datadog::Tracing::Configuration::Ext::SpanAttributeSchema::ENV_PEER_SERVICE_MAPPING = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#85
module Datadog::Tracing::Configuration::Ext::Test; end

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#86
Datadog::Tracing::Configuration::Ext::Test::ENV_MODE_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#90
module Datadog::Tracing::Configuration::Ext::Transport; end

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#91
Datadog::Tracing::Configuration::Ext::Transport::ENV_DEFAULT_PORT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/ext.rb#92
Datadog::Tracing::Configuration::Ext::Transport::ENV_DEFAULT_URL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/configuration/http.rb#6
module Datadog::Tracing::Configuration::HTTP; end

# Datadog tracing supports capturing HTTP request and response headers as span tags.
#
# The provided configuration String for this feature has to be pre-processed to
# allow for ease of utilization by each HTTP integration.
#
# This class process configuration, stores the result, and provides methods to
# utilize this configuration.
#
# source://ddtrace//lib/datadog/tracing/configuration/http.rb#14
class Datadog::Tracing::Configuration::HTTP::HeaderTags
  # @param header_tags [Array<String>] The list of strings from DD_TRACE_HEADER_TAGS.
  # @return [HeaderTags] a new instance of HeaderTags
  #
  # source://ddtrace//lib/datadog/tracing/configuration/http.rb#16
  def initialize(header_tags); end

  # Receives a case insensitive hash with the request headers and returns
  # a list of tag names and values that can be set in a span.
  #
  # source://ddtrace//lib/datadog/tracing/configuration/http.rb#45
  def request_tags(headers); end

  # Receives a case insensitive hash with the response headers and returns
  # a list of tag names and values that can be set in a span.
  #
  # source://ddtrace//lib/datadog/tracing/configuration/http.rb#56
  def response_tags(headers); end

  # For easy configuration inspection,
  # print the original configuration setting.
  #
  # source://ddtrace//lib/datadog/tracing/configuration/http.rb#67
  def to_s; end
end

# Configuration settings for tracing.
#
# source://ddtrace//lib/datadog/tracing/configuration/settings.rb#14
module Datadog::Tracing::Configuration::Settings
  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/configuration/settings.rb#15
    def extended(base); end
  end
end

# {Datadog::Tracing::Context} is used to keep track of a the active trace for the current
# execution flow. During each logical execution, the same {Datadog::Tracing::Context} is
# used to represent a single logical trace, even if the trace is built
# asynchronously.
#
# A single code execution may use multiple {Datadog::Tracing::Context} if part of the execution
# must not be related to the current tracing. As example, a delayed job may
# compose a standalone trace instead of being related to the same trace that
# generates the job itself. On the other hand, if it's part of the same
# {Datadog::Tracing::Context}, it will be related to the original trace.
#
# source://ddtrace//lib/datadog/tracing/context.rb#17
class Datadog::Tracing::Context
  include ::Datadog::Core::Utils::Forking::ClassExtensions
  include ::Datadog::Core::Utils::Forking

  # @return [Context] a new instance of Context
  #
  # source://ddtrace//lib/datadog/core/utils/forking.rb#47
  def initialize(*args, **kwargs, &block); end

  # Handles trace activation.
  #
  # Permits nil, allowing traces to be deactivated.
  #
  # If given a block, it will reset to the original
  # trace after the block completes.
  #
  # When restoring the original trace, if it is finished,
  # it will deactivate it. This prevents the context from
  # holding references to completed traces thereby releasing
  # its memory.
  #
  # source://ddtrace//lib/datadog/tracing/context.rb#40
  def activate!(trace); end

  # Returns the value of attribute active_trace.
  #
  # source://ddtrace//lib/datadog/tracing/context.rb#20
  def active_trace; end

  # Creates a copy of the context, when forked.
  #
  # source://ddtrace//lib/datadog/tracing/context.rb#55
  def fork_clone; end

  private

  # source://ddtrace//lib/datadog/tracing/context.rb#62
  def set_active_trace!(trace); end
end

# Out-of-the-box instrumentation for tracing
#
# source://ddtrace//lib/datadog/tracing/contrib/registry.rb#5
module Datadog::Tracing::Contrib
  class << self
    # Auto-activate instrumentation
    #
    # source://ddtrace//lib/datadog/tracing/contrib/auto_instrument.rb#11
    def auto_instrument!; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/ext.rb#6
module Datadog::Tracing::Contrib::ActionCable; end

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/configuration/settings.rb#10
module Datadog::Tracing::Contrib::ActionCable::Configuration; end

# Custom settings for the ActionCable integration
#
# source://ddtrace//lib/datadog/tracing/contrib/action_cable/configuration/settings.rb#13
class Datadog::Tracing::Contrib::ActionCable::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# Defines basic behaviors for an event.
#
# source://ddtrace//lib/datadog/tracing/contrib/action_cable/event.rb#13
module Datadog::Tracing::Contrib::ActionCable::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event

  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActionCable::Event::ClassMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/event.rb#14
    def included(base); end
  end
end

# Class methods for events.
#
# source://ddtrace//lib/datadog/tracing/contrib/action_cable/event.rb#20
module Datadog::Tracing::Contrib::ActionCable::Event::ClassMethods
  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/event.rb#29
  def configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/event.rb#21
  def span_options; end
end

# Defines collection of instrumented ActionCable events
#
# source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/broadcast.rb#10
module Datadog::Tracing::Contrib::ActionCable::Events
  private

  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events.rb#22
  def all; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events.rb#30
  def subscribe!; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events.rb#26
  def subscriptions; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events.rb#22
    def all; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events.rb#30
    def subscribe!; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events.rb#26
    def subscriptions; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/events.rb#14
Datadog::Tracing::Contrib::ActionCable::Events::ALL = T.let(T.unsafe(nil), Array)

# Defines instrumentation for 'broadcast.action_cable' event.
#
# A single 'broadcast' event will trigger as many 'transmit' events
# as there are clients subscribed to a channel.
#
# source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/broadcast.rb#15
module Datadog::Tracing::Contrib::ActionCable::Events::Broadcast
  include ::Datadog::Tracing::Contrib::ActionCable::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActionCable::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/broadcast.rb#22
  def event_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/broadcast.rb#35
  def process(span, _event, _id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/broadcast.rb#26
  def span_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/broadcast.rb#30
  def span_type; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/broadcast.rb#22
    def event_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/broadcast.rb#35
    def process(span, _event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/broadcast.rb#26
    def span_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/broadcast.rb#30
    def span_type; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/broadcast.rb#18
Datadog::Tracing::Contrib::ActionCable::Events::Broadcast::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for 'perform_action.action_cable' event.
#
# An action, triggered by a WebSockets client, invokes a method
# in the server's channel instance.
#
# source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/perform_action.rb#14
module Datadog::Tracing::Contrib::ActionCable::Events::PerformAction
  include ::Datadog::Tracing::Contrib::ActionCable::RootContextEvent
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActionCable::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActionCable::RootContextEvent::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/perform_action.rb#21
  def event_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/perform_action.rb#34
  def process(span, _event, _id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/perform_action.rb#25
  def span_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/perform_action.rb#29
  def span_type; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/perform_action.rb#21
    def event_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/perform_action.rb#34
    def process(span, _event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/perform_action.rb#25
    def span_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/perform_action.rb#29
    def span_type; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/perform_action.rb#17
Datadog::Tracing::Contrib::ActionCable::Events::PerformAction::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for 'transmit.action_cable' event.
#
# A 'transmit' event sends a message to a single client subscribed to a channel.
#
# source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/transmit.rb#14
module Datadog::Tracing::Contrib::ActionCable::Events::Transmit
  include ::Datadog::Tracing::Contrib::ActionCable::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActionCable::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/transmit.rb#21
  def event_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/transmit.rb#34
  def process(span, _event, _id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/transmit.rb#25
  def span_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/transmit.rb#29
  def span_type; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/transmit.rb#21
    def event_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/transmit.rb#34
    def process(span, _event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/transmit.rb#25
    def span_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/transmit.rb#29
    def span_type; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/events/transmit.rb#17
Datadog::Tracing::Contrib::ActionCable::Events::Transmit::EVENT_NAME = T.let(T.unsafe(nil), String)

# ActionCable integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/action_cable/ext.rb#9
module Datadog::Tracing::Contrib::ActionCable::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/ext.rb#11
Datadog::Tracing::Contrib::ActionCable::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/ext.rb#12
Datadog::Tracing::Contrib::ActionCable::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/ext.rb#10
Datadog::Tracing::Contrib::ActionCable::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/ext.rb#13
Datadog::Tracing::Contrib::ActionCable::Ext::SPAN_ACTION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/ext.rb#14
Datadog::Tracing::Contrib::ActionCable::Ext::SPAN_BROADCAST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/ext.rb#15
Datadog::Tracing::Contrib::ActionCable::Ext::SPAN_ON_OPEN = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/ext.rb#16
Datadog::Tracing::Contrib::ActionCable::Ext::SPAN_TRANSMIT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/ext.rb#17
Datadog::Tracing::Contrib::ActionCable::Ext::TAG_ACTION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/ext.rb#18
Datadog::Tracing::Contrib::ActionCable::Ext::TAG_BROADCAST_CODER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/ext.rb#19
Datadog::Tracing::Contrib::ActionCable::Ext::TAG_CHANNEL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/ext.rb#20
Datadog::Tracing::Contrib::ActionCable::Ext::TAG_CHANNEL_CLASS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/ext.rb#21
Datadog::Tracing::Contrib::ActionCable::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/ext.rb#22
Datadog::Tracing::Contrib::ActionCable::Ext::TAG_CONNECTION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/ext.rb#23
Datadog::Tracing::Contrib::ActionCable::Ext::TAG_OPERATION_ACTION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/ext.rb#24
Datadog::Tracing::Contrib::ActionCable::Ext::TAG_OPERATION_BROADCAST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/ext.rb#25
Datadog::Tracing::Contrib::ActionCable::Ext::TAG_OPERATION_ON_OPEN = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/ext.rb#26
Datadog::Tracing::Contrib::ActionCable::Ext::TAG_OPERATION_TRANSMIT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/ext.rb#27
Datadog::Tracing::Contrib::ActionCable::Ext::TAG_TRANSMIT_VIA = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/instrumentation.rb#9
module Datadog::Tracing::Contrib::ActionCable::Instrumentation; end

# Instrumentation for when a Channel is subscribed to/unsubscribed from.
#
# source://ddtrace//lib/datadog/tracing/contrib/action_cable/instrumentation.rb#37
module Datadog::Tracing::Contrib::ActionCable::Instrumentation::ActionCableChannel
  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/instrumentation.rb#38
    def included(base); end
  end
end

# Instrumentation for Channel hooks.
#
# source://ddtrace//lib/datadog/tracing/contrib/action_cable/instrumentation.rb#57
class Datadog::Tracing::Contrib::ActionCable::Instrumentation::ActionCableChannel::Tracer
  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/instrumentation.rb#58
    def trace(channel, hook); end
  end
end

# When a new WebSocket is open, we receive a Rack request resource name "GET -1".
# This module overrides the current Rack resource name to provide a meaningful name.
#
# source://ddtrace//lib/datadog/tracing/contrib/action_cable/instrumentation.rb#12
module Datadog::Tracing::Contrib::ActionCable::Instrumentation::ActionCableConnection
  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/instrumentation.rb#13
  def on_open; end
end

# Description of ActionCable integration
#
# source://ddtrace//lib/datadog/tracing/contrib/action_cable/integration.rb#11
class Datadog::Tracing::Contrib::ActionCable::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # enabled by rails integration so should only auto instrument
  # if detected that it is being used without rails
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/integration.rb#33
  def auto_instrument?; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/integration.rb#37
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/integration.rb#41
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/integration.rb#27
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/integration.rb#23
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/integration.rb#19
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/action_cable/integration.rb#14
Datadog::Tracing::Contrib::ActionCable::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'action_cable' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/action_cable/patcher.rb#13
module Datadog::Tracing::Contrib::ActionCable::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/patcher.rb#22
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/patcher.rb#18
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/patcher.rb#18
    def target_version; end
  end
end

# Defines behavior for the first event of a thread execution.
#
# This event is not expected to be nested with other event,
# but to start a fresh tracing context.
#
# source://ddtrace//lib/datadog/tracing/contrib/action_cable/event.rb#39
module Datadog::Tracing::Contrib::ActionCable::RootContextEvent
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event

  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActionCable::RootContextEvent::ClassMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/action_cable/event.rb#40
    def included(base); end
  end
end

# Class methods for events.
#
# source://ddtrace//lib/datadog/tracing/contrib/action_cable/event.rb#46
module Datadog::Tracing::Contrib::ActionCable::RootContextEvent::ClassMethods
  include ::Datadog::Tracing::Contrib::ActionCable::Event::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/event.rb#49
  def subscription(*args); end

  private

  # Context objects are thread-bound.
  # If an integration re-uses threads, context from a previous trace
  # could leak into the new trace. This "cleans" current context,
  # preventing such a leak.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/action_cable/event.rb#61
  def ensure_clean_context!; end
end

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/ext.rb#6
module Datadog::Tracing::Contrib::ActionMailer; end

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/configuration/settings.rb#10
module Datadog::Tracing::Contrib::ActionMailer::Configuration; end

# Custom settings for the ActionMailer integration
#
# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/configuration/settings.rb#13
class Datadog::Tracing::Contrib::ActionMailer::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def email_data; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def email_data=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# Defines basic behaviors for an ActionMailer event.
#
# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/event.rb#12
module Datadog::Tracing::Contrib::ActionMailer::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event

  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActionMailer::Event::ClassMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/event.rb#13
    def included(base); end
  end
end

# Class methods for ActionMailer events.
#
# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/event.rb#19
module Datadog::Tracing::Contrib::ActionMailer::Event::ClassMethods
  # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/event.rb#26
  def configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/event.rb#30
  def process(span, event, _id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/event.rb#20
  def span_options; end
end

# Defines collection of instrumented ActionMailer events
#
# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events/process.rb#9
module Datadog::Tracing::Contrib::ActionMailer::Events
  private

  # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events.rb#19
  def all; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events.rb#27
  def subscribe!; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events.rb#23
  def subscriptions; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events.rb#19
    def all; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events.rb#27
    def subscribe!; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events.rb#23
    def subscriptions; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events.rb#12
Datadog::Tracing::Contrib::ActionMailer::Events::ALL = T.let(T.unsafe(nil), Array)

# Defines instrumentation for deliver.action_mailer event
#
# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events/deliver.rb#11
module Datadog::Tracing::Contrib::ActionMailer::Events::Deliver
  include ::Datadog::Tracing::Contrib::ActionMailer::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActionMailer::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events/deliver.rb#18
  def event_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events/deliver.rb#31
  def process(span, event, _id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events/deliver.rb#22
  def span_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events/deliver.rb#26
  def span_type; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events/deliver.rb#18
    def event_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events/deliver.rb#31
    def process(span, event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events/deliver.rb#22
    def span_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events/deliver.rb#26
    def span_type; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events/deliver.rb#14
Datadog::Tracing::Contrib::ActionMailer::Events::Deliver::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for process.action_mailer event
#
# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events/process.rb#11
module Datadog::Tracing::Contrib::ActionMailer::Events::Process
  include ::Datadog::Tracing::Contrib::ActionMailer::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActionMailer::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events/process.rb#18
  def event_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events/process.rb#31
  def process(span, event, _id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events/process.rb#22
  def span_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events/process.rb#26
  def span_type; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events/process.rb#18
    def event_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events/process.rb#31
    def process(span, event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events/process.rb#22
    def span_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events/process.rb#26
    def span_type; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/events/process.rb#14
Datadog::Tracing::Contrib::ActionMailer::Events::Process::EVENT_NAME = T.let(T.unsafe(nil), String)

# ActionMailer integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/ext.rb#9
module Datadog::Tracing::Contrib::ActionMailer::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/ext.rb#11
Datadog::Tracing::Contrib::ActionMailer::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/ext.rb#12
Datadog::Tracing::Contrib::ActionMailer::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/ext.rb#10
Datadog::Tracing::Contrib::ActionMailer::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/ext.rb#14
Datadog::Tracing::Contrib::ActionMailer::Ext::SPAN_DELIVER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/ext.rb#13
Datadog::Tracing::Contrib::ActionMailer::Ext::SPAN_PROCESS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/ext.rb#16
Datadog::Tracing::Contrib::ActionMailer::Ext::TAG_ACTION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/ext.rb#25
Datadog::Tracing::Contrib::ActionMailer::Ext::TAG_BCC = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/ext.rb#26
Datadog::Tracing::Contrib::ActionMailer::Ext::TAG_CC = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/ext.rb#15
Datadog::Tracing::Contrib::ActionMailer::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/ext.rb#27
Datadog::Tracing::Contrib::ActionMailer::Ext::TAG_DATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/ext.rb#24
Datadog::Tracing::Contrib::ActionMailer::Ext::TAG_FROM = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/ext.rb#17
Datadog::Tracing::Contrib::ActionMailer::Ext::TAG_MAILER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/ext.rb#18
Datadog::Tracing::Contrib::ActionMailer::Ext::TAG_MSG_ID = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/ext.rb#19
Datadog::Tracing::Contrib::ActionMailer::Ext::TAG_OPERATION_DELIVER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/ext.rb#20
Datadog::Tracing::Contrib::ActionMailer::Ext::TAG_OPERATION_PROCESS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/ext.rb#28
Datadog::Tracing::Contrib::ActionMailer::Ext::TAG_PERFORM_DELIVERIES = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/ext.rb#22
Datadog::Tracing::Contrib::ActionMailer::Ext::TAG_SUBJECT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/ext.rb#23
Datadog::Tracing::Contrib::ActionMailer::Ext::TAG_TO = T.let(T.unsafe(nil), String)

# Description of ActionMailer integration
#
# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/integration.rb#11
class Datadog::Tracing::Contrib::ActionMailer::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # enabled by rails integration so should only auto instrument
  # if detected that it is being used without rails
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/integration.rb#33
  def auto_instrument?; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/integration.rb#37
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/integration.rb#41
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/integration.rb#27
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/integration.rb#23
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/integration.rb#19
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/integration.rb#14
Datadog::Tracing::Contrib::ActionMailer::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'action_mailer' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/action_mailer/patcher.rb#12
module Datadog::Tracing::Contrib::ActionMailer::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/patcher.rb#21
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/patcher.rb#17
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_mailer/patcher.rb#17
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/action_pack/ext.rb#6
module Datadog::Tracing::Contrib::ActionPack; end

# source://ddtrace//lib/datadog/tracing/contrib/action_pack/action_controller/instrumentation.rb#13
module Datadog::Tracing::Contrib::ActionPack::ActionController; end

# Instrumentation for ActionController components
#
# source://ddtrace//lib/datadog/tracing/contrib/action_pack/action_controller/instrumentation.rb#15
module Datadog::Tracing::Contrib::ActionPack::ActionController::Instrumentation
  private

  # source://ddtrace//lib/datadog/tracing/contrib/action_pack/action_controller/instrumentation.rb#46
  def finish_processing(payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/action_pack/action_controller/instrumentation.rb#18
  def start_processing(payload); end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/action_pack/action_controller/instrumentation.rb#46
    def finish_processing(payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/action_pack/action_controller/instrumentation.rb#18
    def start_processing(payload); end
  end
end

# Instrumentation for ActionController::Metal
#
# source://ddtrace//lib/datadog/tracing/contrib/action_pack/action_controller/instrumentation.rb#85
module Datadog::Tracing::Contrib::ActionPack::ActionController::Instrumentation::Metal
  # source://ddtrace//lib/datadog/tracing/contrib/action_pack/action_controller/instrumentation.rb#120
  def datadog_response_status; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_pack/action_controller/instrumentation.rb#86
  def process_action(*args); end
end

# Patcher for ActionController components
#
# source://ddtrace//lib/datadog/tracing/contrib/action_pack/action_controller/patcher.rb#12
module Datadog::Tracing::Contrib::ActionPack::ActionController::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/action_pack/action_controller/patcher.rb#21
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_pack/action_controller/patcher.rb#17
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_pack/action_controller/patcher.rb#17
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/action_pack/configuration/settings.rb#10
module Datadog::Tracing::Contrib::ActionPack::Configuration; end

# Custom settings for the ActionPack integration
#
# source://ddtrace//lib/datadog/tracing/contrib/action_pack/configuration/settings.rb#13
class Datadog::Tracing::Contrib::ActionPack::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def exception_controller; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def exception_controller=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# ActionPack integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/action_pack/ext.rb#9
module Datadog::Tracing::Contrib::ActionPack::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/action_pack/ext.rb#11
Datadog::Tracing::Contrib::ActionPack::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_pack/ext.rb#12
Datadog::Tracing::Contrib::ActionPack::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_pack/ext.rb#10
Datadog::Tracing::Contrib::ActionPack::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_pack/ext.rb#13
Datadog::Tracing::Contrib::ActionPack::Ext::SPAN_ACTION_CONTROLLER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_pack/ext.rb#14
Datadog::Tracing::Contrib::ActionPack::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_pack/ext.rb#15
Datadog::Tracing::Contrib::ActionPack::Ext::TAG_OPERATION_CONTROLLER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_pack/ext.rb#16
Datadog::Tracing::Contrib::ActionPack::Ext::TAG_ROUTE_ACTION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_pack/ext.rb#17
Datadog::Tracing::Contrib::ActionPack::Ext::TAG_ROUTE_CONTROLLER = T.let(T.unsafe(nil), String)

# Describes the ActionPack integration
#
# source://ddtrace//lib/datadog/tracing/contrib/action_pack/integration.rb#11
class Datadog::Tracing::Contrib::ActionPack::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # enabled by rails integration so should only auto instrument
  # if detected that it is being used without rails
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/action_pack/integration.rb#33
  def auto_instrument?; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_pack/integration.rb#37
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_pack/integration.rb#41
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/action_pack/integration.rb#27
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/action_pack/integration.rb#23
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_pack/integration.rb#19
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/action_pack/integration.rb#14
Datadog::Tracing::Contrib::ActionPack::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'action_pack' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/action_pack/patcher.rb#11
module Datadog::Tracing::Contrib::ActionPack::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/action_pack/patcher.rb#20
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_pack/patcher.rb#16
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_pack/patcher.rb#16
    def target_version; end
  end
end

# Common utilities for ActionPack
#
# source://ddtrace//lib/datadog/tracing/contrib/action_pack/utils.rb#8
module Datadog::Tracing::Contrib::ActionPack::Utils
  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/action_pack/utils.rb#9
    def exception_is_error?(exception); end

    # source://ddtrace//lib/datadog/tracing/contrib/action_pack/utils.rb#21
    def set_analytics_sample_rate(span); end

    private

    # source://ddtrace//lib/datadog/tracing/contrib/action_pack/utils.rb#30
    def datadog_configuration; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/action_view/ext.rb#6
module Datadog::Tracing::Contrib::ActionView; end

# source://ddtrace//lib/datadog/tracing/contrib/action_view/configuration/settings.rb#8
module Datadog::Tracing::Contrib::ActionView::Configuration; end

# Custom settings for the ActionView integration
#
# source://ddtrace//lib/datadog/tracing/contrib/action_view/configuration/settings.rb#11
class Datadog::Tracing::Contrib::ActionView::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def template_base_path; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def template_base_path=(value); end
end

# Defines basic behavior for an ActionView event.
#
# source://ddtrace//lib/datadog/tracing/contrib/action_view/event.rb#10
module Datadog::Tracing::Contrib::ActionView::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event

  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActionView::Event::ClassMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/action_view/event.rb#11
    def included(base); end
  end
end

# Class methods for ActionView events.
#
# source://ddtrace//lib/datadog/tracing/contrib/action_view/event.rb#17
module Datadog::Tracing::Contrib::ActionView::Event::ClassMethods
  # source://ddtrace//lib/datadog/tracing/contrib/action_view/event.rb#18
  def configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/event.rb#22
  def record_exception(span, payload); end
end

# Defines collection of instrumented ActionView events
#
# source://ddtrace//lib/datadog/tracing/contrib/action_view/events/render_partial.rb#11
module Datadog::Tracing::Contrib::ActionView::Events
  private

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/events.rb#19
  def all; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/events.rb#27
  def subscribe!; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/events.rb#23
  def subscriptions; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/action_view/events.rb#19
    def all; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_view/events.rb#27
    def subscribe!; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_view/events.rb#23
    def subscriptions; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/action_view/events.rb#12
Datadog::Tracing::Contrib::ActionView::Events::ALL = T.let(T.unsafe(nil), Array)

# Defines instrumentation for render_partial.action_view event
#
# source://ddtrace//lib/datadog/tracing/contrib/action_view/events/render_partial.rb#13
module Datadog::Tracing::Contrib::ActionView::Events::RenderPartial
  include ::Datadog::Tracing::Contrib::ActionView::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActionView::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/events/render_partial.rb#20
  def event_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/events/render_partial.rb#28
  def process(span, _event, _id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/events/render_partial.rb#24
  def span_name; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/action_view/events/render_partial.rb#20
    def event_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_view/events/render_partial.rb#28
    def process(span, _event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/action_view/events/render_partial.rb#24
    def span_name; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/action_view/events/render_partial.rb#16
Datadog::Tracing::Contrib::ActionView::Events::RenderPartial::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for render_template.action_view event
#
# source://ddtrace//lib/datadog/tracing/contrib/action_view/events/render_template.rb#13
module Datadog::Tracing::Contrib::ActionView::Events::RenderTemplate
  include ::Datadog::Tracing::Contrib::ActionView::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActionView::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/events/render_template.rb#20
  def event_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/events/render_template.rb#28
  def process(span, _event, _id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/events/render_template.rb#24
  def span_name; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/action_view/events/render_template.rb#20
    def event_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_view/events/render_template.rb#28
    def process(span, _event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/action_view/events/render_template.rb#24
    def span_name; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/action_view/events/render_template.rb#16
Datadog::Tracing::Contrib::ActionView::Events::RenderTemplate::EVENT_NAME = T.let(T.unsafe(nil), String)

# ActionView integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/action_view/ext.rb#9
module Datadog::Tracing::Contrib::ActionView::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/action_view/ext.rb#11
Datadog::Tracing::Contrib::ActionView::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_view/ext.rb#12
Datadog::Tracing::Contrib::ActionView::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_view/ext.rb#10
Datadog::Tracing::Contrib::ActionView::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_view/ext.rb#13
Datadog::Tracing::Contrib::ActionView::Ext::SPAN_RENDER_PARTIAL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_view/ext.rb#14
Datadog::Tracing::Contrib::ActionView::Ext::SPAN_RENDER_TEMPLATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_view/ext.rb#15
Datadog::Tracing::Contrib::ActionView::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_view/ext.rb#16
Datadog::Tracing::Contrib::ActionView::Ext::TAG_LAYOUT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_view/ext.rb#17
Datadog::Tracing::Contrib::ActionView::Ext::TAG_OPERATION_RENDER_PARTIAL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_view/ext.rb#18
Datadog::Tracing::Contrib::ActionView::Ext::TAG_OPERATION_RENDER_TEMPLATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_view/ext.rb#19
Datadog::Tracing::Contrib::ActionView::Ext::TAG_TEMPLATE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/action_view/instrumentation/partial_renderer.rb#8
module Datadog::Tracing::Contrib::ActionView::Instrumentation; end

# Legacy instrumentation for partial rendering for Rails < 4
#
# source://ddtrace//lib/datadog/tracing/contrib/action_view/instrumentation/partial_renderer.rb#10
module Datadog::Tracing::Contrib::ActionView::Instrumentation::PartialRenderer
  # source://ddtrace//lib/datadog/tracing/contrib/action_view/instrumentation/partial_renderer.rb#36
  def datadog_render_partial(template); end

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/instrumentation/partial_renderer.rb#11
  def render(*args, &block); end

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/instrumentation/partial_renderer.rb#23
  def render_partial(*args); end

  private

  # Returns the value of attribute active_datadog_span.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/action_view/instrumentation/partial_renderer.rb#53
  def active_datadog_span; end

  # Sets the attribute active_datadog_span
  #
  # @param value the value to set the attribute active_datadog_span to.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/action_view/instrumentation/partial_renderer.rb#53
  def active_datadog_span=(_arg0); end

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/instrumentation/partial_renderer.rb#55
  def with_datadog_span(span); end
end

# Rails < 4 partial rendering
# ActiveSupport events are used instead for Rails >= 4
#
# source://ddtrace//lib/datadog/tracing/contrib/action_view/instrumentation/partial_renderer.rb#64
module Datadog::Tracing::Contrib::ActionView::Instrumentation::PartialRenderer::RailsLessThan4
  include ::Datadog::Tracing::Contrib::ActionView::Instrumentation::PartialRenderer

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/instrumentation/partial_renderer.rb#67
  def datadog_template(*args); end
end

# Legacy instrumentation for template rendering for Rails < 4
#
# source://ddtrace//lib/datadog/tracing/contrib/action_view/instrumentation/template_renderer.rb#10
module Datadog::Tracing::Contrib::ActionView::Instrumentation::TemplateRenderer; end

# Legacy shared code for Rails >= 3.1 template rendering
#
# source://ddtrace//lib/datadog/tracing/contrib/action_view/instrumentation/template_renderer.rb#12
module Datadog::Tracing::Contrib::ActionView::Instrumentation::TemplateRenderer::Rails31Plus
  # source://ddtrace//lib/datadog/tracing/contrib/action_view/instrumentation/template_renderer.rb#38
  def datadog_render_template(template, layout_name); end

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/instrumentation/template_renderer.rb#13
  def render(*args, &block); end

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/instrumentation/template_renderer.rb#25
  def render_template(*args); end

  private

  # Returns the value of attribute active_datadog_span.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/action_view/instrumentation/template_renderer.rb#65
  def active_datadog_span; end

  # Sets the attribute active_datadog_span
  #
  # @param value the value to set the attribute active_datadog_span to.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/action_view/instrumentation/template_renderer.rb#65
  def active_datadog_span=(_arg0); end

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/instrumentation/template_renderer.rb#67
  def with_datadog_span(span); end
end

# Rails >= 3.1, < 4 template rendering
# ActiveSupport events are used instead for Rails >= 4
#
# source://ddtrace//lib/datadog/tracing/contrib/action_view/instrumentation/template_renderer.rb#77
module Datadog::Tracing::Contrib::ActionView::Instrumentation::TemplateRenderer::RailsLessThan4
  include ::Datadog::Tracing::Contrib::ActionView::Instrumentation::TemplateRenderer::Rails31Plus

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/instrumentation/template_renderer.rb#80
  def datadog_parse_args(template, layout_name, *args); end
end

# Describes the ActionView integration
#
# source://ddtrace//lib/datadog/tracing/contrib/action_view/integration.rb#11
class Datadog::Tracing::Contrib::ActionView::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # enabled by rails integration so should only auto instrument
  # if detected that it is being used without rails
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/action_view/integration.rb#40
  def auto_instrument?; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/integration.rb#44
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/integration.rb#48
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/action_view/integration.rb#34
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/action_view/integration.rb#30
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_view/integration.rb#19
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/action_view/integration.rb#14
Datadog::Tracing::Contrib::ActionView::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of ActionView module.
#
# source://ddtrace//lib/datadog/tracing/contrib/action_view/patcher.rb#14
module Datadog::Tracing::Contrib::ActionView::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/patcher.rb#23
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/patcher.rb#27
  def patch_renderer; end

  # source://ddtrace//lib/datadog/tracing/contrib/action_view/patcher.rb#19
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_view/patcher.rb#27
    def patch_renderer; end

    # source://ddtrace//lib/datadog/tracing/contrib/action_view/patcher.rb#19
    def target_version; end
  end
end

# common utilities for Rails
#
# source://ddtrace//lib/datadog/tracing/contrib/action_view/utils.rb#8
module Datadog::Tracing::Contrib::ActionView::Utils
  private

  # in Rails the template name includes the template full path
  # and it's better to avoid storing such information. This method
  # returns the relative path from `views/` or the template name
  # if a `views/` folder is not in the template full path. A wrong
  # usage ensures that this method will not crash the tracing system.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/action_view/utils.rb#16
  def normalize_template_name(name); end

  class << self
    # in Rails the template name includes the template full path
    # and it's better to avoid storing such information. This method
    # returns the relative path from `views/` or the template name
    # if a `views/` folder is not in the template full path. A wrong
    # usage ensures that this method will not crash the tracing system.
    #
    # source://ddtrace//lib/datadog/tracing/contrib/action_view/utils.rb#16
    def normalize_template_name(name); end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#6
module Datadog::Tracing::Contrib::ActiveJob; end

# source://ddtrace//lib/datadog/tracing/contrib/active_job/configuration/settings.rb#11
module Datadog::Tracing::Contrib::ActiveJob::Configuration; end

# Custom settings for the DelayedJob integration
#
# source://ddtrace//lib/datadog/tracing/contrib/active_job/configuration/settings.rb#14
class Datadog::Tracing::Contrib::ActiveJob::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def error_handler; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def error_handler=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# Defines basic behaviors for an ActiveJob event.
#
# source://ddtrace//lib/datadog/tracing/contrib/active_job/event.rb#12
module Datadog::Tracing::Contrib::ActiveJob::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event

  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveJob::Event::ClassMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_job/event.rb#13
    def included(base); end
  end
end

# Class methods for ActiveJob events.
#
# source://ddtrace//lib/datadog/tracing/contrib/active_job/event.rb#19
module Datadog::Tracing::Contrib::ActiveJob::Event::ClassMethods
  # source://ddtrace//lib/datadog/tracing/contrib/active_job/event.rb#26
  def configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/event.rb#30
  def set_common_tags(span, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/event.rb#20
  def span_options; end
end

# Defines collection of instrumented ActiveJob events
#
# source://ddtrace//lib/datadog/tracing/contrib/active_job/events/discard.rb#10
module Datadog::Tracing::Contrib::ActiveJob::Events
  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/events.rb#27
  def all; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/events.rb#35
  def subscribe!; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/events.rb#31
  def subscriptions; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/active_job/events.rb#27
    def all; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_job/events.rb#35
    def subscribe!; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_job/events.rb#31
    def subscriptions; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_job/events.rb#16
Datadog::Tracing::Contrib::ActiveJob::Events::ALL = T.let(T.unsafe(nil), Array)

# Defines instrumentation for discard.active_job event
#
# source://ddtrace//lib/datadog/tracing/contrib/active_job/events/discard.rb#12
module Datadog::Tracing::Contrib::ActiveJob::Events::Discard
  include ::Datadog::Tracing::Contrib::ActiveJob::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveJob::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/discard.rb#19
  def event_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/discard.rb#27
  def process(span, event, _id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/discard.rb#23
  def span_name; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/discard.rb#19
    def event_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/discard.rb#27
    def process(span, event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/discard.rb#23
    def span_name; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_job/events/discard.rb#15
Datadog::Tracing::Contrib::ActiveJob::Events::Discard::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for enqueue.active_job event
#
# source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue.rb#12
module Datadog::Tracing::Contrib::ActiveJob::Events::Enqueue
  include ::Datadog::Tracing::Contrib::ActiveJob::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveJob::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue.rb#19
  def event_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue.rb#27
  def process(span, event, _id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue.rb#23
  def span_name; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue.rb#19
    def event_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue.rb#27
    def process(span, event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue.rb#23
    def span_name; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue.rb#15
Datadog::Tracing::Contrib::ActiveJob::Events::Enqueue::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for enqueue_at.active_job event
#
# source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue_at.rb#12
module Datadog::Tracing::Contrib::ActiveJob::Events::EnqueueAt
  include ::Datadog::Tracing::Contrib::ActiveJob::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveJob::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue_at.rb#19
  def event_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue_at.rb#27
  def process(span, event, _id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue_at.rb#23
  def span_name; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue_at.rb#19
    def event_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue_at.rb#27
    def process(span, event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue_at.rb#23
    def span_name; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue_at.rb#15
Datadog::Tracing::Contrib::ActiveJob::Events::EnqueueAt::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for enqueue_retry.active_job event
#
# source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue_retry.rb#12
module Datadog::Tracing::Contrib::ActiveJob::Events::EnqueueRetry
  include ::Datadog::Tracing::Contrib::ActiveJob::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveJob::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue_retry.rb#19
  def event_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue_retry.rb#27
  def process(span, event, _id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue_retry.rb#23
  def span_name; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue_retry.rb#19
    def event_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue_retry.rb#27
    def process(span, event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue_retry.rb#23
    def span_name; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_job/events/enqueue_retry.rb#15
Datadog::Tracing::Contrib::ActiveJob::Events::EnqueueRetry::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for perform.active_job event
#
# source://ddtrace//lib/datadog/tracing/contrib/active_job/events/perform.rb#12
module Datadog::Tracing::Contrib::ActiveJob::Events::Perform
  include ::Datadog::Tracing::Contrib::ActiveJob::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveJob::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/perform.rb#19
  def event_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/perform.rb#27
  def process(span, event, _id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/perform.rb#23
  def span_name; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/perform.rb#19
    def event_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/perform.rb#27
    def process(span, event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/perform.rb#23
    def span_name; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_job/events/perform.rb#15
Datadog::Tracing::Contrib::ActiveJob::Events::Perform::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for retry_stopped.active_job event
#
# source://ddtrace//lib/datadog/tracing/contrib/active_job/events/retry_stopped.rb#12
module Datadog::Tracing::Contrib::ActiveJob::Events::RetryStopped
  include ::Datadog::Tracing::Contrib::ActiveJob::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveJob::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/retry_stopped.rb#19
  def event_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/retry_stopped.rb#27
  def process(span, event, _id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/retry_stopped.rb#23
  def span_name; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/retry_stopped.rb#19
    def event_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/retry_stopped.rb#27
    def process(span, event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/active_job/events/retry_stopped.rb#23
    def span_name; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_job/events/retry_stopped.rb#15
Datadog::Tracing::Contrib::ActiveJob::Events::RetryStopped::EVENT_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#8
module Datadog::Tracing::Contrib::ActiveJob::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#10
Datadog::Tracing::Contrib::ActiveJob::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#11
Datadog::Tracing::Contrib::ActiveJob::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#9
Datadog::Tracing::Contrib::ActiveJob::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#13
Datadog::Tracing::Contrib::ActiveJob::Ext::SPAN_DISCARD = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#14
Datadog::Tracing::Contrib::ActiveJob::Ext::SPAN_ENQUEUE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#15
Datadog::Tracing::Contrib::ActiveJob::Ext::SPAN_ENQUEUE_RETRY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#16
Datadog::Tracing::Contrib::ActiveJob::Ext::SPAN_PERFORM = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#17
Datadog::Tracing::Contrib::ActiveJob::Ext::SPAN_RETRY_STOPPED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#27
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_ADAPTER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#19
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#28
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_JOB_ERROR = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#29
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_JOB_EXECUTIONS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#30
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_JOB_ID = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#31
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_JOB_PRIORITY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#32
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_JOB_QUEUE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#33
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_JOB_RETRY_WAIT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#34
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_JOB_SCHEDULED_AT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#20
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_OPERATION_DISCARD = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#21
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_OPERATION_ENQUEUE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#22
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_OPERATION_ENQUEUE_AT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#23
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_OPERATION_ENQUEUE_RETRY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#24
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_OPERATION_PERFORM = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_job/ext.rb#25
Datadog::Tracing::Contrib::ActiveJob::Ext::TAG_OPERATION_RETRY_STOPPED = T.let(T.unsafe(nil), String)

# Describes the ActiveJob integration
#
# source://ddtrace//lib/datadog/tracing/contrib/active_job/integration.rb#11
class Datadog::Tracing::Contrib::ActiveJob::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # enabled by rails integration so should only auto instrument
  # if detected that it is being used without rails
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_job/integration.rb#33
  def auto_instrument?; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/integration.rb#37
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/integration.rb#41
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_job/integration.rb#27
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_job/integration.rb#23
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_job/integration.rb#19
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_job/integration.rb#14
Datadog::Tracing::Contrib::ActiveJob::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Active Job log injection wrapped around job execution
#
# source://ddtrace//lib/datadog/tracing/contrib/active_job/log_injection.rb#8
module Datadog::Tracing::Contrib::ActiveJob::LogInjection
  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_job/log_injection.rb#9
    def included(base); end
  end
end

# Patcher enables patching of 'active_job' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/active_job/patcher.rb#13
module Datadog::Tracing::Contrib::ActiveJob::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/patcher.rb#27
  def inject_log_correlation; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/patcher.rb#22
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_job/patcher.rb#18
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/active_job/patcher.rb#27
    def inject_log_correlation; end

    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_job/patcher.rb#18
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/ext.rb#6
module Datadog::Tracing::Contrib::ActiveModelSerializers; end

# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/configuration/settings.rb#10
module Datadog::Tracing::Contrib::ActiveModelSerializers::Configuration; end

# Custom settings for the ActiveModelSerializers integration
#
# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/configuration/settings.rb#13
class Datadog::Tracing::Contrib::ActiveModelSerializers::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end
end

# Defines basic behaviors for an ActiveModelSerializers event.
#
# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/event.rb#13
module Datadog::Tracing::Contrib::ActiveModelSerializers::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event

  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveModelSerializers::Event::ClassMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/event.rb#14
    def included(base); end
  end
end

# Class methods for ActiveModelSerializers events.
# Note, they share the same process method and before_trace method.
#
# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/event.rb#21
module Datadog::Tracing::Contrib::ActiveModelSerializers::Event::ClassMethods
  # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/event.rb#26
  def configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/event.rb#30
  def set_common_tags(span, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/event.rb#22
  def span_options; end

  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/event.rb#54
  def resource(serializer); end
end

# Defines collection of instrumented ActiveModelSerializers events
#
# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events/render.rb#9
module Datadog::Tracing::Contrib::ActiveModelSerializers::Events
  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events.rb#19
  def all; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events.rb#27
  def subscribe!; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events.rb#23
  def subscriptions; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events.rb#19
    def all; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events.rb#27
    def subscribe!; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events.rb#23
    def subscriptions; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events.rb#12
Datadog::Tracing::Contrib::ActiveModelSerializers::Events::ALL = T.let(T.unsafe(nil), Array)

# Defines instrumentation for render.active_model_serializers event
#
# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events/render.rb#11
module Datadog::Tracing::Contrib::ActiveModelSerializers::Events::Render
  include ::Datadog::Tracing::Contrib::ActiveModelSerializers::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveModelSerializers::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events/render.rb#23
  def event_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events/render.rb#31
  def process(span, _event, _id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events/render.rb#27
  def span_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events/render.rb#18
  def supported?; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events/render.rb#23
    def event_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events/render.rb#31
    def process(span, _event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events/render.rb#27
    def span_name; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events/render.rb#18
    def supported?; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events/render.rb#14
Datadog::Tracing::Contrib::ActiveModelSerializers::Events::Render::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for !serialize.active_model_serializers event
#
# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events/serialize.rb#10
module Datadog::Tracing::Contrib::ActiveModelSerializers::Events::Serialize
  include ::Datadog::Tracing::Contrib::ActiveModelSerializers::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveModelSerializers::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events/serialize.rb#25
  def event_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events/serialize.rb#33
  def process(span, _event, _id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events/serialize.rb#29
  def span_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events/serialize.rb#17
  def supported?; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events/serialize.rb#25
    def event_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events/serialize.rb#33
    def process(span, _event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events/serialize.rb#29
    def span_name; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events/serialize.rb#17
    def supported?; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/events/serialize.rb#13
Datadog::Tracing::Contrib::ActiveModelSerializers::Events::Serialize::EVENT_NAME = T.let(T.unsafe(nil), String)

# ActiveModelSerializers integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/ext.rb#9
module Datadog::Tracing::Contrib::ActiveModelSerializers::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/ext.rb#11
Datadog::Tracing::Contrib::ActiveModelSerializers::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/ext.rb#12
Datadog::Tracing::Contrib::ActiveModelSerializers::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/ext.rb#10
Datadog::Tracing::Contrib::ActiveModelSerializers::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/ext.rb#13
Datadog::Tracing::Contrib::ActiveModelSerializers::Ext::SPAN_RENDER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/ext.rb#14
Datadog::Tracing::Contrib::ActiveModelSerializers::Ext::SPAN_SERIALIZE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/ext.rb#15
Datadog::Tracing::Contrib::ActiveModelSerializers::Ext::TAG_ADAPTER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/ext.rb#16
Datadog::Tracing::Contrib::ActiveModelSerializers::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/ext.rb#17
Datadog::Tracing::Contrib::ActiveModelSerializers::Ext::TAG_OPERATION_RENDER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/ext.rb#18
Datadog::Tracing::Contrib::ActiveModelSerializers::Ext::TAG_OPERATION_SERIALIZE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/ext.rb#19
Datadog::Tracing::Contrib::ActiveModelSerializers::Ext::TAG_SERIALIZER = T.let(T.unsafe(nil), String)

# Description of ActiveModelSerializers integration
#
# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/integration.rb#10
class Datadog::Tracing::Contrib::ActiveModelSerializers::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/integration.rb#32
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/integration.rb#36
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/integration.rb#28
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/integration.rb#23
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/integration.rb#18
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/integration.rb#13
Datadog::Tracing::Contrib::ActiveModelSerializers::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'active_model_serializers' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/patcher.rb#12
module Datadog::Tracing::Contrib::ActiveModelSerializers::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/patcher.rb#25
  def get_option(option); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/patcher.rb#21
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/patcher.rb#17
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/patcher.rb#25
    def get_option(option); end

    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_model_serializers/patcher.rb#17
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#10
module Datadog::Tracing::Contrib::ActiveRecord; end

# source://ddtrace//lib/datadog/tracing/contrib/active_record/configuration/makara_resolver.rb#5
module Datadog::Tracing::Contrib::ActiveRecord::Configuration; end

# The `makara` gem has the concept of **role**, which can be
# inferred from the configuration `name`, in the form of:
# `master/0`, `replica/0`, `replica/1`, etc.
# The first part of this string is the database role.
#
# This allows the matching of a connection based on its role,
# instead of connection-specific information.
#
# source://ddtrace//lib/datadog/tracing/contrib/active_record/configuration/makara_resolver.rb#13
module Datadog::Tracing::Contrib::ActiveRecord::Configuration::MakaraResolver
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/configuration/makara_resolver.rb#14
  def normalize_for_config(active_record_config); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/configuration/makara_resolver.rb#20
  def normalize_for_resolve(active_record_config); end
end

# Converts Symbols, Strings, and Hashes to a normalized connection settings Hash.
#
# When matching using a Hash, these are the valid fields:
# ```
# {
#   adapter: ...,
#   host: ...,
#   port: ...,
#   database: ...,
#   username: ...,
#   role: ...,
# }
# ```
#
# Partial matching is supported: not including certain fields or setting them to `nil`
# will cause them to matching all values for that field. For example: `database: nil`
# will match any database, given the remaining fields match.
#
# Any fields not listed above are discarded.
#
# When more than one configuration could be matched, the last one to match is selected,
# based on addition order (`#add`).
#
# source://ddtrace//lib/datadog/tracing/contrib/active_record/configuration/resolver.rb#32
class Datadog::Tracing::Contrib::ActiveRecord::Configuration::Resolver < ::Datadog::Tracing::Contrib::Configuration::Resolver
  include ::Datadog::Tracing::Contrib::ActiveRecord::Configuration::MakaraResolver

  # @return [Resolver] a new instance of Resolver
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/configuration/resolver.rb#35
  def initialize(active_record_configuration = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/configuration/resolver.rb#41
  def active_record_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/configuration/resolver.rb#45
  def add(matcher, value); end

  # Extract only fields we'd like to match
  # from the ActiveRecord configuration.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/configuration/makara_resolver.rb#14
  def normalize_for_config(active_record_config); end

  # Extract only fields we'd like to match
  # from the ActiveRecord configuration.
  # Both resolvers perform the same operations for this implementation, but can be specialized
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/configuration/makara_resolver.rb#20
  def normalize_for_resolve(active_record_config); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/configuration/resolver.rb#54
  def resolve(db_config); end

  protected

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/configuration/resolver.rb#93
  def connection_resolver; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/configuration/resolver.rb#78
  def parse_matcher(matcher); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/configuration/resolver.rb#107
  def resolve_connection_key(key); end
end

# Custom settings for the ActiveRecord integration
#
# source://ddtrace//lib/datadog/tracing/contrib/active_record/configuration/settings.rb#14
class Datadog::Tracing::Contrib::ActiveRecord::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# Defines basic behaviors for an ActiveRecord event.
#
# source://ddtrace//lib/datadog/tracing/contrib/active_record/event.rb#10
module Datadog::Tracing::Contrib::ActiveRecord::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event

  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveRecord::Event::ClassMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_record/event.rb#11
    def included(base); end
  end
end

# Class methods for ActiveRecord events.
#
# source://ddtrace//lib/datadog/tracing/contrib/active_record/event.rb#17
module Datadog::Tracing::Contrib::ActiveRecord::Event::ClassMethods
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/event.rb#22
  def configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/event.rb#18
  def span_options; end
end

# Defines collection of instrumented ActiveRecord events
#
# source://ddtrace//lib/datadog/tracing/contrib/active_record/events/instantiation.rb#10
module Datadog::Tracing::Contrib::ActiveRecord::Events
  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/events.rb#19
  def all; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/events.rb#27
  def subscribe!; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/events.rb#23
  def subscriptions; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/active_record/events.rb#19
    def all; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_record/events.rb#27
    def subscribe!; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_record/events.rb#23
    def subscriptions; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_record/events.rb#12
Datadog::Tracing::Contrib::ActiveRecord::Events::ALL = T.let(T.unsafe(nil), Array)

# Defines instrumentation for instantiation.active_record event
#
# source://ddtrace//lib/datadog/tracing/contrib/active_record/events/instantiation.rb#12
module Datadog::Tracing::Contrib::ActiveRecord::Events::Instantiation
  include ::Datadog::Tracing::Contrib::ActiveRecord::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveRecord::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/events/instantiation.rb#24
  def event_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/events/instantiation.rb#32
  def process(span, event, _id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/events/instantiation.rb#28
  def span_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/events/instantiation.rb#19
  def supported?; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/active_record/events/instantiation.rb#24
    def event_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_record/events/instantiation.rb#32
    def process(span, event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/active_record/events/instantiation.rb#28
    def span_name; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_record/events/instantiation.rb#19
    def supported?; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_record/events/instantiation.rb#15
Datadog::Tracing::Contrib::ActiveRecord::Events::Instantiation::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for sql.active_record event
#
# source://ddtrace//lib/datadog/tracing/contrib/active_record/events/sql.rb#14
module Datadog::Tracing::Contrib::ActiveRecord::Events::SQL
  include ::Datadog::Tracing::Contrib::ActiveRecord::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveRecord::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/events/sql.rb#22
  def event_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/events/sql.rb#30
  def process(span, event, _id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/events/sql.rb#26
  def span_name; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/active_record/events/sql.rb#22
    def event_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_record/events/sql.rb#30
    def process(span, event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/active_record/events/sql.rb#26
    def span_name; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_record/events/sql.rb#17
Datadog::Tracing::Contrib::ActiveRecord::Events::SQL::EVENT_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_record/events/sql.rb#18
Datadog::Tracing::Contrib::ActiveRecord::Events::SQL::PAYLOAD_CACHE = T.let(T.unsafe(nil), String)

# ActiveRecord integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/active_record/ext.rb#9
module Datadog::Tracing::Contrib::ActiveRecord::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/active_record/ext.rb#11
Datadog::Tracing::Contrib::ActiveRecord::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_record/ext.rb#12
Datadog::Tracing::Contrib::ActiveRecord::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_record/ext.rb#10
Datadog::Tracing::Contrib::ActiveRecord::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_record/ext.rb#13
Datadog::Tracing::Contrib::ActiveRecord::Ext::SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_record/ext.rb#14
Datadog::Tracing::Contrib::ActiveRecord::Ext::SPAN_INSTANTIATION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_record/ext.rb#15
Datadog::Tracing::Contrib::ActiveRecord::Ext::SPAN_SQL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_record/ext.rb#16
Datadog::Tracing::Contrib::ActiveRecord::Ext::SPAN_TYPE_INSTANTIATION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_record/ext.rb#17
Datadog::Tracing::Contrib::ActiveRecord::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_record/ext.rb#20
Datadog::Tracing::Contrib::ActiveRecord::Ext::TAG_DB_CACHED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_record/ext.rb#21
Datadog::Tracing::Contrib::ActiveRecord::Ext::TAG_DB_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_record/ext.rb#22
Datadog::Tracing::Contrib::ActiveRecord::Ext::TAG_DB_VENDOR = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_record/ext.rb#23
Datadog::Tracing::Contrib::ActiveRecord::Ext::TAG_INSTANTIATION_CLASS_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_record/ext.rb#24
Datadog::Tracing::Contrib::ActiveRecord::Ext::TAG_INSTANTIATION_RECORD_COUNT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_record/ext.rb#18
Datadog::Tracing::Contrib::ActiveRecord::Ext::TAG_OPERATION_INSTANTIATION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_record/ext.rb#19
Datadog::Tracing::Contrib::ActiveRecord::Ext::TAG_OPERATION_SQL = T.let(T.unsafe(nil), String)

# Describes the ActiveRecord integration
#
# source://ddtrace//lib/datadog/tracing/contrib/active_record/integration.rb#13
class Datadog::Tracing::Contrib::ActiveRecord::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # enabled by rails integration so should only auto instrument
  # if detected that it is being used without rails
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/integration.rb#35
  def auto_instrument?; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/integration.rb#39
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/integration.rb#43
  def patcher; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/integration.rb#47
  def resolver; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_record/integration.rb#29
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_record/integration.rb#25
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_record/integration.rb#21
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_record/integration.rb#16
Datadog::Tracing::Contrib::ActiveRecord::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'active_record' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/active_record/patcher.rb#11
module Datadog::Tracing::Contrib::ActiveRecord::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/patcher.rb#20
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/patcher.rb#16
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_record/patcher.rb#16
    def target_version; end
  end
end

# Common utilities for Rails
#
# source://ddtrace//lib/datadog/tracing/contrib/active_record/utils.rb#9
module Datadog::Tracing::Contrib::ActiveRecord::Utils
  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/active_record/utils.rb#20
    def adapter_host; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_record/utils.rb#12
    def adapter_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_record/utils.rb#24
    def adapter_port; end

    # Returns the connection configuration hash from the
    # current connection
    #
    # Since Rails 6.0, we have direct access to the object,
    # while older versions of Rails only provide us the
    # connection id.
    #
    # @see https://github.com/rails/rails/pull/34602
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_record/utils.rb#36
    def connection_config(connection = T.unsafe(nil), connection_id = T.unsafe(nil)); end

    # JRuby does not enable {ObjectSpace._id2ref} by default,
    # as it has large performance impact:
    # https://github.com/jruby/jruby/wiki/PerformanceTuning/cf155dd9#dont-enable-objectspace
    #
    # This fallback code does not support the makara gem,
    # as its connections don't live in the ActiveRecord
    # connection pool.
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_record/utils.rb#62
    def connection_from_id(connection_id); end

    # source://ddtrace//lib/datadog/tracing/contrib/active_record/utils.rb#16
    def database_name; end

    # @return [Hash]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_record/utils.rb#115
    def db_config(connection_pool); end

    # @return [Hash]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_record/utils.rb#99
    def default_connection_config; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_record/utils.rb#10
Datadog::Tracing::Contrib::ActiveRecord::Utils::EMPTY_CONFIG = T.let(T.unsafe(nil), Hash)

# source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#11
module Datadog::Tracing::Contrib::ActiveRecord::Vendor; end

# Copy/paste from:
# https://github.com/rails/rails/blob/5-2-stable/activerecord/lib/active_record/connection_adapters/connection_specification.rb
#
# source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#20
module Datadog::Tracing::Contrib::ActiveRecord::Vendor::ConnectionAdapters; end

# source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#21
class Datadog::Tracing::Contrib::ActiveRecord::Vendor::ConnectionAdapters::ConnectionSpecification
  # @return [ConnectionSpecification] a new instance of ConnectionSpecification
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#24
  def initialize(name, config, adapter_method); end

  # Returns the value of attribute adapter_method.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#22
  def adapter_method; end

  # Returns the value of attribute config.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#22
  def config; end

  # Returns the value of attribute name.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#22
  def name; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#32
  def to_hash; end

  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#28
  def initialize_dup(original); end
end

# Expands a connection string into a hash.
#
# source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#37
class Datadog::Tracing::Contrib::ActiveRecord::Vendor::ConnectionAdapters::ConnectionSpecification::ConnectionUrlResolver
  # == Example
  #
  #   url = "postgresql://foo:bar@localhost:9000/foo_test?pool=5&timeout=3000"
  #   ConnectionUrlResolver.new(url).to_hash
  #   # => {
  #     "adapter"  => "postgresql",
  #     "host"     => "localhost",
  #     "port"     => 9000,
  #     "database" => "foo_test",
  #     "username" => "foo",
  #     "password" => "bar",
  #     "pool"     => "5",
  #     "timeout"  => "3000"
  #   }
  #
  # @return [ConnectionUrlResolver] a new instance of ConnectionUrlResolver
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#52
  def initialize(url); end

  # Converts the given URL to a full connection hash.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#66
  def to_hash; end

  private

  # Returns name of the database.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#112
  def database_from_path; end

  # Converts the query parameters of the URI into a hash.
  #
  #   "localhost?pool=5&reaping_frequency=2"
  #   # => { "pool" => "5", "reaping_frequency" => "2" }
  #
  # returns empty hash if no query present.
  #
  #   "localhost"
  #   # => {}
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#91
  def query_hash; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#95
  def raw_config; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#74
  def uri; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#78
  def uri_parser; end
end

# Builds a ConnectionSpecification from user input.
#
# source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#130
class Datadog::Tracing::Contrib::ActiveRecord::Vendor::ConnectionAdapters::ConnectionSpecification::Resolver
  # Accepts a hash two layers deep, keys on the first layer represent
  # environments such as "production". Keys must be strings.
  #
  # @return [Resolver] a new instance of Resolver
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#135
  def initialize(configurations); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#131
  def configurations; end

  # Returns a hash with database connection information.
  #
  # == Examples
  #
  # Full hash Configuration.
  #
  #   configurations = { "production" => { "host" => "localhost", "database" => "foo", "adapter" => "sqlite3" } }
  #   Resolver.new(configurations).resolve(:production)
  #   # => { "host" => "localhost", "database" => "foo", "adapter" => "sqlite3"}
  #
  # Initialized with URL configuration strings.
  #
  #   configurations = { "production" => "postgresql://localhost/foo" }
  #   Resolver.new(configurations).resolve(:production)
  #   # => { "host" => "localhost", "database" => "foo", "adapter" => "postgresql" }
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#155
  def resolve(config); end

  # Expands each key in @configurations hash into fully resolved hash
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#166
  def resolve_all; end

  # Returns an instance of ConnectionSpecification for a given adapter.
  # Accepts a hash one layer deep that contains all connection information.
  #
  # == Example
  #
  #   config = { "production" => { "host" => "localhost", "database" => "foo", "adapter" => "sqlite3" } }
  #   spec = Resolver.new(config).spec(:production)
  #   spec.adapter_method
  #   # => "sqlite3_connection"
  #   spec.config
  #   # => { "host" => "localhost", "database" => "foo", "adapter" => "sqlite3" }
  #
  # @raise [AdapterNotSpecified]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#195
  def spec(config); end

  private

  # Returns fully resolved connection, accepts hash, string or symbol.
  # Always returns a hash.
  #
  # == Examples
  #
  # Symbol representing current environment.
  #
  #   Resolver.new("production" => {}).resolve_connection(:production)
  #   # => {}
  #
  # One layer deep hash of connection values.
  #
  #   Resolver.new({}).resolve_connection("adapter" => "sqlite3")
  #   # => { "adapter" => "sqlite3" }
  #
  # Connection URL.
  #
  #   Resolver.new({}).resolve_connection("postgresql://localhost/foo")
  #   # => { "host" => "localhost", "database" => "foo", "adapter" => "postgresql" }
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#252
  def resolve_connection(spec); end

  # Accepts a hash. Expands the "url" key that contains a
  # URL database connection to a full connection
  # hash and merges with the rest of the hash.
  # Connection details inside of the "url" key win any merge conflicts
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#282
  def resolve_hash_connection(spec); end

  # Takes the environment such as +:production+ or +:development+.
  # This requires that the @configurations was initialized with a key that
  # matches.
  #
  #   Resolver.new("production" => {}).resolve_symbol_connection(:production)
  #   # => {}
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#270
  def resolve_symbol_connection(spec); end

  # Takes a connection URL.
  #
  #   Resolver.new({}).resolve_url_connection("postgresql://localhost/foo")
  #   # => { "host" => "localhost", "database" => "foo", "adapter" => "postgresql" }
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#295
  def resolve_url_connection(url); end
end

# Copy/paste from:
# https://github.com/rails/rails/blob/5-2-stable/activerecord/lib/active_record/connection_handling.rb
#
# source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#14
module Datadog::Tracing::Contrib::ActiveRecord::Vendor::ConnectionHandling; end

# source://ddtrace//lib/datadog/tracing/contrib/active_record/vendor/connection_specification.rb#15
Datadog::Tracing::Contrib::ActiveRecord::Vendor::ConnectionHandling::RAILS_ENV = T.let(T.unsafe(nil), Proc)

# source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#4
module Datadog::Tracing::Contrib::ActiveSupport; end

# source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#11
module Datadog::Tracing::Contrib::ActiveSupport::Cache; end

# Defines instrumentation for ActiveSupport caching
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#14
module Datadog::Tracing::Contrib::ActiveSupport::Cache::Instrumentation
  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#105
  def enabled?; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#50
  def finish_trace_cache(payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#77
  def finish_trace_cache_multi(payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#17
  def start_trace_cache(payload); end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#105
    def enabled?; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#50
    def finish_trace_cache(payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#77
    def finish_trace_cache_multi(payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#17
    def start_trace_cache(payload); end
  end
end

# Defines instrumentation for ActiveSupport cache deleting
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#250
module Datadog::Tracing::Contrib::ActiveSupport::Cache::Instrumentation::Delete
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#251
  def delete(*args, &block); end
end

# Defines instrumentation for ActiveSupport cache fetching
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#156
module Datadog::Tracing::Contrib::ActiveSupport::Cache::Instrumentation::Fetch
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#157
  def fetch(*args, &block); end
end

# Defines instrumentation for ActiveSupport cache fetching of multiple keys
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#179
module Datadog::Tracing::Contrib::ActiveSupport::Cache::Instrumentation::FetchMulti
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#180
  def fetch_multi(*args, &block); end
end

# Defines instrumentation for ActiveSupport cache reading
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#110
module Datadog::Tracing::Contrib::ActiveSupport::Cache::Instrumentation::Read
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#111
  def read(*args, &block); end
end

# Defines instrumentation for ActiveSupport cache reading of multiple keys
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#133
module Datadog::Tracing::Contrib::ActiveSupport::Cache::Instrumentation::ReadMulti
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#134
  def read_multi(*keys, &block); end
end

# Defines instrumentation for ActiveSupport cache writing
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#204
module Datadog::Tracing::Contrib::ActiveSupport::Cache::Instrumentation::Write
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#205
  def write(*args, &block); end
end

# Defines instrumentation for ActiveSupport cache writing of multiple keys
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#227
module Datadog::Tracing::Contrib::ActiveSupport::Cache::Instrumentation::WriteMulti
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/instrumentation.rb#228
  def write_multi(hash, options = T.unsafe(nil)); end
end

# Patcher enables patching of 'active_support' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#12
module Datadog::Tracing::Contrib::ActiveSupport::Cache::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Cache::Redis::Patcher

  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#31
  def cache_store_class(meth); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#21
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#65
  def patch_cache_store_delete; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#43
  def patch_cache_store_fetch; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#47
  def patch_cache_store_fetch_multi; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#35
  def patch_cache_store_read; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#39
  def patch_cache_store_read_multi; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#54
  def patch_cache_store_write; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#58
  def patch_cache_store_write_multi; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#17
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/redis.rb#31
    def cache_store_class(meth); end

    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#65
    def patch_cache_store_delete; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#43
    def patch_cache_store_fetch; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#47
    def patch_cache_store_fetch_multi; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#35
    def patch_cache_store_read; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#39
    def patch_cache_store_read_multi; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#54
    def patch_cache_store_write; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#58
    def patch_cache_store_write_multi; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/patcher.rb#17
    def target_version; end
  end
end

# Support for Redis with ActiveSupport
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/redis.rb#11
module Datadog::Tracing::Contrib::ActiveSupport::Cache::Redis; end

# Patching behavior for Redis with ActiveSupport
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/redis.rb#13
module Datadog::Tracing::Contrib::ActiveSupport::Cache::Redis::Patcher
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/redis.rb#31
  def cache_store_class(meth); end

  # For Rails < 5.2 w/ redis-activesupport...
  # When Redis is used, we can't only patch Cache::Store as it is
  # Cache::RedisStore, a sub-class of it that is used, in practice.
  # We need to do a per-method monkey patching as some of them might
  # be redefined, and some of them not. The latest version of redis-activesupport
  # redefines write but leaves untouched read and delete:
  # https://github.com/redis-store/redis-activesupport/blob/v4.1.5/lib/active_support/cache/redis_store.rb
  #
  # For Rails >= 5.2 w/o redis-activesupport...
  # ActiveSupport includes a Redis cache store internally, and does not require these overrides.
  # https://github.com/rails/rails/blob/master/activesupport/lib/active_support/cache/redis_cache_store.rb
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/cache/redis.rb#25
  def patch_redis?(meth); end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_support/configuration/settings.rb#10
module Datadog::Tracing::Contrib::ActiveSupport::Configuration; end

# Custom settings for the ActiveSupport integration
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/configuration/settings.rb#13
class Datadog::Tracing::Contrib::ActiveSupport::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def cache_service; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def cache_service=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end
end

# ActiveSupport integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/ext.rb#9
module Datadog::Tracing::Contrib::ActiveSupport::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/active_support/ext.rb#11
Datadog::Tracing::Contrib::ActiveSupport::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_support/ext.rb#12
Datadog::Tracing::Contrib::ActiveSupport::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_support/ext.rb#10
Datadog::Tracing::Contrib::ActiveSupport::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_support/ext.rb#13
Datadog::Tracing::Contrib::ActiveSupport::Ext::QUANTIZE_CACHE_MAX_KEY_SIZE = T.let(T.unsafe(nil), Integer)

# source://ddtrace//lib/datadog/tracing/contrib/active_support/ext.rb#14
Datadog::Tracing::Contrib::ActiveSupport::Ext::RESOURCE_CACHE_DELETE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_support/ext.rb#15
Datadog::Tracing::Contrib::ActiveSupport::Ext::RESOURCE_CACHE_GET = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_support/ext.rb#16
Datadog::Tracing::Contrib::ActiveSupport::Ext::RESOURCE_CACHE_MGET = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_support/ext.rb#18
Datadog::Tracing::Contrib::ActiveSupport::Ext::RESOURCE_CACHE_MSET = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_support/ext.rb#17
Datadog::Tracing::Contrib::ActiveSupport::Ext::RESOURCE_CACHE_SET = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_support/ext.rb#19
Datadog::Tracing::Contrib::ActiveSupport::Ext::SERVICE_CACHE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_support/ext.rb#20
Datadog::Tracing::Contrib::ActiveSupport::Ext::SPAN_CACHE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_support/ext.rb#21
Datadog::Tracing::Contrib::ActiveSupport::Ext::SPAN_TYPE_CACHE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_support/ext.rb#22
Datadog::Tracing::Contrib::ActiveSupport::Ext::TAG_CACHE_BACKEND = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_support/ext.rb#23
Datadog::Tracing::Contrib::ActiveSupport::Ext::TAG_CACHE_KEY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_support/ext.rb#24
Datadog::Tracing::Contrib::ActiveSupport::Ext::TAG_CACHE_KEY_MULTI = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_support/ext.rb#25
Datadog::Tracing::Contrib::ActiveSupport::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/active_support/ext.rb#26
Datadog::Tracing::Contrib::ActiveSupport::Ext::TAG_OPERATION_CACHE = T.let(T.unsafe(nil), String)

# Describes the ActiveSupport integration
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/integration.rb#12
class Datadog::Tracing::Contrib::ActiveSupport::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # enabled by rails integration so should only auto instrument
  # if detected that it is being used without rails
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/integration.rb#34
  def auto_instrument?; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/integration.rb#38
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/integration.rb#42
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_support/integration.rb#28
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_support/integration.rb#24
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_support/integration.rb#20
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/active_support/integration.rb#15
Datadog::Tracing::Contrib::ActiveSupport::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#5
module Datadog::Tracing::Contrib::ActiveSupport::Notifications; end

# Defines behaviors for an ActiveSupport::Notifications event.
# Compose this into a module or class, then define
# #event_name, #span_name, and #process. You can then
# invoke Event.subscribe! to more easily subscribe to an event.
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/event.rb#14
module Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber

  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/event.rb#15
    def included(base); end
  end
end

# Redefines some class behaviors for a Subscriber to make
# it a bit simpler for an Event.
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/event.rb#23
module Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/event.rb#61
  def payload_exception(payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/event.rb#56
  def report_if_exception(span, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/event.rb#52
  def span_options; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/event.rb#37
  def subscribe(pattern = T.unsafe(nil), span_name = T.unsafe(nil), options = T.unsafe(nil)); end

  # Publicly exposes protected method `subscribe!`
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/event.rb#25
  def subscribe!; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/event.rb#29
  def subscription(span_name = T.unsafe(nil), options = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/event.rb#48
  def supported?; end
end

# For classes that listen to ActiveSupport::Notification events.
# Creates subscriptions that are wrapped with tracing.
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscriber.rb#13
module Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscriber.rb#14
    def included(base); end
  end
end

# Class methods that are implemented in the inheriting class.
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscriber.rb#19
module Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  # Returns whether subscriptions have been activated, via #subscribe!
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscriber.rb#26
  def subscribed?; end

  # Returns a list of subscriptions created for this class.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscriber.rb#21
  def subscriptions; end

  protected

  # Defines a callback for when subscribe! is called.
  # Should contain subscription setup, defined by the inheriting class.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscriber.rb#34
  def on_subscribe(&block); end

  # Creates a subscription and immediately activates it.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscriber.rb#48
  def subscribe(pattern, span_name, options = T.unsafe(nil), &block); end

  # Runs the on_subscribe callback once, to activate subscriptions.
  # Should be triggered by the inheriting class.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscriber.rb#40
  def subscribe!; end

  # Creates a subscription without activating it.
  # Subscription is added to the inheriting class' list of subscriptions.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscriber.rb#56
  def subscription(span_name, options = T.unsafe(nil), &block); end

  private

  # Returns the value of attribute on_subscribe_block.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscriber.rb#64
  def on_subscribe_block; end

  # Returns the value of attribute subscribed.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscriber.rb#64
  def subscribed; end
end

# An ActiveSupport::Notification subscription that wraps events with tracing.
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#7
class Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscription
  # @raise [ArgumentError]
  # @return [Subscription] a new instance of Subscription
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#12
  def initialize(span_name, options, &block); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#41
  def after_trace(&block); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#37
  def before_trace(&block); end

  # ActiveSupport 3.x calls this
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#22
  def call(name, start, finish, id, payload); end

  # ActiveSupport 4+ calls this on finish
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#33
  def finish(name, id, payload); end

  # Returns the value of attribute options.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#8
  def options; end

  # Sets the attribute options
  #
  # @param value the value to set the attribute options to.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#8
  def options=(_arg0); end

  # Returns the value of attribute span_name.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#8
  def span_name; end

  # Sets the attribute span_name
  #
  # @param value the value to set the attribute span_name to.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#8
  def span_name=(_arg0); end

  # ActiveSupport 4+ calls this on start
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#28
  def start(name, id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#45
  def subscribe(pattern); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#52
  def unsubscribe(pattern); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#60
  def unsubscribe_all; end

  protected

  # Returns the value of attribute callbacks.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#69
  def callbacks; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#85
  def finish_span(name, id, payload, finish = T.unsafe(nil)); end

  # Returns the value of attribute handler.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#69
  def handler; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#73
  def start_span(name, id, payload, start = T.unsafe(nil)); end

  # Pattern => ActiveSupport:Notifications::Subscribers
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#102
  def subscribers; end
end

# Wrapper for subscription callbacks
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#128
class Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscription::Callbacks
  # @return [Callbacks] a new instance of Callbacks
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#131
  def initialize; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#135
  def add(key, &block); end

  # Returns the value of attribute blocks.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#129
  def blocks; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#139
  def run(event, key, *args); end

  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#153
  def blocks_for(key); end
end

# Wrapper for subscription handler
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#107
class Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscription::Handler
  # @return [Handler] a new instance of Handler
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#110
  def initialize(&block); end

  # Returns the value of attribute block.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#108
  def block; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#114
  def run(span, name, id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/notifications/subscription.rb#122
  def run!(*args); end
end

# Patcher enables patching of 'active_support' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/active_support/patcher.rb#11
module Datadog::Tracing::Contrib::ActiveSupport::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/patcher.rb#20
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/active_support/patcher.rb#16
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/active_support/patcher.rb#16
    def target_version; end
  end
end

# Defines analytics behavior for integrations
#
# source://ddtrace//lib/datadog/tracing/contrib/analytics.rb#10
module Datadog::Tracing::Contrib::Analytics
  private

  # Checks whether analytics should be enabled.
  # `flag` is a truthy/falsey value that represents a setting on the integration.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/analytics.rb#15
  def enabled?(flag = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/contrib/analytics.rb#23
  def set_measured(span, value = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/contrib/analytics.rb#19
  def set_sample_rate(span, sample_rate); end

  class << self
    # Checks whether analytics should be enabled.
    # `flag` is a truthy/falsey value that represents a setting on the integration.
    #
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/analytics.rb#15
    def enabled?(flag = T.unsafe(nil)); end

    # source://ddtrace//lib/datadog/tracing/contrib/analytics.rb#23
    def set_measured(span, value = T.unsafe(nil)); end

    # source://ddtrace//lib/datadog/tracing/contrib/analytics.rb#19
    def set_sample_rate(span, sample_rate); end
  end
end

# Extensions for auto instrumentation added to the base library
# AutoInstrumentation enables all integration
#
# source://ddtrace//lib/datadog/tracing/contrib/auto_instrument.rb#24
module Datadog::Tracing::Contrib::AutoInstrument
  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/auto_instrument.rb#25
    def patch_all!; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#6
module Datadog::Tracing::Contrib::Aws; end

# source://ddtrace//lib/datadog/tracing/contrib/aws/configuration/settings.rb#11
module Datadog::Tracing::Contrib::Aws::Configuration; end

# Custom settings for the AWS integration
#
# source://ddtrace//lib/datadog/tracing/contrib/aws/configuration/settings.rb#14
class Datadog::Tracing::Contrib::Aws::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def peer_service; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def peer_service=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# AWS integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#9
module Datadog::Tracing::Contrib::Aws::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#15
Datadog::Tracing::Contrib::Aws::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#13
Datadog::Tracing::Contrib::Aws::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#14
Datadog::Tracing::Contrib::Aws::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#10
Datadog::Tracing::Contrib::Aws::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#12
Datadog::Tracing::Contrib::Aws::Ext::ENV_PEER_SERVICE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#11
Datadog::Tracing::Contrib::Aws::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#35
Datadog::Tracing::Contrib::Aws::Ext::PEER_SERVICE_SOURCES = T.let(T.unsafe(nil), Array)

# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#16
Datadog::Tracing::Contrib::Aws::Ext::SPAN_COMMAND = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#17
Datadog::Tracing::Contrib::Aws::Ext::TAG_AGENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#27
Datadog::Tracing::Contrib::Aws::Ext::TAG_AWS_ACCOUNT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#24
Datadog::Tracing::Contrib::Aws::Ext::TAG_AWS_REGION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#26
Datadog::Tracing::Contrib::Aws::Ext::TAG_AWS_SERVICE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#34
Datadog::Tracing::Contrib::Aws::Ext::TAG_BUCKET_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#18
Datadog::Tracing::Contrib::Aws::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#19
Datadog::Tracing::Contrib::Aws::Ext::TAG_DEFAULT_AGENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#20
Datadog::Tracing::Contrib::Aws::Ext::TAG_HOST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#21
Datadog::Tracing::Contrib::Aws::Ext::TAG_OPERATION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#22
Datadog::Tracing::Contrib::Aws::Ext::TAG_OPERATION_COMMAND = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#23
Datadog::Tracing::Contrib::Aws::Ext::TAG_PATH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#28
Datadog::Tracing::Contrib::Aws::Ext::TAG_QUEUE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#25
Datadog::Tracing::Contrib::Aws::Ext::TAG_REGION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#32
Datadog::Tracing::Contrib::Aws::Ext::TAG_RULE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#33
Datadog::Tracing::Contrib::Aws::Ext::TAG_STATE_MACHINE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#31
Datadog::Tracing::Contrib::Aws::Ext::TAG_STREAM_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#30
Datadog::Tracing::Contrib::Aws::Ext::TAG_TABLE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/aws/ext.rb#29
Datadog::Tracing::Contrib::Aws::Ext::TAG_TOPIC_NAME = T.let(T.unsafe(nil), String)

# Description of AWS integration
#
# source://ddtrace//lib/datadog/tracing/contrib/aws/integration.rb#10
class Datadog::Tracing::Contrib::Aws::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/aws/integration.rb#34
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/aws/integration.rb#38
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/aws/integration.rb#30
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/aws/integration.rb#26
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/aws/integration.rb#18
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/aws/integration.rb#13
Datadog::Tracing::Contrib::Aws::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'aws' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/aws/patcher.rb#11
module Datadog::Tracing::Contrib::Aws::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/aws/patcher.rb#32
  def add_plugin(*targets); end

  # source://ddtrace//lib/datadog/tracing/contrib/aws/patcher.rb#50
  def get_option(option); end

  # source://ddtrace//lib/datadog/tracing/contrib/aws/patcher.rb#36
  def loaded_constants; end

  # source://ddtrace//lib/datadog/tracing/contrib/aws/patcher.rb#20
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/aws/patcher.rb#16
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/aws/patcher.rb#32
    def add_plugin(*targets); end

    # source://ddtrace//lib/datadog/tracing/contrib/aws/patcher.rb#50
    def get_option(option); end

    # source://ddtrace//lib/datadog/tracing/contrib/aws/patcher.rb#36
    def loaded_constants; end

    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/aws/patcher.rb#16
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/concurrent_ruby/patcher.rb#8
module Datadog::Tracing::Contrib::ConcurrentRuby; end

# source://ddtrace//lib/datadog/tracing/contrib/concurrent_ruby/configuration/settings.rb#10
module Datadog::Tracing::Contrib::ConcurrentRuby::Configuration; end

# Custom settings for the ConcurrentRuby integration
#
# source://ddtrace//lib/datadog/tracing/contrib/concurrent_ruby/configuration/settings.rb#13
class Datadog::Tracing::Contrib::ConcurrentRuby::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end
end

# ConcurrentRuby integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/concurrent_ruby/ext.rb#9
module Datadog::Tracing::Contrib::ConcurrentRuby::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/concurrent_ruby/ext.rb#10
Datadog::Tracing::Contrib::ConcurrentRuby::Ext::APP = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/concurrent_ruby/ext.rb#11
Datadog::Tracing::Contrib::ConcurrentRuby::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# Describes the ConcurrentRuby integration
#
# source://ddtrace//lib/datadog/tracing/contrib/concurrent_ruby/integration.rb#10
class Datadog::Tracing::Contrib::ConcurrentRuby::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/concurrent_ruby/integration.rb#30
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/concurrent_ruby/integration.rb#34
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/concurrent_ruby/integration.rb#26
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/concurrent_ruby/integration.rb#22
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/concurrent_ruby/integration.rb#18
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/concurrent_ruby/integration.rb#13
Datadog::Tracing::Contrib::ConcurrentRuby::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'Future' class.
#
# source://ddtrace//lib/datadog/tracing/contrib/concurrent_ruby/patcher.rb#10
module Datadog::Tracing::Contrib::ConcurrentRuby::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/concurrent_ruby/patcher.rb#19
  def patch; end

  # Propagate tracing context in Concurrent::Future
  #
  # source://ddtrace//lib/datadog/tracing/contrib/concurrent_ruby/patcher.rb#25
  def patch_future; end

  # source://ddtrace//lib/datadog/tracing/contrib/concurrent_ruby/patcher.rb#15
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # Propagate tracing context in Concurrent::Future
    #
    # source://ddtrace//lib/datadog/tracing/contrib/concurrent_ruby/patcher.rb#25
    def patch_future; end

    # source://ddtrace//lib/datadog/tracing/contrib/concurrent_ruby/patcher.rb#15
    def target_version; end
  end
end

# Defines configurable behavior for integrations.
#
# This module is responsible for coordination between
# the configuration resolver and default configuration
# fallback.
#
# source://ddtrace//lib/datadog/tracing/contrib/configurable.rb#14
module Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/configurable.rb#15
    def included(base); end
  end
end

# Configurable instance behavior for integrations
#
# source://ddtrace//lib/datadog/tracing/contrib/configurable.rb#20
module Datadog::Tracing::Contrib::Configurable::InstanceMethods
  # Get matching configuration by matcher.
  # If no match, returns the default configuration instance.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/configurable.rb#23
  def configuration(matcher = T.unsafe(nil)); end

  # Returns all registered matchers and their respective configurations.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/configurable.rb#38
  def configurations; end

  # Create or update configuration associated with `matcher` with
  # the provided `options` and `&block`.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/configurable.rb#44
  def configure(matcher = T.unsafe(nil), options = T.unsafe(nil), &block); end

  # Returns the integration-specific configuration object.
  #
  # If one does not exist, invoke {.new_configuration} a memoize
  # its value.
  #
  # @return [Datadog::Tracing::Contrib::Configuration::Settings] the memoized integration-specific settings object
  #
  # source://ddtrace//lib/datadog/tracing/contrib/configurable.rb#69
  def default_configuration; end

  # Resets all configuration options
  #
  # source://ddtrace//lib/datadog/tracing/contrib/configurable.rb#58
  def reset_configuration!; end

  # Resolves the matching configuration for integration-specific value.
  # If no match, returns the default configuration instance.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/configurable.rb#31
  def resolve(value); end

  protected

  # Returns a new configuration object for this integration.
  #
  # This method normally needs to be overridden for each integration
  # as their settings, defaults and environment variables are
  # specific for each integration.
  #
  # @return [Datadog::Tracing::Contrib::Configuration::Settings] a new, integration-specific settings object
  #
  # source://ddtrace//lib/datadog/tracing/contrib/configurable.rb#82
  def new_configuration; end

  # Overridable configuration resolver.
  #
  # This resolver is responsible for performing the matching
  # of `#configure(matcher)` `matcher`s with `value`s provided
  # in subsequent calls to `#resolve(value)`.
  #
  # By default, the `value` in `#resolve(value)` must be equal
  # to the `matcher` object provided in `#configure(matcher)`
  # to retrieve the associated configuration.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/configurable.rb#95
  def resolver; end
end

# source://ddtrace//lib/datadog/tracing/contrib/configuration/resolver.rb#6
module Datadog::Tracing::Contrib::Configuration; end

# Resolves an integration-specific matcher to an associated
# object.
#
# Integrations that perform any configuration matching
# based on patterns might want to override this class
# to provide richer matching. For example, match configuration
# based on: HTTP request parameters, request headers,
# async queue name.
#
# When overriding this class, for simple use cases, only
# overriding `#parse_matcher` might suffice. See
# `#parse_matcher`'s documentation for more information.
#
# source://ddtrace//lib/datadog/tracing/contrib/configuration/resolver.rb#19
class Datadog::Tracing::Contrib::Configuration::Resolver
  # @return [Resolver] a new instance of Resolver
  #
  # source://ddtrace//lib/datadog/tracing/contrib/configuration/resolver.rb#22
  def initialize; end

  # Adds a new `matcher`, associating with it a `value`.
  #
  # This `value` is returned when `#resolve` is called
  # with a matching value for this matcher. When multiple
  # matchers would match, `#resolve` returns the latest
  # added one.
  #
  # The `matcher` can be transformed internally by the
  # `#parse_matcher` method before being stored.
  #
  # The `value` can also be retrieved by calling `#get`
  # with the same `matcher` added by this method.
  #
  # @param matcher [Object] integration-specific matcher
  # @param value [Object] arbitrary value to be associated with `matcher`
  #
  # source://ddtrace//lib/datadog/tracing/contrib/configuration/resolver.rb#41
  def add(matcher, value); end

  # Returns the value of attribute configurations.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/configuration/resolver.rb#20
  def configurations; end

  # Retrieves the stored value for a `matcher`
  # previously stored by `#add`.
  #
  # @param matcher [Object] integration-specific matcher
  # @return [Object] previously stored `value` from `#add`, or `nil` if not found
  #
  # source://ddtrace//lib/datadog/tracing/contrib/configuration/resolver.rb#50
  def get(matcher); end

  # Matches an arbitrary value against the configured
  # matchers previously set with `#add`.
  #
  # If multiple matchers would match, returns the latest one.
  #
  # @param value [Object] integration-specific value
  # @return [Object] matching `value` configured at `#add`, or `nil` if none match
  #
  # source://ddtrace//lib/datadog/tracing/contrib/configuration/resolver.rb#61
  def resolve(value); end

  protected

  # Converts `matcher` into an appropriate key
  # for the internal Hash storage.
  #
  # It's recommended to override this method,
  # instead of the public methods, if the
  # integration can simply convert both
  # `matcher` (provided to `#add`) and `value`
  # (provided to `#resolve`) to the same value.
  #
  # @param matcher [Object] integration-specific matcher
  # @return [Object] processed matcher
  #
  # source://ddtrace//lib/datadog/tracing/contrib/configuration/resolver.rb#78
  def parse_matcher(matcher); end
end

# Resolves a value to a configuration key
#
# source://ddtrace//lib/datadog/tracing/contrib/configuration/resolvers/pattern_resolver.rb#10
module Datadog::Tracing::Contrib::Configuration::Resolvers; end

# Matches Strings and Regexps against `object.to_s` objects
# and Procs against plain objects.
#
# source://ddtrace//lib/datadog/tracing/contrib/configuration/resolvers/pattern_resolver.rb#13
class Datadog::Tracing::Contrib::Configuration::Resolvers::PatternResolver < ::Datadog::Tracing::Contrib::Configuration::Resolver
  # source://ddtrace//lib/datadog/tracing/contrib/configuration/resolvers/pattern_resolver.rb#14
  def resolve(value); end

  protected

  # source://ddtrace//lib/datadog/tracing/contrib/configuration/resolvers/pattern_resolver.rb#31
  def parse_matcher(matcher); end
end

# Common settings for all integrations
#
# source://ddtrace//lib/datadog/tracing/contrib/configuration/settings.rb#10
class Datadog::Tracing::Contrib::Configuration::Settings
  include ::Datadog::Core::Configuration::Base
  include ::Datadog::Core::Environment::VariableHelpers
  include ::Datadog::Core::Configuration::Options
  include ::Datadog::Core::Configuration::Options::InstanceMethods
  include ::Datadog::Core::Configuration::Base::InstanceMethods
  extend ::Datadog::Core::Environment::VariableHelpers
  extend ::Datadog::Core::Configuration::Options::ClassMethods
  extend ::Datadog::Core::Configuration::Base::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/configuration/settings.rb#28
  def [](name); end

  # source://ddtrace//lib/datadog/tracing/contrib/configuration/settings.rb#32
  def []=(name, value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # @yield [_self]
  # @yieldparam _self [Datadog::Tracing::Contrib::Configuration::Settings] the object that the method was called on
  #
  # source://ddtrace//lib/datadog/tracing/contrib/configuration/settings.rb#20
  def configure(options = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# source://ddtrace//lib/datadog/tracing/contrib/dalli/ext.rb#6
module Datadog::Tracing::Contrib::Dalli; end

# source://ddtrace//lib/datadog/tracing/contrib/dalli/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Dalli::Configuration; end

# Custom settings for the Dalli integration
#
# source://ddtrace//lib/datadog/tracing/contrib/dalli/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Dalli::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def peer_service; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def peer_service=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# Dalli integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/dalli/ext.rb#9
module Datadog::Tracing::Contrib::Dalli::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/dalli/ext.rb#17
Datadog::Tracing::Contrib::Dalli::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/dalli/ext.rb#11
Datadog::Tracing::Contrib::Dalli::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/dalli/ext.rb#12
Datadog::Tracing::Contrib::Dalli::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/dalli/ext.rb#10
Datadog::Tracing::Contrib::Dalli::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/dalli/ext.rb#14
Datadog::Tracing::Contrib::Dalli::Ext::ENV_PEER_SERVICE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/dalli/ext.rb#13
Datadog::Tracing::Contrib::Dalli::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/dalli/ext.rb#24
Datadog::Tracing::Contrib::Dalli::Ext::PEER_SERVICE_SOURCES = T.let(T.unsafe(nil), Array)

# source://ddtrace//lib/datadog/tracing/contrib/dalli/ext.rb#16
Datadog::Tracing::Contrib::Dalli::Ext::QUANTIZE_MAX_CMD_LENGTH = T.let(T.unsafe(nil), Integer)

# source://ddtrace//lib/datadog/tracing/contrib/dalli/ext.rb#18
Datadog::Tracing::Contrib::Dalli::Ext::SPAN_COMMAND = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/dalli/ext.rb#19
Datadog::Tracing::Contrib::Dalli::Ext::SPAN_TYPE_COMMAND = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/dalli/ext.rb#20
Datadog::Tracing::Contrib::Dalli::Ext::TAG_COMMAND = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/dalli/ext.rb#21
Datadog::Tracing::Contrib::Dalli::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/dalli/ext.rb#22
Datadog::Tracing::Contrib::Dalli::Ext::TAG_OPERATION_COMMAND = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/dalli/ext.rb#23
Datadog::Tracing::Contrib::Dalli::Ext::TAG_SYSTEM = T.let(T.unsafe(nil), String)

# Instruments every interaction with the memcached server
#
# source://ddtrace//lib/datadog/tracing/contrib/dalli/instrumentation.rb#12
module Datadog::Tracing::Contrib::Dalli::Instrumentation
  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/dalli/instrumentation.rb#13
    def included(base); end
  end
end

# InstanceMethods - implementing instrumentation
#
# source://ddtrace//lib/datadog/tracing/contrib/dalli/instrumentation.rb#18
module Datadog::Tracing::Contrib::Dalli::Instrumentation::InstanceMethods
  # source://ddtrace//lib/datadog/tracing/contrib/dalli/instrumentation.rb#19
  def request(op, *args); end

  private

  # source://ddtrace//lib/datadog/tracing/contrib/dalli/instrumentation.rb#58
  def datadog_configuration; end
end

# Description of Dalli integration
#
# source://ddtrace//lib/datadog/tracing/contrib/dalli/integration.rb#10
class Datadog::Tracing::Contrib::Dalli::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/dalli/integration.rb#39
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/dalli/integration.rb#43
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/dalli/integration.rb#27
    def compatible?; end

    # source://ddtrace//lib/datadog/tracing/contrib/dalli/integration.rb#31
    def dalli_class; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/dalli/integration.rb#23
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/dalli/integration.rb#19
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/dalli/integration.rb#14
Datadog::Tracing::Contrib::Dalli::Integration::DALLI_PROTOCOL_BINARY_VERSION = T.let(T.unsafe(nil), Gem::Version)

# source://ddtrace//lib/datadog/tracing/contrib/dalli/integration.rb#13
Datadog::Tracing::Contrib::Dalli::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'dalli' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/dalli/patcher.rb#12
module Datadog::Tracing::Contrib::Dalli::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/dalli/patcher.rb#21
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/dalli/patcher.rb#17
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/dalli/patcher.rb#17
    def target_version; end
  end
end

# Quantize contains dalli-specic quantization tools.
#
# source://ddtrace//lib/datadog/tracing/contrib/dalli/quantize.rb#8
module Datadog::Tracing::Contrib::Dalli::Quantize
  private

  # source://ddtrace//lib/datadog/tracing/contrib/dalli/quantize.rb#11
  def format_command(operation, args); end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/dalli/quantize.rb#11
    def format_command(operation, args); end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/delayed_job/ext.rb#6
module Datadog::Tracing::Contrib::DelayedJob; end

# source://ddtrace//lib/datadog/tracing/contrib/delayed_job/configuration/settings.rb#11
module Datadog::Tracing::Contrib::DelayedJob::Configuration; end

# Custom settings for the DelayedJob integration
#
# source://ddtrace//lib/datadog/tracing/contrib/delayed_job/configuration/settings.rb#14
class Datadog::Tracing::Contrib::DelayedJob::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def client_service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def client_service_name=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def error_handler; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def error_handler=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# DelayedJob integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/delayed_job/ext.rb#9
module Datadog::Tracing::Contrib::DelayedJob::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/delayed_job/ext.rb#11
Datadog::Tracing::Contrib::DelayedJob::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/delayed_job/ext.rb#12
Datadog::Tracing::Contrib::DelayedJob::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/delayed_job/ext.rb#10
Datadog::Tracing::Contrib::DelayedJob::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/delayed_job/ext.rb#14
Datadog::Tracing::Contrib::DelayedJob::Ext::SPAN_ENQUEUE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/delayed_job/ext.rb#13
Datadog::Tracing::Contrib::DelayedJob::Ext::SPAN_JOB = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/delayed_job/ext.rb#15
Datadog::Tracing::Contrib::DelayedJob::Ext::SPAN_RESERVE_JOB = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/delayed_job/ext.rb#16
Datadog::Tracing::Contrib::DelayedJob::Ext::TAG_ATTEMPTS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/delayed_job/ext.rb#20
Datadog::Tracing::Contrib::DelayedJob::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/delayed_job/ext.rb#17
Datadog::Tracing::Contrib::DelayedJob::Ext::TAG_ID = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/delayed_job/ext.rb#21
Datadog::Tracing::Contrib::DelayedJob::Ext::TAG_OPERATION_ENQUEUE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/delayed_job/ext.rb#22
Datadog::Tracing::Contrib::DelayedJob::Ext::TAG_OPERATION_JOB = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/delayed_job/ext.rb#23
Datadog::Tracing::Contrib::DelayedJob::Ext::TAG_OPERATION_RESERVE_JOB = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/delayed_job/ext.rb#18
Datadog::Tracing::Contrib::DelayedJob::Ext::TAG_PRIORITY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/delayed_job/ext.rb#19
Datadog::Tracing::Contrib::DelayedJob::Ext::TAG_QUEUE = T.let(T.unsafe(nil), String)

# Description of DelayedJob integration
#
# source://ddtrace//lib/datadog/tracing/contrib/delayed_job/integration.rb#10
class Datadog::Tracing::Contrib::DelayedJob::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/delayed_job/integration.rb#30
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/delayed_job/integration.rb#34
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/delayed_job/integration.rb#26
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/delayed_job/integration.rb#22
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/delayed_job/integration.rb#18
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/delayed_job/integration.rb#13
Datadog::Tracing::Contrib::DelayedJob::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'delayed_job' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/delayed_job/patcher.rb#10
module Datadog::Tracing::Contrib::DelayedJob::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/delayed_job/patcher.rb#25
  def add_instrumentation(klass); end

  # source://ddtrace//lib/datadog/tracing/contrib/delayed_job/patcher.rb#19
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/delayed_job/patcher.rb#29
  def patch_server_internals; end

  # source://ddtrace//lib/datadog/tracing/contrib/delayed_job/patcher.rb#15
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/delayed_job/patcher.rb#25
    def add_instrumentation(klass); end

    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/delayed_job/patcher.rb#29
    def patch_server_internals; end

    # source://ddtrace//lib/datadog/tracing/contrib/delayed_job/patcher.rb#15
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/ext.rb#6
module Datadog::Tracing::Contrib::Elasticsearch; end

# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Elasticsearch::Configuration; end

# Custom settings for the Elasticsearch integration
#
# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Elasticsearch::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def peer_service; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def peer_service=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def quantize; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def quantize=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# Elasticsearch integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/ext.rb#9
module Datadog::Tracing::Contrib::Elasticsearch::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/ext.rb#15
Datadog::Tracing::Contrib::Elasticsearch::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/ext.rb#13
Datadog::Tracing::Contrib::Elasticsearch::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/ext.rb#14
Datadog::Tracing::Contrib::Elasticsearch::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/ext.rb#10
Datadog::Tracing::Contrib::Elasticsearch::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/ext.rb#12
Datadog::Tracing::Contrib::Elasticsearch::Ext::ENV_PEER_SERVICE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/ext.rb#11
Datadog::Tracing::Contrib::Elasticsearch::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/ext.rb#25
Datadog::Tracing::Contrib::Elasticsearch::Ext::PEER_SERVICE_SOURCES = T.let(T.unsafe(nil), Array)

# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/ext.rb#16
Datadog::Tracing::Contrib::Elasticsearch::Ext::SPAN_QUERY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/ext.rb#17
Datadog::Tracing::Contrib::Elasticsearch::Ext::SPAN_TYPE_QUERY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/ext.rb#18
Datadog::Tracing::Contrib::Elasticsearch::Ext::TAG_BODY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/ext.rb#22
Datadog::Tracing::Contrib::Elasticsearch::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/ext.rb#19
Datadog::Tracing::Contrib::Elasticsearch::Ext::TAG_METHOD = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/ext.rb#23
Datadog::Tracing::Contrib::Elasticsearch::Ext::TAG_OPERATION_QUERY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/ext.rb#20
Datadog::Tracing::Contrib::Elasticsearch::Ext::TAG_PARAMS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/ext.rb#24
Datadog::Tracing::Contrib::Elasticsearch::Ext::TAG_SYSTEM = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/ext.rb#21
Datadog::Tracing::Contrib::Elasticsearch::Ext::TAG_URL = T.let(T.unsafe(nil), String)

# Description of Elasticsearch integration
#
# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/integration.rb#10
class Datadog::Tracing::Contrib::Elasticsearch::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/integration.rb#37
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/integration.rb#41
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/integration.rb#33
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/integration.rb#27
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/integration.rb#18
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/integration.rb#13
Datadog::Tracing::Contrib::Elasticsearch::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'elasticsearch' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/patcher.rb#13
module Datadog::Tracing::Contrib::Elasticsearch::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/patcher.rb#22
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/patcher.rb#36
  def patch_elasticsearch_transport_client; end

  # source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/patcher.rb#18
  def target_version; end

  # `Elasticsearch` namespace renamed to `Elastic` in version 8.0.0 of the transport gem:
  #
  # @see https://github.com/elastic/elastic-transport-ruby/commit/ef804cbbd284f2a82d825221f87124f8b5ff823c
  #
  # source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/patcher.rb#147
  def transport_module; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/patcher.rb#36
    def patch_elasticsearch_transport_client; end

    # source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/patcher.rb#18
    def target_version; end

    # `Elasticsearch` namespace renamed to `Elastic` in version 8.0.0 of the transport gem:
    #
    # @see https://github.com/elastic/elastic-transport-ruby/commit/ef804cbbd284f2a82d825221f87124f8b5ff823c
    #
    # source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/patcher.rb#147
    def transport_module; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/elasticsearch/patcher.rb#30
Datadog::Tracing::Contrib::Elasticsearch::Patcher::SELF_DEPRECATION_ONLY_ONCE = T.let(T.unsafe(nil), Datadog::Core::Utils::OnlyOnce)

# source://ddtrace//lib/datadog/tracing/contrib/ethon/ext.rb#6
module Datadog::Tracing::Contrib::Ethon; end

# source://ddtrace//lib/datadog/tracing/contrib/ethon/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Ethon::Configuration; end

# Custom settings for the Ethon integration
#
# source://ddtrace//lib/datadog/tracing/contrib/ethon/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Ethon::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def distributed_tracing; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def distributed_tracing=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def peer_service; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def peer_service=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def split_by_domain; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def split_by_domain=(value); end
end

# Ethon integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/ethon/ext.rb#9
module Datadog::Tracing::Contrib::Ethon::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/ethon/ext.rb#16
Datadog::Tracing::Contrib::Ethon::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/ethon/ext.rb#14
Datadog::Tracing::Contrib::Ethon::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/ethon/ext.rb#15
Datadog::Tracing::Contrib::Ethon::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/ethon/ext.rb#10
Datadog::Tracing::Contrib::Ethon::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/ethon/ext.rb#12
Datadog::Tracing::Contrib::Ethon::Ext::ENV_PEER_SERVICE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/ethon/ext.rb#11
Datadog::Tracing::Contrib::Ethon::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/ethon/ext.rb#19
Datadog::Tracing::Contrib::Ethon::Ext::NOT_APPLICABLE_METHOD = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/ethon/ext.rb#23
Datadog::Tracing::Contrib::Ethon::Ext::PEER_SERVICE_SOURCES = T.let(T.unsafe(nil), Array)

# source://ddtrace//lib/datadog/tracing/contrib/ethon/ext.rb#18
Datadog::Tracing::Contrib::Ethon::Ext::SPAN_MULTI_REQUEST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/ethon/ext.rb#17
Datadog::Tracing::Contrib::Ethon::Ext::SPAN_REQUEST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/ethon/ext.rb#20
Datadog::Tracing::Contrib::Ethon::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/ethon/ext.rb#22
Datadog::Tracing::Contrib::Ethon::Ext::TAG_OPERATION_MULTI_REQUEST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/ethon/ext.rb#21
Datadog::Tracing::Contrib::Ethon::Ext::TAG_OPERATION_REQUEST = T.let(T.unsafe(nil), String)

# Description of Ethon integration
#
# source://ddtrace//lib/datadog/tracing/contrib/ethon/integration.rb#11
class Datadog::Tracing::Contrib::Ethon::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/ethon/integration.rb#31
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/ethon/integration.rb#35
  def patcher; end

  # source://ddtrace//lib/datadog/tracing/contrib/ethon/integration.rb#39
  def resolver; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/ethon/integration.rb#27
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/ethon/integration.rb#23
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/ethon/integration.rb#19
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/ethon/integration.rb#14
Datadog::Tracing::Contrib::Ethon::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'ethon' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/ethon/patcher.rb#10
module Datadog::Tracing::Contrib::Ethon::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/ethon/patcher.rb#19
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/ethon/patcher.rb#15
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/ethon/patcher.rb#15
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/excon/ext.rb#6
module Datadog::Tracing::Contrib::Excon; end

# source://ddtrace//lib/datadog/tracing/contrib/excon/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Excon::Configuration; end

# Custom settings for the Excon integration
#
# source://ddtrace//lib/datadog/tracing/contrib/excon/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Excon::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def distributed_tracing; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def distributed_tracing=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def error_handler; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def error_handler=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def peer_service; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def peer_service=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def split_by_domain; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def split_by_domain=(value); end
end

# Excon integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/excon/ext.rb#9
module Datadog::Tracing::Contrib::Excon::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/excon/ext.rb#16
Datadog::Tracing::Contrib::Excon::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/excon/ext.rb#14
Datadog::Tracing::Contrib::Excon::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/excon/ext.rb#15
Datadog::Tracing::Contrib::Excon::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/excon/ext.rb#10
Datadog::Tracing::Contrib::Excon::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/excon/ext.rb#12
Datadog::Tracing::Contrib::Excon::Ext::ENV_PEER_SERVICE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/excon/ext.rb#11
Datadog::Tracing::Contrib::Excon::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/excon/ext.rb#20
Datadog::Tracing::Contrib::Excon::Ext::PEER_SERVICE_SOURCES = T.let(T.unsafe(nil), Array)

# source://ddtrace//lib/datadog/tracing/contrib/excon/ext.rb#17
Datadog::Tracing::Contrib::Excon::Ext::SPAN_REQUEST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/excon/ext.rb#18
Datadog::Tracing::Contrib::Excon::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/excon/ext.rb#19
Datadog::Tracing::Contrib::Excon::Ext::TAG_OPERATION_REQUEST = T.let(T.unsafe(nil), String)

# Description of Excon integration
#
# source://ddtrace//lib/datadog/tracing/contrib/excon/integration.rb#11
class Datadog::Tracing::Contrib::Excon::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/excon/integration.rb#31
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/excon/integration.rb#35
  def patcher; end

  # source://ddtrace//lib/datadog/tracing/contrib/excon/integration.rb#39
  def resolver; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/excon/integration.rb#27
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/excon/integration.rb#23
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/excon/integration.rb#19
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/excon/integration.rb#14
Datadog::Tracing::Contrib::Excon::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'excon' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/excon/patcher.rb#10
module Datadog::Tracing::Contrib::Excon::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/excon/patcher.rb#24
  def add_middleware; end

  # source://ddtrace//lib/datadog/tracing/contrib/excon/patcher.rb#19
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/excon/patcher.rb#15
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/excon/patcher.rb#24
    def add_middleware; end

    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/excon/patcher.rb#15
    def target_version; end
  end
end

# Contrib specific constants
#
# source://ddtrace//lib/datadog/tracing/contrib/ext.rb#7
module Datadog::Tracing::Contrib::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/ext.rb#9
module Datadog::Tracing::Contrib::Ext::DB; end

# source://ddtrace//lib/datadog/tracing/contrib/ext.rb#15
Datadog::Tracing::Contrib::Ext::DB::PEER_SERVICE_SOURCES = T.let(T.unsafe(nil), Array)

# source://ddtrace//lib/datadog/tracing/contrib/ext.rb#10
Datadog::Tracing::Contrib::Ext::DB::TAG_INSTANCE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/ext.rb#14
Datadog::Tracing::Contrib::Ext::DB::TAG_ROW_COUNT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/ext.rb#13
Datadog::Tracing::Contrib::Ext::DB::TAG_STATEMENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/ext.rb#12
Datadog::Tracing::Contrib::Ext::DB::TAG_SYSTEM = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/ext.rb#11
Datadog::Tracing::Contrib::Ext::DB::TAG_USER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/ext.rb#35
module Datadog::Tracing::Contrib::Ext::Messaging; end

# source://ddtrace//lib/datadog/tracing/contrib/ext.rb#37
Datadog::Tracing::Contrib::Ext::Messaging::PEER_SERVICE_SOURCES = T.let(T.unsafe(nil), Array)

# source://ddtrace//lib/datadog/tracing/contrib/ext.rb#36
Datadog::Tracing::Contrib::Ext::Messaging::TAG_SYSTEM = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/ext.rb#42
module Datadog::Tracing::Contrib::Ext::Metadata; end

# Value of tag from which peer.service value was remapped from
#
# source://ddtrace//lib/datadog/tracing/contrib/ext.rb#47
Datadog::Tracing::Contrib::Ext::Metadata::TAG_PEER_SERVICE_REMAP = T.let(T.unsafe(nil), String)

# Name of tag from which where peer.service information was extracted from
#
# source://ddtrace//lib/datadog/tracing/contrib/ext.rb#44
Datadog::Tracing::Contrib::Ext::Metadata::TAG_PEER_SERVICE_SOURCE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/ext.rb#21
module Datadog::Tracing::Contrib::Ext::RPC; end

# source://ddtrace//lib/datadog/tracing/contrib/ext.rb#29
module Datadog::Tracing::Contrib::Ext::RPC::GRPC; end

# source://ddtrace//lib/datadog/tracing/contrib/ext.rb#31
Datadog::Tracing::Contrib::Ext::RPC::GRPC::TAG_FULL_METHOD = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/ext.rb#30
Datadog::Tracing::Contrib::Ext::RPC::GRPC::TAG_STATUS_CODE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/ext.rb#25
Datadog::Tracing::Contrib::Ext::RPC::PEER_SERVICE_SOURCES = T.let(T.unsafe(nil), Array)

# source://ddtrace//lib/datadog/tracing/contrib/ext.rb#24
Datadog::Tracing::Contrib::Ext::RPC::TAG_METHOD = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/ext.rb#23
Datadog::Tracing::Contrib::Ext::RPC::TAG_SERVICE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/ext.rb#22
Datadog::Tracing::Contrib::Ext::RPC::TAG_SYSTEM = T.let(T.unsafe(nil), String)

# Extensions that can be added to the base library
# Adds registry, configuration access for integrations.
#
# DEV: The Registry should probably be part of the core tracer
# as it represents a global tracer repository that is strongly intertwined
# with the tracer lifecycle and deeply modifies the tracer initialization
# process.
# Most of this file should probably live inside the tracer core.
#
# source://ddtrace//lib/datadog/tracing/contrib/extensions.rb#18
module Datadog::Tracing::Contrib::Extensions
  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/extensions.rb#19
    def extend!; end
  end
end

# Configuration methods for Datadog module.
#
# source://ddtrace//lib/datadog/tracing/contrib/extensions.rb#56
module Datadog::Tracing::Contrib::Extensions::Configuration
  # TODO: Is is not possible to separate this configuration method
  # TODO: from core ddtrace parts ()e.g. the registry).
  # TODO: Today this method sits here in the `Datadog::Tracing::Contrib::Extensions` namespace
  # TODO: but cannot empirically constraints to the contrib domain only.
  # TODO: We should promote most of this logic to core parts of ddtrace.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/extensions.rb#62
  def configure(&block); end
end

# Extensions for Datadog::Core::Configuration::Settings
#
# source://ddtrace//lib/datadog/tracing/contrib/extensions.rb#108
module Datadog::Tracing::Contrib::Extensions::Configuration::Settings
  # For the provided `integration_name`, resolves a matching configuration
  # for the provided integration from an integration-specific `key`.
  #
  # How the matching is performed is integration-specific.
  #
  # @example
  #   Datadog.configuration.tracing[:integration_name]
  # @example
  #   Datadog.configuration.tracing[:integration_name][:sub_configuration]
  # @param integration_name [Symbol] the integration name
  # @param key [Object] the integration-specific lookup key
  # @return [Datadog::Tracing::Contrib::Configuration::Settings]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/extensions.rb#186
  def [](integration_name, key = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/contrib/extensions.rb#208
  def fetch_integration(name); end

  # source://ddtrace//lib/datadog/tracing/contrib/extensions.rb#218
  def ignore_integration_load_errors=(value); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/extensions.rb#214
  def ignore_integration_load_errors?; end

  # Applies instrumentation for the provided `integration_name`.
  #
  # Options may be provided, that are specific to that instrumentation.
  # See the instrumentation's settings file for a list of available options.
  #
  # @example
  #   Datadog.configure { |c| c.tracing.instrument :integration_name }
  # @example
  #   Datadog.configure { |c| c.tracing.instrument :integration_name, option_key: :option_value }
  # @param integration_name [Symbol] the integration name
  # @param options [Hash] the integration-specific configuration settings
  # @return [Datadog::Tracing::Contrib::Integration]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/extensions.rb#155
  def instrument(integration_name, options = T.unsafe(nil), &block); end

  # source://ddtrace//lib/datadog/tracing/contrib/extensions.rb#197
  def instrumented_integrations; end

  # source://ddtrace//lib/datadog/tracing/contrib/extensions.rb#192
  def integrations_pending_activation; end

  # source://ddtrace//lib/datadog/tracing/contrib/extensions.rb#202
  def reset!; end

  # Applies instrumentation for the provided `integration_name`.
  #
  # Options may be provided, that are specific to that instrumentation.
  # See the instrumentation's settings file for a list of available options.
  # TODO: Deprecate in the next major version, as `instrument` better describes this method's purpose
  #
  # @example
  #   Datadog.configure { |c| c.tracing.instrument :integration_name }
  # @example
  #   Datadog.configure { |c| c.tracing.instrument :integration_name, option_key: :option_value }
  # @param integration_name [Symbol] the integration name
  # @param options [Hash] the integration-specific configuration settings
  # @return [Datadog::Tracing::Contrib::Integration]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/extensions.rb#155
  def use(integration_name, options = T.unsafe(nil), &block); end

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/extensions.rb#111
    def included(base); end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/extensions.rb#109
class Datadog::Tracing::Contrib::Extensions::Configuration::Settings::InvalidIntegrationError < ::StandardError; end

# Helper methods for Datadog module.
#
# source://ddtrace//lib/datadog/tracing/contrib/extensions.rb#31
module Datadog::Tracing::Contrib::Extensions::Helpers
  # The global integration registry.
  #
  # This registry holds a reference to all integrations available
  # to the tracer.
  #
  # Integrations registered in the {.registry} can be activated as follows:
  #
  # ```
  # Datadog.configure do |c|
  #   c.tracing.instrument :my_registered_integration, **my_options
  # end
  # ```
  #
  # New integrations can be registered by implementing the {Datadog::Tracing::Contrib::Integration} interface.
  #
  # @return [Datadog::Tracing::Contrib::Registry]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/extensions.rb#50
  def registry; end
end

# source://ddtrace//lib/datadog/tracing/contrib/faraday/ext.rb#6
module Datadog::Tracing::Contrib::Faraday; end

# source://ddtrace//lib/datadog/tracing/contrib/faraday/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Faraday::Configuration; end

# Custom settings for the Faraday integration
#
# source://ddtrace//lib/datadog/tracing/contrib/faraday/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Faraday::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def distributed_tracing; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def distributed_tracing=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def error_handler; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def error_handler=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def peer_service; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def peer_service=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def split_by_domain; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def split_by_domain=(value); end
end

# source://ddtrace//lib/datadog/tracing/contrib/faraday/configuration/settings.rb#14
Datadog::Tracing::Contrib::Faraday::Configuration::Settings::DEFAULT_ERROR_HANDLER = T.let(T.unsafe(nil), Proc)

# Handles installation of our middleware if the user has *not*
# already explicitly configured our middleware for this correction.
#
# Wraps Faraday::Connection#initialize:
# https://github.com/lostisland/faraday/blob/ff9dc1d1219a1bbdba95a9a4cf5d135b97247ee2/lib/faraday/connection.rb#L62-L92
#
# source://ddtrace//lib/datadog/tracing/contrib/faraday/connection.rb#12
module Datadog::Tracing::Contrib::Faraday::Connection
  # source://ddtrace//lib/datadog/tracing/contrib/faraday/connection.rb#13
  def initialize(*args, &block); end
end

# Faraday integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/faraday/ext.rb#9
module Datadog::Tracing::Contrib::Faraday::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/faraday/ext.rb#16
Datadog::Tracing::Contrib::Faraday::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/faraday/ext.rb#14
Datadog::Tracing::Contrib::Faraday::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/faraday/ext.rb#15
Datadog::Tracing::Contrib::Faraday::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/faraday/ext.rb#10
Datadog::Tracing::Contrib::Faraday::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/faraday/ext.rb#12
Datadog::Tracing::Contrib::Faraday::Ext::ENV_PEER_SERVICE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/faraday/ext.rb#11
Datadog::Tracing::Contrib::Faraday::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/faraday/ext.rb#20
Datadog::Tracing::Contrib::Faraday::Ext::PEER_SERVICE_SOURCES = T.let(T.unsafe(nil), Array)

# source://ddtrace//lib/datadog/tracing/contrib/faraday/ext.rb#17
Datadog::Tracing::Contrib::Faraday::Ext::SPAN_REQUEST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/faraday/ext.rb#18
Datadog::Tracing::Contrib::Faraday::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/faraday/ext.rb#19
Datadog::Tracing::Contrib::Faraday::Ext::TAG_OPERATION_REQUEST = T.let(T.unsafe(nil), String)

# Description of Faraday integration
#
# source://ddtrace//lib/datadog/tracing/contrib/faraday/integration.rb#11
class Datadog::Tracing::Contrib::Faraday::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/faraday/integration.rb#31
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/faraday/integration.rb#35
  def patcher; end

  # source://ddtrace//lib/datadog/tracing/contrib/faraday/integration.rb#39
  def resolver; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/faraday/integration.rb#27
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/faraday/integration.rb#23
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/faraday/integration.rb#19
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/faraday/integration.rb#14
Datadog::Tracing::Contrib::Faraday::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'faraday' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/faraday/patcher.rb#11
module Datadog::Tracing::Contrib::Faraday::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/faraday/patcher.rb#31
  def add_default_middleware!; end

  # source://ddtrace//lib/datadog/tracing/contrib/faraday/patcher.rb#20
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/faraday/patcher.rb#27
  def register_middleware!; end

  # source://ddtrace//lib/datadog/tracing/contrib/faraday/patcher.rb#16
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/faraday/patcher.rb#31
    def add_default_middleware!; end

    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/faraday/patcher.rb#27
    def register_middleware!; end

    # source://ddtrace//lib/datadog/tracing/contrib/faraday/patcher.rb#16
    def target_version; end
  end
end

# Handles installation of our middleware if the user has *not*
# already explicitly configured it for this correction.
#
# RackBuilder class was introduced in faraday 0.9.0:
# https://github.com/lostisland/faraday/commit/77d7546d6d626b91086f427c56bc2cdd951353b3
#
# source://ddtrace//lib/datadog/tracing/contrib/faraday/rack_builder.rb#12
module Datadog::Tracing::Contrib::Faraday::RackBuilder
  # source://ddtrace//lib/datadog/tracing/contrib/faraday/rack_builder.rb#13
  def adapter(*args); end
end

# source://ddtrace//lib/datadog/tracing/contrib/grpc/ext.rb#6
module Datadog::Tracing::Contrib::GRPC; end

# source://ddtrace//lib/datadog/tracing/contrib/grpc/configuration/settings.rb#11
module Datadog::Tracing::Contrib::GRPC::Configuration; end

# Custom settings for the gRPC integration
#
# source://ddtrace//lib/datadog/tracing/contrib/grpc/configuration/settings.rb#14
class Datadog::Tracing::Contrib::GRPC::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def distributed_tracing; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def distributed_tracing=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def error_handler; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def error_handler=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def peer_service; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def peer_service=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# gRPC integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/grpc/ext.rb#9
module Datadog::Tracing::Contrib::GRPC::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/grpc/ext.rb#15
Datadog::Tracing::Contrib::GRPC::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grpc/ext.rb#13
Datadog::Tracing::Contrib::GRPC::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grpc/ext.rb#14
Datadog::Tracing::Contrib::GRPC::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grpc/ext.rb#10
Datadog::Tracing::Contrib::GRPC::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grpc/ext.rb#12
Datadog::Tracing::Contrib::GRPC::Ext::ENV_PEER_SERVICE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grpc/ext.rb#11
Datadog::Tracing::Contrib::GRPC::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grpc/ext.rb#23
Datadog::Tracing::Contrib::GRPC::Ext::PEER_SERVICE_SOURCES = T.let(T.unsafe(nil), Array)

# source://ddtrace//lib/datadog/tracing/contrib/grpc/ext.rb#16
Datadog::Tracing::Contrib::GRPC::Ext::SPAN_CLIENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grpc/ext.rb#17
Datadog::Tracing::Contrib::GRPC::Ext::SPAN_SERVICE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grpc/ext.rb#18
Datadog::Tracing::Contrib::GRPC::Ext::TAG_CLIENT_DEADLINE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grpc/ext.rb#19
Datadog::Tracing::Contrib::GRPC::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grpc/ext.rb#20
Datadog::Tracing::Contrib::GRPC::Ext::TAG_OPERATION_CLIENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grpc/ext.rb#21
Datadog::Tracing::Contrib::GRPC::Ext::TAG_OPERATION_SERVICE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grpc/ext.rb#22
Datadog::Tracing::Contrib::GRPC::Ext::TAG_SYSTEM = T.let(T.unsafe(nil), String)

# Description of gRPC integration
#
# source://ddtrace//lib/datadog/tracing/contrib/grpc/integration.rb#10
class Datadog::Tracing::Contrib::GRPC::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/grpc/integration.rb#37
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/grpc/integration.rb#41
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/grpc/integration.rb#33
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/grpc/integration.rb#22
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/grpc/integration.rb#18
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/grpc/integration.rb#13
Datadog::Tracing::Contrib::GRPC::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'grpc' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/grpc/patcher.rb#11
module Datadog::Tracing::Contrib::GRPC::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/grpc/patcher.rb#20
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/grpc/patcher.rb#26
  def prepend_interceptor; end

  # source://ddtrace//lib/datadog/tracing/contrib/grpc/patcher.rb#16
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/grpc/patcher.rb#26
    def prepend_interceptor; end

    # source://ddtrace//lib/datadog/tracing/contrib/grpc/patcher.rb#16
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/grape/ext.rb#6
module Datadog::Tracing::Contrib::Grape; end

# source://ddtrace//lib/datadog/tracing/contrib/grape/configuration/settings.rb#11
module Datadog::Tracing::Contrib::Grape::Configuration; end

# Custom settings for the Grape integration
#
# source://ddtrace//lib/datadog/tracing/contrib/grape/configuration/settings.rb#14
class Datadog::Tracing::Contrib::Grape::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def error_statuses; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def error_statuses=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# Endpoint module includes a list of subscribers to create
# traces when a Grape endpoint is hit
#
# source://ddtrace//lib/datadog/tracing/contrib/grape/endpoint.rb#12
module Datadog::Tracing::Contrib::Grape::Endpoint
  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/grape/endpoint.rb#131
    def endpoint_render(name, start, finish, id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/grape/endpoint.rb#67
    def endpoint_run(name, start, finish, id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/grape/endpoint.rb#155
    def endpoint_run_filters(name, start, finish, id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/grape/endpoint.rb#36
    def endpoint_start_process(_name, _start, _finish, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/grape/endpoint.rb#112
    def endpoint_start_render(*_arg0); end

    # source://ddtrace//lib/datadog/tracing/contrib/grape/endpoint.rb#17
    def subscribe; end

    private

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/grape/endpoint.rb#218
    def analytics_enabled?; end

    # source://ddtrace//lib/datadog/tracing/contrib/grape/endpoint.rb#222
    def analytics_sample_rate; end

    # source://ddtrace//lib/datadog/tracing/contrib/grape/endpoint.rb#195
    def api_view(api); end

    # source://ddtrace//lib/datadog/tracing/contrib/grape/endpoint.rb#240
    def datadog_configuration; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/grape/endpoint.rb#235
    def enabled?; end

    # source://ddtrace//lib/datadog/tracing/contrib/grape/endpoint.rb#206
    def endpoint_expand_path(endpoint); end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/grape/endpoint.rb#226
    def exception_is_error?(exception); end

    # source://ddtrace//lib/datadog/tracing/contrib/grape/endpoint.rb#214
    def service_name; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/grape/endpoint.rb#14
Datadog::Tracing::Contrib::Grape::Endpoint::KEY_RENDER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grape/endpoint.rb#13
Datadog::Tracing::Contrib::Grape::Endpoint::KEY_RUN = T.let(T.unsafe(nil), String)

# Grape integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/grape/ext.rb#9
module Datadog::Tracing::Contrib::Grape::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/grape/ext.rb#11
Datadog::Tracing::Contrib::Grape::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grape/ext.rb#12
Datadog::Tracing::Contrib::Grape::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grape/ext.rb#10
Datadog::Tracing::Contrib::Grape::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grape/ext.rb#13
Datadog::Tracing::Contrib::Grape::Ext::SPAN_ENDPOINT_RENDER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grape/ext.rb#14
Datadog::Tracing::Contrib::Grape::Ext::SPAN_ENDPOINT_RUN = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grape/ext.rb#15
Datadog::Tracing::Contrib::Grape::Ext::SPAN_ENDPOINT_RUN_FILTERS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grape/ext.rb#16
Datadog::Tracing::Contrib::Grape::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grape/ext.rb#17
Datadog::Tracing::Contrib::Grape::Ext::TAG_FILTER_TYPE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grape/ext.rb#18
Datadog::Tracing::Contrib::Grape::Ext::TAG_OPERATION_ENDPOINT_RENDER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grape/ext.rb#19
Datadog::Tracing::Contrib::Grape::Ext::TAG_OPERATION_ENDPOINT_RUN = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grape/ext.rb#20
Datadog::Tracing::Contrib::Grape::Ext::TAG_OPERATION_ENDPOINT_RUN_FILTERS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grape/ext.rb#21
Datadog::Tracing::Contrib::Grape::Ext::TAG_ROUTE_ENDPOINT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grape/ext.rb#23
Datadog::Tracing::Contrib::Grape::Ext::TAG_ROUTE_METHOD = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/grape/ext.rb#22
Datadog::Tracing::Contrib::Grape::Ext::TAG_ROUTE_PATH = T.let(T.unsafe(nil), String)

# Instrumentation for Grape::Endpoint
#
# source://ddtrace//lib/datadog/tracing/contrib/grape/instrumentation.rb#6
module Datadog::Tracing::Contrib::Grape::Instrumentation
  mixes_in_class_methods ::Datadog::Tracing::Contrib::Grape::Instrumentation::ClassMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/grape/instrumentation.rb#7
    def included(base); end
  end
end

# ClassMethods - implementing instrumentation
#
# source://ddtrace//lib/datadog/tracing/contrib/grape/instrumentation.rb#13
module Datadog::Tracing::Contrib::Grape::Instrumentation::ClassMethods
  # source://ddtrace//lib/datadog/tracing/contrib/grape/instrumentation.rb#14
  def generate_api_method(*params, &block); end
end

# InstanceMethods - implementing instrumentation
#
# source://ddtrace//lib/datadog/tracing/contrib/grape/instrumentation.rb#25
module Datadog::Tracing::Contrib::Grape::Instrumentation::InstanceMethods
  # source://ddtrace//lib/datadog/tracing/contrib/grape/instrumentation.rb#26
  def run(*args); end
end

# Description of Grape integration
#
# source://ddtrace//lib/datadog/tracing/contrib/grape/integration.rb#10
class Datadog::Tracing::Contrib::Grape::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/grape/integration.rb#31
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/grape/integration.rb#35
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/grape/integration.rb#27
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/grape/integration.rb#22
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/grape/integration.rb#18
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/grape/integration.rb#13
Datadog::Tracing::Contrib::Grape::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'grape' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/grape/patcher.rb#13
module Datadog::Tracing::Contrib::Grape::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/grape/patcher.rb#22
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/grape/patcher.rb#18
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/grape/patcher.rb#18
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/graphql/ext.rb#6
module Datadog::Tracing::Contrib::GraphQL; end

# source://ddtrace//lib/datadog/tracing/contrib/graphql/configuration/settings.rb#10
module Datadog::Tracing::Contrib::GraphQL::Configuration; end

# Custom settings for the GraphQL integration
#
# source://ddtrace//lib/datadog/tracing/contrib/graphql/configuration/settings.rb#13
class Datadog::Tracing::Contrib::GraphQL::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def schemas; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def schemas=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# GraphQL integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/graphql/ext.rb#9
module Datadog::Tracing::Contrib::GraphQL::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/graphql/ext.rb#11
Datadog::Tracing::Contrib::GraphQL::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/graphql/ext.rb#12
Datadog::Tracing::Contrib::GraphQL::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/graphql/ext.rb#10
Datadog::Tracing::Contrib::GraphQL::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/graphql/ext.rb#13
Datadog::Tracing::Contrib::GraphQL::Ext::SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/graphql/ext.rb#14
Datadog::Tracing::Contrib::GraphQL::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# Description of GraphQL integration
#
# source://ddtrace//lib/datadog/tracing/contrib/graphql/integration.rb#10
class Datadog::Tracing::Contrib::GraphQL::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/graphql/integration.rb#31
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/graphql/integration.rb#35
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/graphql/integration.rb#27
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/graphql/integration.rb#22
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/graphql/integration.rb#18
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/graphql/integration.rb#13
Datadog::Tracing::Contrib::GraphQL::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Provides instrumentation for `graphql` through the GraphQL tracing framework
#
# source://ddtrace//lib/datadog/tracing/contrib/graphql/patcher.rb#9
module Datadog::Tracing::Contrib::GraphQL::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/graphql/patcher.rb#64
  def get_option(option); end

  # source://ddtrace//lib/datadog/tracing/contrib/graphql/patcher.rb#18
  def patch; end

  # Before https://github.com/rmosolgo/graphql-ruby/pull/4038 was introduced,
  # we were left with incompatibilities between ddtrace 1.0 and older graphql gem versions.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/graphql/patcher.rb#58
  def patch_legacy_gem!; end

  # source://ddtrace//lib/datadog/tracing/contrib/graphql/patcher.rb#26
  def patch_schema!(schema); end

  # source://ddtrace//lib/datadog/tracing/contrib/graphql/patcher.rb#14
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/graphql/patcher.rb#64
    def get_option(option); end

    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # Before https://github.com/rmosolgo/graphql-ruby/pull/4038 was introduced,
    # we were left with incompatibilities between ddtrace 1.0 and older graphql gem versions.
    #
    # source://ddtrace//lib/datadog/tracing/contrib/graphql/patcher.rb#58
    def patch_legacy_gem!; end

    # source://ddtrace//lib/datadog/tracing/contrib/graphql/patcher.rb#26
    def patch_schema!(schema); end

    # source://ddtrace//lib/datadog/tracing/contrib/graphql/patcher.rb#14
    def target_version; end
  end
end

# Patches the graphql gem to support ddtrace 1.0.
# This is not necessary in versions containing https://github.com/rmosolgo/graphql-ruby/pull/4038.
#
# source://ddtrace//lib/datadog/tracing/contrib/graphql/patcher.rb#70
module Datadog::Tracing::Contrib::GraphQL::Patcher::PatchLegacyGem
  # Ensure resource name is not left as `nil`.
  # This is fixed in graphql > 2.0.6.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/graphql/patcher.rb#80
  def fallback_transaction_name(context); end

  # Ensure invocation to #trace method targets the new namespaced public API object,
  # instead of the old global Datadog.trace.
  # This is fixed in graphql > 2.0.3.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/graphql/patcher.rb#74
  def tracer; end
end

# Datadog Net/HTTP integration.
#
# source://ddtrace//lib/datadog/tracing/contrib/http/distributed/fetcher.rb#8
module Datadog::Tracing::Contrib::HTTP
  extend ::Datadog::Tracing::Contrib::HTTP::CircuitBreaker
end

# HTTP integration circuit breaker behavior
# For avoiding recursive traces.
#
# source://ddtrace//lib/datadog/tracing/contrib/http/circuit_breaker.rb#11
module Datadog::Tracing::Contrib::HTTP::CircuitBreaker
  # We don't want to trace our own call to the API (they use net/http)
  # TODO: We don't want this kind of soft-check on HTTP requests.
  #       Remove this when transport implements its own "skip tracing" mechanism.
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/http/circuit_breaker.rb#26
  def internal_request?(request); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/http/circuit_breaker.rb#31
  def should_skip_distributed_tracing?(client_config); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/http/circuit_breaker.rb#12
  def should_skip_tracing?(request); end
end

# source://ddtrace//lib/datadog/tracing/contrib/http/configuration/settings.rb#10
module Datadog::Tracing::Contrib::HTTP::Configuration; end

# Custom settings for the HTTP integration
#
# source://ddtrace//lib/datadog/tracing/contrib/http/configuration/settings.rb#13
class Datadog::Tracing::Contrib::HTTP::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def distributed_tracing; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def distributed_tracing=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def error_status_codes; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def error_status_codes=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def peer_service; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def peer_service=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def split_by_domain; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def split_by_domain=(value); end
end

# source://ddtrace//lib/datadog/tracing/contrib/http/distributed/fetcher.rb#9
module Datadog::Tracing::Contrib::HTTP::Distributed; end

# Retrieves HTTP headers from carrier.
# Headers will also match if Rack-formatted:
# 'my-header' will match 'my-header' and 'HTTP_MY_HEADER'.
#
# In case both variants are present, the verbatim match will be used.
#
# source://ddtrace//lib/datadog/tracing/contrib/http/distributed/fetcher.rb#15
class Datadog::Tracing::Contrib::HTTP::Distributed::Fetcher < ::Datadog::Tracing::Distributed::Fetcher
  # DEV: Should we try to parse both verbatim an Rack-formatted headers,
  # DEV: given Rack-formatted is the most common format in Ruby?
  #
  # source://ddtrace//lib/datadog/tracing/contrib/http/distributed/fetcher.rb#18
  def [](name); end
end

# Extracts and injects propagation through HTTP headers.
#
# source://ddtrace//lib/datadog/tracing/contrib/http/distributed/propagation.rb#17
class Datadog::Tracing::Contrib::HTTP::Distributed::Propagation < ::Datadog::Tracing::Distributed::Propagation
  # @return [Propagation] a new instance of Propagation
  #
  # source://ddtrace//lib/datadog/tracing/contrib/http/distributed/propagation.rb#18
  def initialize; end
end

# HTTP integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/http/ext.rb#9
module Datadog::Tracing::Contrib::HTTP::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/http/ext.rb#16
Datadog::Tracing::Contrib::HTTP::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/http/ext.rb#13
Datadog::Tracing::Contrib::HTTP::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/http/ext.rb#14
Datadog::Tracing::Contrib::HTTP::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/http/ext.rb#10
Datadog::Tracing::Contrib::HTTP::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/http/ext.rb#15
Datadog::Tracing::Contrib::HTTP::Ext::ENV_ERROR_STATUS_CODES = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/http/ext.rb#12
Datadog::Tracing::Contrib::HTTP::Ext::ENV_PEER_SERVICE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/http/ext.rb#11
Datadog::Tracing::Contrib::HTTP::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/http/ext.rb#20
Datadog::Tracing::Contrib::HTTP::Ext::PEER_SERVICE_SOURCES = T.let(T.unsafe(nil), Array)

# source://ddtrace//lib/datadog/tracing/contrib/http/ext.rb#17
Datadog::Tracing::Contrib::HTTP::Ext::SPAN_REQUEST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/http/ext.rb#18
Datadog::Tracing::Contrib::HTTP::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/http/ext.rb#19
Datadog::Tracing::Contrib::HTTP::Ext::TAG_OPERATION_REQUEST = T.let(T.unsafe(nil), String)

# Instrumentation for Net::HTTP
#
# source://ddtrace//lib/datadog/tracing/contrib/http/instrumentation.rb#13
module Datadog::Tracing::Contrib::HTTP::Instrumentation
  class << self
    # Span hook invoked after request is completed.
    #
    # source://ddtrace//lib/datadog/tracing/contrib/http/instrumentation.rb#19
    def after_request(&block); end

    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/http/instrumentation.rb#14
    def included(base); end
  end
end

# InstanceMethods - implementing instrumentation
#
# source://ddtrace//lib/datadog/tracing/contrib/http/instrumentation.rb#30
module Datadog::Tracing::Contrib::HTTP::Instrumentation::InstanceMethods
  include ::Datadog::Tracing::Contrib::HttpAnnotationHelper

  # source://ddtrace//lib/datadog/tracing/contrib/http/instrumentation.rb#117
  def annotate_span_with_error!(span, error); end

  # source://ddtrace//lib/datadog/tracing/contrib/http/instrumentation.rb#71
  def annotate_span_with_request!(span, request, request_options); end

  # source://ddtrace//lib/datadog/tracing/contrib/http/instrumentation.rb#105
  def annotate_span_with_response!(span, response, request_options); end

  # :yield: +response+
  #
  # source://ddtrace//lib/datadog/tracing/contrib/http/instrumentation.rb#34
  def request(req, body = T.unsafe(nil), &block); end

  # source://ddtrace//lib/datadog/tracing/contrib/http/instrumentation.rb#121
  def set_analytics_sample_rate(span, request_options); end

  private

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/http/instrumentation.rb#141
  def analytics_enabled?(request_options); end

  # source://ddtrace//lib/datadog/tracing/contrib/http/instrumentation.rb#145
  def analytics_sample_rate(request_options); end

  # source://ddtrace//lib/datadog/tracing/contrib/http/instrumentation.rb#137
  def datadog_configuration(host = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/contrib/http/instrumentation.rb#129
  def host_and_port(request); end
end

# Description of HTTP integration
#
# source://ddtrace//lib/datadog/tracing/contrib/http/integration.rb#18
class Datadog::Tracing::Contrib::HTTP::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/http/integration.rb#34
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/http/integration.rb#38
  def patcher; end

  # source://ddtrace//lib/datadog/tracing/contrib/http/integration.rb#42
  def resolver; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/http/integration.rb#30
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/http/integration.rb#26
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/http/integration.rb#21
Datadog::Tracing::Contrib::HTTP::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), String)

# Patcher enables patching of 'net/http' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/http/patcher.rb#13
module Datadog::Tracing::Contrib::HTTP::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # patch applies our patch if needed
  #
  # source://ddtrace//lib/datadog/tracing/contrib/http/patcher.rb#23
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/http/patcher.rb#18
  def target_version; end

  class << self
    # patch applies our patch if needed
    #
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/http/patcher.rb#18
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/hanami/ext.rb#6
module Datadog::Tracing::Contrib::Hanami; end

# Hanami Instrumentation for `hanami.action`
#
# source://ddtrace//lib/datadog/tracing/contrib/hanami/action_tracer.rb#12
class Datadog::Tracing::Contrib::Hanami::ActionTracer
  # @return [ActionTracer] a new instance of ActionTracer
  #
  # source://ddtrace//lib/datadog/tracing/contrib/hanami/action_tracer.rb#13
  def initialize(app, action); end

  # source://ddtrace//lib/datadog/tracing/contrib/hanami/action_tracer.rb#18
  def call(env); end

  private

  # source://ddtrace//lib/datadog/tracing/contrib/hanami/action_tracer.rb#40
  def configuration; end
end

# source://ddtrace//lib/datadog/tracing/contrib/hanami/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Hanami::Configuration; end

# Configuration for Hanami instrumentation
#
# source://ddtrace//lib/datadog/tracing/contrib/hanami/configuration/settings.rb#12
class Datadog::Tracing::Contrib::Hanami::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end
end

# Hanami integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/hanami/ext.rb#9
module Datadog::Tracing::Contrib::Hanami::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/hanami/ext.rb#10
Datadog::Tracing::Contrib::Hanami::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/hanami/ext.rb#12
Datadog::Tracing::Contrib::Hanami::Ext::SPAN_ACTION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/hanami/ext.rb#14
Datadog::Tracing::Contrib::Hanami::Ext::SPAN_RENDER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/hanami/ext.rb#13
Datadog::Tracing::Contrib::Hanami::Ext::SPAN_ROUTING = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/hanami/ext.rb#16
Datadog::Tracing::Contrib::Hanami::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/hanami/ext.rb#17
Datadog::Tracing::Contrib::Hanami::Ext::TAG_OPERATION_ACTION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/hanami/ext.rb#19
Datadog::Tracing::Contrib::Hanami::Ext::TAG_OPERATION_RENDER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/hanami/ext.rb#18
Datadog::Tracing::Contrib::Hanami::Ext::TAG_OPERATION_ROUTING = T.let(T.unsafe(nil), String)

# Description of Hanami integration
#
# source://ddtrace//lib/datadog/tracing/contrib/hanami/integration.rb#10
class Datadog::Tracing::Contrib::Hanami::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/hanami/integration.rb#31
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/hanami/integration.rb#35
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/hanami/integration.rb#26
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/hanami/integration.rb#22
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/hanami/integration.rb#18
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/hanami/integration.rb#14
Datadog::Tracing::Contrib::Hanami::Integration::MAXIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# source://ddtrace//lib/datadog/tracing/contrib/hanami/integration.rb#13
Datadog::Tracing::Contrib::Hanami::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of Hanami
#
# source://ddtrace//lib/datadog/tracing/contrib/hanami/patcher.rb#13
module Datadog::Tracing::Contrib::Hanami::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/hanami/patcher.rb#22
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/hanami/patcher.rb#18
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/hanami/patcher.rb#18
    def target_version; end
  end
end

# Hanami Instrumentation for `hanami.render`
#
# source://ddtrace//lib/datadog/tracing/contrib/hanami/renderer_policy_tracing.rb#11
module Datadog::Tracing::Contrib::Hanami::RendererPolicyTracing
  # source://ddtrace//lib/datadog/tracing/contrib/hanami/renderer_policy_tracing.rb#34
  def configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/hanami/renderer_policy_tracing.rb#12
  def render(env, response); end
end

# Hanami Instrumentation for `hanami.routing`
#
# source://ddtrace//lib/datadog/tracing/contrib/hanami/router_tracing.rb#11
module Datadog::Tracing::Contrib::Hanami::RouterTracing
  # source://ddtrace//lib/datadog/tracing/contrib/hanami/router_tracing.rb#12
  def call(env); end

  # source://ddtrace//lib/datadog/tracing/contrib/hanami/router_tracing.rb#37
  def configuration; end
end

# Contains methods helpful for tracing/annotating HTTP request libraries
#
# source://ddtrace//lib/datadog/tracing/contrib/http_annotation_helper.rb#7
module Datadog::Tracing::Contrib::HttpAnnotationHelper
  # source://ddtrace//lib/datadog/tracing/contrib/http_annotation_helper.rb#8
  def service_name(hostname, configuration_options, pin = T.unsafe(nil)); end
end

# Datadog Httpclient integration.
#
# source://ddtrace//lib/datadog/tracing/contrib/httpclient/ext.rb#6
module Datadog::Tracing::Contrib::Httpclient; end

# source://ddtrace//lib/datadog/tracing/contrib/httpclient/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Httpclient::Configuration; end

# Custom settings for the Httpclient integration
#
# source://ddtrace//lib/datadog/tracing/contrib/httpclient/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Httpclient::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def distributed_tracing; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def distributed_tracing=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def error_status_codes; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def error_status_codes=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def peer_service; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def peer_service=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def split_by_domain; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def split_by_domain=(value); end
end

# Httpclient integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/httpclient/ext.rb#9
module Datadog::Tracing::Contrib::Httpclient::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/httpclient/ext.rb#17
Datadog::Tracing::Contrib::Httpclient::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/httpclient/ext.rb#14
Datadog::Tracing::Contrib::Httpclient::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/httpclient/ext.rb#15
Datadog::Tracing::Contrib::Httpclient::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/httpclient/ext.rb#10
Datadog::Tracing::Contrib::Httpclient::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/httpclient/ext.rb#16
Datadog::Tracing::Contrib::Httpclient::Ext::ENV_ERROR_STATUS_CODES = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/httpclient/ext.rb#12
Datadog::Tracing::Contrib::Httpclient::Ext::ENV_PEER_SERVICE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/httpclient/ext.rb#11
Datadog::Tracing::Contrib::Httpclient::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/httpclient/ext.rb#21
Datadog::Tracing::Contrib::Httpclient::Ext::PEER_SERVICE_SOURCES = T.let(T.unsafe(nil), Array)

# source://ddtrace//lib/datadog/tracing/contrib/httpclient/ext.rb#18
Datadog::Tracing::Contrib::Httpclient::Ext::SPAN_REQUEST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/httpclient/ext.rb#19
Datadog::Tracing::Contrib::Httpclient::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/httpclient/ext.rb#20
Datadog::Tracing::Contrib::Httpclient::Ext::TAG_OPERATION_REQUEST = T.let(T.unsafe(nil), String)

# Instrumentation for Httpclient
#
# source://ddtrace//lib/datadog/tracing/contrib/httpclient/instrumentation.rb#11
module Datadog::Tracing::Contrib::Httpclient::Instrumentation
  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/httpclient/instrumentation.rb#12
    def included(base); end
  end
end

# Instance methods for configuration
#
# source://ddtrace//lib/datadog/tracing/contrib/httpclient/instrumentation.rb#17
module Datadog::Tracing::Contrib::Httpclient::Instrumentation::InstanceMethods
  include ::Datadog::Tracing::Contrib::HttpAnnotationHelper

  # source://ddtrace//lib/datadog/tracing/contrib/httpclient/instrumentation.rb#20
  def do_get_block(req, proxy, conn, &block); end

  private

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/httpclient/instrumentation.rb#106
  def analytics_enabled?(request_options); end

  # source://ddtrace//lib/datadog/tracing/contrib/httpclient/instrumentation.rb#98
  def annotate_span_with_error!(span, error); end

  # source://ddtrace//lib/datadog/tracing/contrib/httpclient/instrumentation.rb#51
  def annotate_span_with_request!(span, req, req_options); end

  # source://ddtrace//lib/datadog/tracing/contrib/httpclient/instrumentation.rb#84
  def annotate_span_with_response!(span, response, request_options); end

  # source://ddtrace//lib/datadog/tracing/contrib/httpclient/instrumentation.rb#102
  def datadog_configuration(host = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/contrib/httpclient/instrumentation.rb#110
  def logger; end

  # source://ddtrace//lib/datadog/tracing/contrib/httpclient/instrumentation.rb#120
  def set_analytics_sample_rate(span, request_options); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/httpclient/instrumentation.rb#114
  def should_skip_distributed_tracing?(client_config); end
end

# Description of Httpclient integration
#
# source://ddtrace//lib/datadog/tracing/contrib/httpclient/integration.rb#11
class Datadog::Tracing::Contrib::Httpclient::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/httpclient/integration.rb#31
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/httpclient/integration.rb#35
  def patcher; end

  # source://ddtrace//lib/datadog/tracing/contrib/httpclient/integration.rb#39
  def resolver; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/httpclient/integration.rb#27
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/httpclient/integration.rb#23
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/httpclient/integration.rb#19
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/httpclient/integration.rb#14
Datadog::Tracing::Contrib::Httpclient::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'httpclient' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/httpclient/patcher.rb#11
module Datadog::Tracing::Contrib::Httpclient::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # patch applies our patch
  #
  # source://ddtrace//lib/datadog/tracing/contrib/httpclient/patcher.rb#27
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/httpclient/patcher.rb#18
  def patched?; end

  # source://ddtrace//lib/datadog/tracing/contrib/httpclient/patcher.rb#22
  def target_version; end

  class << self
    # patch applies our patch
    #
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#27
    def patched?; end

    # source://ddtrace//lib/datadog/tracing/contrib/httpclient/patcher.rb#22
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/httpclient/patcher.rb#14
Datadog::Tracing::Contrib::Httpclient::Patcher::PATCH_ONLY_ONCE = T.let(T.unsafe(nil), Datadog::Core::Utils::OnlyOnce)

# Datadog Httprb integration.
#
# source://ddtrace//lib/datadog/tracing/contrib/httprb/ext.rb#6
module Datadog::Tracing::Contrib::Httprb; end

# source://ddtrace//lib/datadog/tracing/contrib/httprb/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Httprb::Configuration; end

# Custom settings for the Httprb integration
#
# source://ddtrace//lib/datadog/tracing/contrib/httprb/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Httprb::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def distributed_tracing; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def distributed_tracing=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def error_status_codes; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def error_status_codes=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def peer_service; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def peer_service=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def split_by_domain; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def split_by_domain=(value); end
end

# Httprb integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/httprb/ext.rb#9
module Datadog::Tracing::Contrib::Httprb::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/httprb/ext.rb#16
Datadog::Tracing::Contrib::Httprb::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/httprb/ext.rb#13
Datadog::Tracing::Contrib::Httprb::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/httprb/ext.rb#14
Datadog::Tracing::Contrib::Httprb::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/httprb/ext.rb#10
Datadog::Tracing::Contrib::Httprb::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/httprb/ext.rb#15
Datadog::Tracing::Contrib::Httprb::Ext::ENV_ERROR_STATUS_CODES = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/httprb/ext.rb#12
Datadog::Tracing::Contrib::Httprb::Ext::ENV_PEER_SERVICE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/httprb/ext.rb#11
Datadog::Tracing::Contrib::Httprb::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/httprb/ext.rb#20
Datadog::Tracing::Contrib::Httprb::Ext::PEER_SERVICE_SOURCES = T.let(T.unsafe(nil), Array)

# source://ddtrace//lib/datadog/tracing/contrib/httprb/ext.rb#17
Datadog::Tracing::Contrib::Httprb::Ext::SPAN_REQUEST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/httprb/ext.rb#18
Datadog::Tracing::Contrib::Httprb::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/httprb/ext.rb#19
Datadog::Tracing::Contrib::Httprb::Ext::TAG_OPERATION_REQUEST = T.let(T.unsafe(nil), String)

# Instrumentation for Httprb
#
# source://ddtrace//lib/datadog/tracing/contrib/httprb/instrumentation.rb#11
module Datadog::Tracing::Contrib::Httprb::Instrumentation
  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/httprb/instrumentation.rb#12
    def included(base); end
  end
end

# Instance methods for configuration
#
# source://ddtrace//lib/datadog/tracing/contrib/httprb/instrumentation.rb#17
module Datadog::Tracing::Contrib::Httprb::Instrumentation::InstanceMethods
  include ::Datadog::Tracing::Contrib::HttpAnnotationHelper

  # source://ddtrace//lib/datadog/tracing/contrib/httprb/instrumentation.rb#20
  def perform(req, options); end

  private

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/httprb/instrumentation.rb#116
  def analytics_enabled?(request_options); end

  # source://ddtrace//lib/datadog/tracing/contrib/httprb/instrumentation.rb#108
  def annotate_span_with_error!(span, error); end

  # source://ddtrace//lib/datadog/tracing/contrib/httprb/instrumentation.rb#51
  def annotate_span_with_request!(span, req, req_options); end

  # source://ddtrace//lib/datadog/tracing/contrib/httprb/instrumentation.rb#92
  def annotate_span_with_response!(span, response, request_options); end

  # source://ddtrace//lib/datadog/tracing/contrib/httprb/instrumentation.rb#112
  def datadog_configuration(host = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/contrib/httprb/instrumentation.rb#120
  def logger; end

  # source://ddtrace//lib/datadog/tracing/contrib/httprb/instrumentation.rb#130
  def set_analytics_sample_rate(span, request_options); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/httprb/instrumentation.rb#124
  def should_skip_distributed_tracing?(client_config); end
end

# Description of Httprb integration
#
# source://ddtrace//lib/datadog/tracing/contrib/httprb/integration.rb#11
class Datadog::Tracing::Contrib::Httprb::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/httprb/integration.rb#31
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/httprb/integration.rb#35
  def patcher; end

  # source://ddtrace//lib/datadog/tracing/contrib/httprb/integration.rb#39
  def resolver; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/httprb/integration.rb#27
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/httprb/integration.rb#23
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/httprb/integration.rb#19
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/httprb/integration.rb#14
Datadog::Tracing::Contrib::Httprb::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'httprb' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/httprb/patcher.rb#11
module Datadog::Tracing::Contrib::Httprb::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # patch applies our patch
  #
  # source://ddtrace//lib/datadog/tracing/contrib/httprb/patcher.rb#27
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/httprb/patcher.rb#18
  def patched?; end

  # source://ddtrace//lib/datadog/tracing/contrib/httprb/patcher.rb#22
  def target_version; end

  class << self
    # patch applies our patch
    #
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#27
    def patched?; end

    # source://ddtrace//lib/datadog/tracing/contrib/httprb/patcher.rb#22
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/httprb/patcher.rb#14
Datadog::Tracing::Contrib::Httprb::Patcher::PATCH_ONLY_ONCE = T.let(T.unsafe(nil), Datadog::Core::Utils::OnlyOnce)

# {Integration} provides the basic contract of a tracing integration.
#
# An example for a simple instrumentation of a fictional `BillingApi::Client`:
#
# ```
# require 'ddtrace'
#
# module BillingApi
#   class Integration
#     include ::Datadog::Tracing::Contrib::Integration
#
#     register_as :billing_api # Register in the global tracing registry
#
#     def self.available?
#       defined?(::BillingApi::Client) # Check if the target for instrumentation is present.
#     end
#
#     def new_configuration
#       Settings.new
#     end
#
#     def patcher
#       Patcher
#     end
#   end
#
#   class Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
#     # Custom service name, if a separate service is desirable for BillingApi calls.
#     option :service, default: nil
#   end
#
#   module Patcher
#     include ::Datadog::Tracing::Contrib::Patcher
#
#     def self.patch
#       ::BillingApi::Client.prepend(Instrumentation)
#     end
#   end
#
#   module Instrumentation
#     def api_request!(env)
#       Tracing.trace('billing.request',
#                            type: 'http',
#                            service: Datadog.configuration.tracing[:billing_api][:service]) do |span|
#         span.resource = env[:route].to_s
#         span.set_tag('client_id', env[:client][:id])
#
#         super
#       end
#     end
#   end
# end
#
# Datadog.configure do |c|
#   c.tracing.instrument :billing_api # Settings (e.g. `service:`) can be provided as keyword arguments.
# end
# ```
#
# source://ddtrace//lib/datadog/tracing/contrib/integration.rb#69
module Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable

  mixes_in_class_methods ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/integration.rb#70
    def included(base); end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#6
module Datadog::Tracing::Contrib::Kafka; end

# source://ddtrace//lib/datadog/tracing/contrib/kafka/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Kafka::Configuration; end

# Custom settings for the Kafka integration
#
# source://ddtrace//lib/datadog/tracing/contrib/kafka/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Kafka::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# Defines basic behaviors for an event for a consumer.
#
# source://ddtrace//lib/datadog/tracing/contrib/kafka/consumer_event.rb#8
module Datadog::Tracing::Contrib::Kafka::ConsumerEvent
  # source://ddtrace//lib/datadog/tracing/contrib/kafka/consumer_event.rb#9
  def process(span, _event, _id, payload); end
end

# Defines basic behaviors for an event for a consumer group.
#
# source://ddtrace//lib/datadog/tracing/contrib/kafka/consumer_group_event.rb#8
module Datadog::Tracing::Contrib::Kafka::ConsumerGroupEvent
  # source://ddtrace//lib/datadog/tracing/contrib/kafka/consumer_group_event.rb#9
  def process(span, _event, _id, payload); end
end

# Defines basic behaviors for an ActiveSupport event.
#
# source://ddtrace//lib/datadog/tracing/contrib/kafka/event.rb#12
module Datadog::Tracing::Contrib::Kafka::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event

  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::Kafka::Event::ClassMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/kafka/event.rb#13
    def included(base); end
  end
end

# Class methods for Kafka events.
#
# source://ddtrace//lib/datadog/tracing/contrib/kafka/event.rb#19
module Datadog::Tracing::Contrib::Kafka::Event::ClassMethods
  # source://ddtrace//lib/datadog/tracing/contrib/kafka/event.rb#28
  def configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/event.rb#20
  def event_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/event.rb#32
  def process(span, _event, _id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/event.rb#24
  def span_options; end
end

# Defines collection of instrumented Kafka events
#
# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/connection/request.rb#8
module Datadog::Tracing::Contrib::Kafka::Events
  private

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/events.rb#33
  def all; end

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/events.rb#41
  def subscribe!; end

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/events.rb#37
  def subscriptions; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events.rb#33
    def all; end

    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events.rb#41
    def subscribe!; end

    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events.rb#37
    def subscriptions; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/kafka/events.rb#19
Datadog::Tracing::Contrib::Kafka::Events::ALL = T.let(T.unsafe(nil), Array)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/connection/request.rb#9
module Datadog::Tracing::Contrib::Kafka::Events::Connection; end

# Defines instrumentation for request.connection.kafka event
#
# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/connection/request.rb#11
module Datadog::Tracing::Contrib::Kafka::Events::Connection::Request
  include ::Datadog::Tracing::Contrib::Kafka::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/connection/request.rb#27
  def span_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/connection/request.rb#31
  def span_options; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/connection/request.rb#16
    def process(span, _event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/connection/request.rb#27
    def span_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/connection/request.rb#31
    def span_options; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/connection/request.rb#14
Datadog::Tracing::Contrib::Kafka::Events::Connection::Request::EVENT_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer/process_batch.rb#10
module Datadog::Tracing::Contrib::Kafka::Events::Consumer; end

# Defines instrumentation for process_batch.consumer.kafka event
#
# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer/process_batch.rb#12
module Datadog::Tracing::Contrib::Kafka::Events::Consumer::ProcessBatch
  include ::Datadog::Tracing::Contrib::Kafka::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::ConsumerEvent

  private

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer/process_batch.rb#34
  def span_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer/process_batch.rb#38
  def span_options; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer/process_batch.rb#18
    def process(span, _event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer/process_batch.rb#34
    def span_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer/process_batch.rb#38
    def span_options; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer/process_batch.rb#16
Datadog::Tracing::Contrib::Kafka::Events::Consumer::ProcessBatch::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for process_message.consumer.kafka event
#
# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer/process_message.rb#12
module Datadog::Tracing::Contrib::Kafka::Events::Consumer::ProcessMessage
  include ::Datadog::Tracing::Contrib::Kafka::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::ConsumerEvent

  private

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer/process_message.rb#32
  def span_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer/process_message.rb#36
  def span_options; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer/process_message.rb#18
    def process(span, _event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer/process_message.rb#32
    def span_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer/process_message.rb#36
    def span_options; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer/process_message.rb#16
Datadog::Tracing::Contrib::Kafka::Events::Consumer::ProcessMessage::EVENT_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/heartbeat.rb#11
module Datadog::Tracing::Contrib::Kafka::Events::ConsumerGroup; end

# Defines instrumentation for heartbeat.consumer.kafka event
#
# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/heartbeat.rb#13
module Datadog::Tracing::Contrib::Kafka::Events::ConsumerGroup::Heartbeat
  include ::Datadog::Tracing::Contrib::Kafka::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::ConsumerEvent
  extend ::Datadog::Tracing::Contrib::Kafka::ConsumerGroupEvent

  private

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/heartbeat.rb#32
  def span_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/heartbeat.rb#36
  def span_options; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/heartbeat.rb#20
    def process(span, _event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/heartbeat.rb#32
    def span_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/heartbeat.rb#36
    def span_options; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/heartbeat.rb#18
Datadog::Tracing::Contrib::Kafka::Events::ConsumerGroup::Heartbeat::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for join_group.consumer.kafka event
#
# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/join_group.rb#13
module Datadog::Tracing::Contrib::Kafka::Events::ConsumerGroup::JoinGroup
  include ::Datadog::Tracing::Contrib::Kafka::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::ConsumerEvent
  extend ::Datadog::Tracing::Contrib::Kafka::ConsumerGroupEvent

  private

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/join_group.rb#22
  def span_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/join_group.rb#26
  def span_options; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/join_group.rb#22
    def span_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/join_group.rb#26
    def span_options; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/join_group.rb#18
Datadog::Tracing::Contrib::Kafka::Events::ConsumerGroup::JoinGroup::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for leave_group.consumer.kafka event
#
# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/leave_group.rb#13
module Datadog::Tracing::Contrib::Kafka::Events::ConsumerGroup::LeaveGroup
  include ::Datadog::Tracing::Contrib::Kafka::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::ConsumerEvent
  extend ::Datadog::Tracing::Contrib::Kafka::ConsumerGroupEvent

  private

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/leave_group.rb#22
  def span_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/leave_group.rb#26
  def span_options; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/leave_group.rb#22
    def span_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/leave_group.rb#26
    def span_options; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/leave_group.rb#18
Datadog::Tracing::Contrib::Kafka::Events::ConsumerGroup::LeaveGroup::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for sync_group.consumer.kafka event
#
# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/sync_group.rb#13
module Datadog::Tracing::Contrib::Kafka::Events::ConsumerGroup::SyncGroup
  include ::Datadog::Tracing::Contrib::Kafka::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::ConsumerEvent
  extend ::Datadog::Tracing::Contrib::Kafka::ConsumerGroupEvent

  private

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/sync_group.rb#22
  def span_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/sync_group.rb#26
  def span_options; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/sync_group.rb#22
    def span_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/sync_group.rb#26
    def span_options; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/consumer_group/sync_group.rb#18
Datadog::Tracing::Contrib::Kafka::Events::ConsumerGroup::SyncGroup::EVENT_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/produce_operation/send_messages.rb#9
module Datadog::Tracing::Contrib::Kafka::Events::ProduceOperation; end

# Defines instrumentation for send_messages.producer.kafka event
#
# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/produce_operation/send_messages.rb#11
module Datadog::Tracing::Contrib::Kafka::Events::ProduceOperation::SendMessages
  include ::Datadog::Tracing::Contrib::Kafka::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/produce_operation/send_messages.rb#26
  def span_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/produce_operation/send_messages.rb#30
  def span_options; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/produce_operation/send_messages.rb#16
    def process(span, _event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/produce_operation/send_messages.rb#26
    def span_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/produce_operation/send_messages.rb#30
    def span_options; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/produce_operation/send_messages.rb#14
Datadog::Tracing::Contrib::Kafka::Events::ProduceOperation::SendMessages::EVENT_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/producer/deliver_messages.rb#9
module Datadog::Tracing::Contrib::Kafka::Events::Producer; end

# Defines instrumentation for deliver_messages.producer.kafka event
#
# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/producer/deliver_messages.rb#11
module Datadog::Tracing::Contrib::Kafka::Events::Producer::DeliverMessages
  include ::Datadog::Tracing::Contrib::Kafka::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Kafka::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/producer/deliver_messages.rb#29
  def span_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/producer/deliver_messages.rb#33
  def span_options; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/producer/deliver_messages.rb#16
    def process(span, _event, _id, payload); end

    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/producer/deliver_messages.rb#29
    def span_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/kafka/events/producer/deliver_messages.rb#33
    def span_options; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/kafka/events/producer/deliver_messages.rb#14
Datadog::Tracing::Contrib::Kafka::Events::Producer::DeliverMessages::EVENT_NAME = T.let(T.unsafe(nil), String)

# Kafka integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#9
module Datadog::Tracing::Contrib::Kafka::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#11
Datadog::Tracing::Contrib::Kafka::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#12
Datadog::Tracing::Contrib::Kafka::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#10
Datadog::Tracing::Contrib::Kafka::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#13
Datadog::Tracing::Contrib::Kafka::Ext::SPAN_CONNECTION_REQUEST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#14
Datadog::Tracing::Contrib::Kafka::Ext::SPAN_CONSUMER_HEARTBEAT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#15
Datadog::Tracing::Contrib::Kafka::Ext::SPAN_CONSUMER_JOIN_GROUP = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#16
Datadog::Tracing::Contrib::Kafka::Ext::SPAN_CONSUMER_LEAVE_GROUP = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#17
Datadog::Tracing::Contrib::Kafka::Ext::SPAN_CONSUMER_SYNC_GROUP = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#18
Datadog::Tracing::Contrib::Kafka::Ext::SPAN_DELIVER_MESSAGES = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#19
Datadog::Tracing::Contrib::Kafka::Ext::SPAN_PROCESS_BATCH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#20
Datadog::Tracing::Contrib::Kafka::Ext::SPAN_PROCESS_MESSAGE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#21
Datadog::Tracing::Contrib::Kafka::Ext::SPAN_SEND_MESSAGES = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#23
Datadog::Tracing::Contrib::Kafka::Ext::TAG_API = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#22
Datadog::Tracing::Contrib::Kafka::Ext::TAG_ATTEMPTS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#24
Datadog::Tracing::Contrib::Kafka::Ext::TAG_CLIENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#38
Datadog::Tracing::Contrib::Kafka::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#29
Datadog::Tracing::Contrib::Kafka::Ext::TAG_DELIVERED_MESSAGE_COUNT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#25
Datadog::Tracing::Contrib::Kafka::Ext::TAG_GROUP = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#26
Datadog::Tracing::Contrib::Kafka::Ext::TAG_HIGHWATER_MARK_OFFSET = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#49
Datadog::Tracing::Contrib::Kafka::Ext::TAG_KAFKA_BOOTSTRAP_SERVERS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#27
Datadog::Tracing::Contrib::Kafka::Ext::TAG_MESSAGE_COUNT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#28
Datadog::Tracing::Contrib::Kafka::Ext::TAG_MESSAGE_KEY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#48
Datadog::Tracing::Contrib::Kafka::Ext::TAG_MESSAGING_SYSTEM = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#30
Datadog::Tracing::Contrib::Kafka::Ext::TAG_OFFSET = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#31
Datadog::Tracing::Contrib::Kafka::Ext::TAG_OFFSET_LAG = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#39
Datadog::Tracing::Contrib::Kafka::Ext::TAG_OPERATION_CONNECTION_REQUEST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#40
Datadog::Tracing::Contrib::Kafka::Ext::TAG_OPERATION_CONSUMER_HEARTBEAT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#41
Datadog::Tracing::Contrib::Kafka::Ext::TAG_OPERATION_CONSUMER_JOIN_GROUP = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#42
Datadog::Tracing::Contrib::Kafka::Ext::TAG_OPERATION_CONSUMER_LEAVE_GROUP = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#43
Datadog::Tracing::Contrib::Kafka::Ext::TAG_OPERATION_CONSUMER_SYNC_GROUP = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#44
Datadog::Tracing::Contrib::Kafka::Ext::TAG_OPERATION_DELIVER_MESSAGES = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#45
Datadog::Tracing::Contrib::Kafka::Ext::TAG_OPERATION_PROCESS_BATCH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#46
Datadog::Tracing::Contrib::Kafka::Ext::TAG_OPERATION_PROCESS_MESSAGE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#47
Datadog::Tracing::Contrib::Kafka::Ext::TAG_OPERATION_SEND_MESSAGES = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#32
Datadog::Tracing::Contrib::Kafka::Ext::TAG_PARTITION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#33
Datadog::Tracing::Contrib::Kafka::Ext::TAG_REQUEST_SIZE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#34
Datadog::Tracing::Contrib::Kafka::Ext::TAG_RESPONSE_SIZE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#35
Datadog::Tracing::Contrib::Kafka::Ext::TAG_SENT_MESSAGE_COUNT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#36
Datadog::Tracing::Contrib::Kafka::Ext::TAG_TOPIC = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/kafka/ext.rb#37
Datadog::Tracing::Contrib::Kafka::Ext::TAG_TOPIC_PARTITIONS = T.let(T.unsafe(nil), String)

# Description of Kafka integration
#
# source://ddtrace//lib/datadog/tracing/contrib/kafka/integration.rb#10
class Datadog::Tracing::Contrib::Kafka::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/integration.rb#31
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/integration.rb#35
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/kafka/integration.rb#27
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/kafka/integration.rb#22
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/kafka/integration.rb#18
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/kafka/integration.rb#13
Datadog::Tracing::Contrib::Kafka::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'kafka' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/kafka/patcher.rb#12
module Datadog::Tracing::Contrib::Kafka::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/patcher.rb#21
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/kafka/patcher.rb#17
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/kafka/patcher.rb#17
    def target_version; end
  end
end

# Datadog Lograge integration.
#
# source://ddtrace//lib/datadog/tracing/contrib/lograge/ext.rb#6
module Datadog::Tracing::Contrib::Lograge; end

# source://ddtrace//lib/datadog/tracing/contrib/lograge/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Lograge::Configuration; end

# Custom settings for the Lograge integration
#
# source://ddtrace//lib/datadog/tracing/contrib/lograge/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Lograge::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end
end

# Lograge integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/lograge/ext.rb#9
module Datadog::Tracing::Contrib::Lograge::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/lograge/ext.rb#10
Datadog::Tracing::Contrib::Lograge::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# Instrumentation for Lograge
#
# source://ddtrace//lib/datadog/tracing/contrib/lograge/instrumentation.rb#10
module Datadog::Tracing::Contrib::Lograge::Instrumentation
  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/lograge/instrumentation.rb#11
    def included(base); end
  end
end

# Instance methods for configuration
#
# source://ddtrace//lib/datadog/tracing/contrib/lograge/instrumentation.rb#16
module Datadog::Tracing::Contrib::Lograge::Instrumentation::InstanceMethods
  # source://ddtrace//lib/datadog/tracing/contrib/lograge/instrumentation.rb#17
  def custom_options(event); end
end

# Description of Lograge integration
#
# source://ddtrace//lib/datadog/tracing/contrib/lograge/integration.rb#10
class Datadog::Tracing::Contrib::Lograge::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # enabled by rails integration and has a hard dependancy on rails
  # so can safely say this shouldn't ever be part of auto instrumentation
  # https://github.com/roidrage/lograge/blob/1729eab7956bb95c5992e4adab251e4f93ff9280/lograge.gemspec#L18-L20
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/lograge/integration.rb#33
  def auto_instrument?; end

  # source://ddtrace//lib/datadog/tracing/contrib/lograge/integration.rb#37
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/lograge/integration.rb#41
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/lograge/integration.rb#26
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/lograge/integration.rb#22
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/lograge/integration.rb#18
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/lograge/integration.rb#13
Datadog::Tracing::Contrib::Lograge::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'lograge' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/lograge/patcher.rb#12
module Datadog::Tracing::Contrib::Lograge::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # patch applies our patch
  #
  # source://ddtrace//lib/datadog/tracing/contrib/lograge/patcher.rb#22
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/lograge/patcher.rb#17
  def target_version; end

  class << self
    # patch applies our patch
    #
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/lograge/patcher.rb#17
    def target_version; end
  end
end

# MongoDB module includes classes and functions to instrument MongoDB clients
#
# source://ddtrace//lib/datadog/tracing/contrib/mongodb/ext.rb#6
module Datadog::Tracing::Contrib::MongoDB
  private

  # source://ddtrace//lib/datadog/tracing/contrib/mongodb/parsers.rb#41
  def configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/mongodb/parsers.rb#37
  def quantization_options; end

  # returns a formatted and normalized query
  #
  # source://ddtrace//lib/datadog/tracing/contrib/mongodb/parsers.rb#19
  def query_builder(command_name, database_name, command); end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/mongodb/parsers.rb#41
    def configuration; end

    # source://ddtrace//lib/datadog/tracing/contrib/mongodb/parsers.rb#37
    def quantization_options; end

    # returns a formatted and normalized query
    #
    # source://ddtrace//lib/datadog/tracing/contrib/mongodb/parsers.rb#19
    def query_builder(command_name, database_name, command); end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/configuration/settings.rb#10
module Datadog::Tracing::Contrib::MongoDB::Configuration; end

# Custom settings for the MongoDB integration
#
# source://ddtrace//lib/datadog/tracing/contrib/mongodb/configuration/settings.rb#13
class Datadog::Tracing::Contrib::MongoDB::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def peer_service; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def peer_service=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def quantize; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def quantize=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/configuration/settings.rb#14
Datadog::Tracing::Contrib::MongoDB::Configuration::Settings::DEFAULT_QUANTIZE = T.let(T.unsafe(nil), Hash)

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/parsers.rb#10
Datadog::Tracing::Contrib::MongoDB::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/parsers.rb#8
Datadog::Tracing::Contrib::MongoDB::EXCLUDE_KEYS = T.let(T.unsafe(nil), Array)

# MongoDB integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/mongodb/ext.rb#9
module Datadog::Tracing::Contrib::MongoDB::Ext; end

# Temporary namespace to accommodate unified tags which has naming collision, before
# making breaking changes
#
# source://ddtrace//lib/datadog/tracing/contrib/mongodb/ext.rb#30
module Datadog::Tracing::Contrib::MongoDB::Ext::DB; end

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/ext.rb#31
Datadog::Tracing::Contrib::MongoDB::Ext::DB::TAG_COLLECTION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/ext.rb#15
Datadog::Tracing::Contrib::MongoDB::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/ext.rb#13
Datadog::Tracing::Contrib::MongoDB::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/ext.rb#14
Datadog::Tracing::Contrib::MongoDB::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/ext.rb#10
Datadog::Tracing::Contrib::MongoDB::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/ext.rb#12
Datadog::Tracing::Contrib::MongoDB::Ext::ENV_PEER_SERVICE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/ext.rb#11
Datadog::Tracing::Contrib::MongoDB::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/ext.rb#26
Datadog::Tracing::Contrib::MongoDB::Ext::PEER_SERVICE_SOURCES = T.let(T.unsafe(nil), Array)

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/ext.rb#16
Datadog::Tracing::Contrib::MongoDB::Ext::SPAN_COMMAND = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/ext.rb#17
Datadog::Tracing::Contrib::MongoDB::Ext::SPAN_TYPE_COMMAND = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/ext.rb#18
Datadog::Tracing::Contrib::MongoDB::Ext::TAG_COLLECTION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/ext.rb#23
Datadog::Tracing::Contrib::MongoDB::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/ext.rb#19
Datadog::Tracing::Contrib::MongoDB::Ext::TAG_DB = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/ext.rb#20
Datadog::Tracing::Contrib::MongoDB::Ext::TAG_OPERATION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/ext.rb#24
Datadog::Tracing::Contrib::MongoDB::Ext::TAG_OPERATION_COMMAND = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/ext.rb#21
Datadog::Tracing::Contrib::MongoDB::Ext::TAG_QUERY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/ext.rb#22
Datadog::Tracing::Contrib::MongoDB::Ext::TAG_ROWS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/ext.rb#25
Datadog::Tracing::Contrib::MongoDB::Ext::TAG_SYSTEM = T.let(T.unsafe(nil), String)

# Instrumentation for Mongo integration
#
# source://ddtrace//lib/datadog/tracing/contrib/mongodb/instrumentation.rb#12
module Datadog::Tracing::Contrib::MongoDB::Instrumentation; end

# Instrumentation for Mongo::Client
#
# source://ddtrace//lib/datadog/tracing/contrib/mongodb/instrumentation.rb#14
module Datadog::Tracing::Contrib::MongoDB::Instrumentation::Client
  include ::Datadog::Tracing::Contrib::MongoDB::Instrumentation::Client::InstanceMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/mongodb/instrumentation.rb#15
    def included(base); end
  end
end

# Instance methods for Mongo::Client
#
# source://ddtrace//lib/datadog/tracing/contrib/mongodb/instrumentation.rb#20
module Datadog::Tracing::Contrib::MongoDB::Instrumentation::Client::InstanceMethods
  # source://ddtrace//lib/datadog/tracing/contrib/mongodb/instrumentation.rb#21
  def datadog_pin; end

  # source://ddtrace//lib/datadog/tracing/contrib/mongodb/instrumentation.rb#30
  def datadog_pin=(pin); end
end

# Description of MongoDB integration
#
# source://ddtrace//lib/datadog/tracing/contrib/mongodb/integration.rb#11
class Datadog::Tracing::Contrib::MongoDB::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/mongodb/integration.rb#31
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/mongodb/integration.rb#35
  def patcher; end

  # source://ddtrace//lib/datadog/tracing/contrib/mongodb/integration.rb#39
  def resolver; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/mongodb/integration.rb#27
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/mongodb/integration.rb#23
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/mongodb/integration.rb#19
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/integration.rb#14
Datadog::Tracing::Contrib::MongoDB::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# `MongoCommandSubscriber` listens to all events from the `Monitoring`
# system available in the Mongo driver.
#
# source://ddtrace//lib/datadog/tracing/contrib/mongodb/subscribers.rb#13
class Datadog::Tracing::Contrib::MongoDB::MongoCommandSubscriber
  # source://ddtrace//lib/datadog/tracing/contrib/mongodb/subscribers.rb#67
  def failed(event); end

  # source://ddtrace//lib/datadog/tracing/contrib/mongodb/subscribers.rb#14
  def started(event); end

  # source://ddtrace//lib/datadog/tracing/contrib/mongodb/subscribers.rb#83
  def succeeded(event); end

  private

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/mongodb/subscribers.rb#117
  def analytics_enabled?; end

  # source://ddtrace//lib/datadog/tracing/contrib/mongodb/subscribers.rb#121
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/tracing/contrib/mongodb/subscribers.rb#111
  def clear_span(event); end

  # source://ddtrace//lib/datadog/tracing/contrib/mongodb/subscribers.rb#125
  def datadog_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/mongodb/subscribers.rb#101
  def get_span(event); end

  # source://ddtrace//lib/datadog/tracing/contrib/mongodb/subscribers.rb#106
  def set_span(event, span); end
end

# skipped keys are related to command names, since they are already
# extracted by the query_builder
#
# source://ddtrace//lib/datadog/tracing/contrib/mongodb/parsers.rb#16
Datadog::Tracing::Contrib::MongoDB::PLACEHOLDER = T.let(T.unsafe(nil), String)

# Patcher enables patching of 'mongo' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/mongodb/patcher.rb#12
module Datadog::Tracing::Contrib::MongoDB::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/mongodb/patcher.rb#26
  def add_mongo_monitoring; end

  # source://ddtrace//lib/datadog/tracing/contrib/mongodb/patcher.rb#21
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/mongodb/patcher.rb#17
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/mongodb/patcher.rb#26
    def add_mongo_monitoring; end

    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/mongodb/patcher.rb#17
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/mongodb/parsers.rb#9
Datadog::Tracing::Contrib::MongoDB::SHOW_KEYS = T.let(T.unsafe(nil), Array)

# source://ddtrace//lib/datadog/tracing/contrib/mysql2/ext.rb#6
module Datadog::Tracing::Contrib::Mysql2; end

# source://ddtrace//lib/datadog/tracing/contrib/mysql2/configuration/settings.rb#12
module Datadog::Tracing::Contrib::Mysql2::Configuration; end

# Custom settings for the Mysql2 integration
#
# source://ddtrace//lib/datadog/tracing/contrib/mysql2/configuration/settings.rb#15
class Datadog::Tracing::Contrib::Mysql2::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def comment_propagation; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def comment_propagation=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def peer_service; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def peer_service=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# Mysql2 integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/mysql2/ext.rb#9
module Datadog::Tracing::Contrib::Mysql2::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/mysql2/ext.rb#16
Datadog::Tracing::Contrib::Mysql2::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mysql2/ext.rb#14
Datadog::Tracing::Contrib::Mysql2::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mysql2/ext.rb#15
Datadog::Tracing::Contrib::Mysql2::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mysql2/ext.rb#10
Datadog::Tracing::Contrib::Mysql2::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mysql2/ext.rb#12
Datadog::Tracing::Contrib::Mysql2::Ext::ENV_PEER_SERVICE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mysql2/ext.rb#11
Datadog::Tracing::Contrib::Mysql2::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mysql2/ext.rb#22
Datadog::Tracing::Contrib::Mysql2::Ext::PEER_SERVICE_SOURCES = T.let(T.unsafe(nil), Array)

# source://ddtrace//lib/datadog/tracing/contrib/mysql2/ext.rb#17
Datadog::Tracing::Contrib::Mysql2::Ext::SPAN_QUERY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mysql2/ext.rb#19
Datadog::Tracing::Contrib::Mysql2::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mysql2/ext.rb#18
Datadog::Tracing::Contrib::Mysql2::Ext::TAG_DB_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mysql2/ext.rb#20
Datadog::Tracing::Contrib::Mysql2::Ext::TAG_OPERATION_QUERY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/mysql2/ext.rb#21
Datadog::Tracing::Contrib::Mysql2::Ext::TAG_SYSTEM = T.let(T.unsafe(nil), String)

# Mysql2::Client patch module
#
# source://ddtrace//lib/datadog/tracing/contrib/mysql2/instrumentation.rb#15
module Datadog::Tracing::Contrib::Mysql2::Instrumentation
  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/mysql2/instrumentation.rb#16
    def included(base); end
  end
end

# Mysql2::Client patch instance methods
#
# source://ddtrace//lib/datadog/tracing/contrib/mysql2/instrumentation.rb#21
module Datadog::Tracing::Contrib::Mysql2::Instrumentation::InstanceMethods
  # source://ddtrace//lib/datadog/tracing/contrib/mysql2/instrumentation.rb#22
  def query(sql, options = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/mysql2/instrumentation.rb#68
  def analytics_enabled?; end

  # source://ddtrace//lib/datadog/tracing/contrib/mysql2/instrumentation.rb#72
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/tracing/contrib/mysql2/instrumentation.rb#76
  def comment_propagation; end

  # source://ddtrace//lib/datadog/tracing/contrib/mysql2/instrumentation.rb#64
  def datadog_configuration; end
end

# Description of Mysql2 integration
#
# source://ddtrace//lib/datadog/tracing/contrib/mysql2/integration.rb#10
class Datadog::Tracing::Contrib::Mysql2::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/mysql2/integration.rb#30
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/mysql2/integration.rb#34
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/mysql2/integration.rb#26
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/mysql2/integration.rb#22
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/mysql2/integration.rb#18
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/mysql2/integration.rb#13
Datadog::Tracing::Contrib::Mysql2::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'mysql2' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/mysql2/patcher.rb#11
module Datadog::Tracing::Contrib::Mysql2::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/mysql2/patcher.rb#20
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/mysql2/patcher.rb#24
  def patch_mysql2_client; end

  # source://ddtrace//lib/datadog/tracing/contrib/mysql2/patcher.rb#16
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/mysql2/patcher.rb#24
    def patch_mysql2_client; end

    # source://ddtrace//lib/datadog/tracing/contrib/mysql2/patcher.rb#16
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/opensearch/ext.rb#6
module Datadog::Tracing::Contrib::OpenSearch; end

# source://ddtrace//lib/datadog/tracing/contrib/opensearch/configuration/settings.rb#10
module Datadog::Tracing::Contrib::OpenSearch::Configuration; end

# Custom settings for the OpenSearch integration
#
# source://ddtrace//lib/datadog/tracing/contrib/opensearch/configuration/settings.rb#13
class Datadog::Tracing::Contrib::OpenSearch::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def peer_service; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def peer_service=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def quantize; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def quantize=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# OpenSearch integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/opensearch/ext.rb#9
module Datadog::Tracing::Contrib::OpenSearch::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/opensearch/ext.rb#15
Datadog::Tracing::Contrib::OpenSearch::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/opensearch/ext.rb#13
Datadog::Tracing::Contrib::OpenSearch::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/opensearch/ext.rb#14
Datadog::Tracing::Contrib::OpenSearch::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/opensearch/ext.rb#10
Datadog::Tracing::Contrib::OpenSearch::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/opensearch/ext.rb#12
Datadog::Tracing::Contrib::OpenSearch::Ext::ENV_PEER_SERVICE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/opensearch/ext.rb#11
Datadog::Tracing::Contrib::OpenSearch::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/opensearch/ext.rb#29
Datadog::Tracing::Contrib::OpenSearch::Ext::PEER_SERVICE_SOURCES = T.let(T.unsafe(nil), Array)

# source://ddtrace//lib/datadog/tracing/contrib/opensearch/ext.rb#16
Datadog::Tracing::Contrib::OpenSearch::Ext::SPAN_QUERY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/opensearch/ext.rb#17
Datadog::Tracing::Contrib::OpenSearch::Ext::SPAN_TYPE_QUERY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/opensearch/ext.rb#23
Datadog::Tracing::Contrib::OpenSearch::Ext::TAG_BODY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/opensearch/ext.rb#18
Datadog::Tracing::Contrib::OpenSearch::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/opensearch/ext.rb#25
Datadog::Tracing::Contrib::OpenSearch::Ext::TAG_HOST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/opensearch/ext.rb#20
Datadog::Tracing::Contrib::OpenSearch::Ext::TAG_METHOD = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/opensearch/ext.rb#22
Datadog::Tracing::Contrib::OpenSearch::Ext::TAG_PARAMS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/opensearch/ext.rb#21
Datadog::Tracing::Contrib::OpenSearch::Ext::TAG_PATH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/opensearch/ext.rb#26
Datadog::Tracing::Contrib::OpenSearch::Ext::TAG_PORT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/opensearch/ext.rb#28
Datadog::Tracing::Contrib::OpenSearch::Ext::TAG_RESPONSE_CONTENT_LENGTH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/opensearch/ext.rb#27
Datadog::Tracing::Contrib::OpenSearch::Ext::TAG_SCHEME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/opensearch/ext.rb#19
Datadog::Tracing::Contrib::OpenSearch::Ext::TAG_SYSTEM = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/opensearch/ext.rb#24
Datadog::Tracing::Contrib::OpenSearch::Ext::TAG_URL = T.let(T.unsafe(nil), String)

# Description of OpenSearch integration
#
# source://ddtrace//lib/datadog/tracing/contrib/opensearch/integration.rb#12
class Datadog::Tracing::Contrib::OpenSearch::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/opensearch/integration.rb#33
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/opensearch/integration.rb#37
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/opensearch/integration.rb#29
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/opensearch/integration.rb#25
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/opensearch/integration.rb#20
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/opensearch/integration.rb#15
Datadog::Tracing::Contrib::OpenSearch::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'opensearch' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/opensearch/patcher.rb#15
module Datadog::Tracing::Contrib::OpenSearch::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/opensearch/patcher.rb#20
  def patch; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end
  end
end

# Patches OpenSearch::Transport::Client module
#
# source://ddtrace//lib/datadog/tracing/contrib/opensearch/patcher.rb#29
module Datadog::Tracing::Contrib::OpenSearch::Patcher::Client
  # source://ddtrace//lib/datadog/tracing/contrib/opensearch/patcher.rb#119
  def datadog_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/opensearch/patcher.rb#31
  def perform_request(method, path, params = T.unsafe(nil), body = T.unsafe(nil), headers = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/contrib/opensearch/patcher.rb#107
  def tag_body(body, span); end

  # source://ddtrace//lib/datadog/tracing/contrib/opensearch/patcher.rb#100
  def tag_params(params, span); end
end

# Base provides features that are shared across all integrations
#
# source://ddtrace//lib/datadog/tracing/contrib/patchable.rb#7
module Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods

  mixes_in_class_methods ::Datadog::Tracing::Contrib::Patchable::ClassMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/patchable.rb#8
    def included(base); end
  end
end

# Class methods for integrations
#
# source://ddtrace//lib/datadog/tracing/contrib/patchable.rb#15
module Datadog::Tracing::Contrib::Patchable::ClassMethods
  # Is the target available to be instrumented? (e.g. gem installed?)
  #
  # The target doesn't have to be loaded (e.g. `require`) yet, but needs to be able
  # to be loaded before instrumentation can commence.
  #
  # By default, {.available?} checks if {.version} returned a non-nil object.
  #
  # If the target for instrumentation has concept of versioning, override {.version},
  # otherwise override {.available?} and implement a custom target presence check.
  #
  # @return [Boolean] is the target available for instrumentation in this Ruby environment?
  #
  # source://ddtrace//lib/datadog/tracing/contrib/patchable.rb#37
  def available?; end

  # Is this instrumentation compatible with the available target? (e.g. minimum version met?)
  #
  # @return [Boolean] is the available target compatible with this instrumentation?
  #
  # source://ddtrace//lib/datadog/tracing/contrib/patchable.rb#53
  def compatible?; end

  # Is the target loaded into the application? (e.g. gem required? Constant defined?)
  #
  # The target's objects should be ready to be referenced by the instrumented when {.loaded}
  # returns `true`.
  #
  # @return [Boolean] is the target ready to be referenced during instrumentation?
  #
  # source://ddtrace//lib/datadog/tracing/contrib/patchable.rb#47
  def loaded?; end

  # Can the patch for this integration be applied?
  #
  # By default, this is equivalent to {#available?}, {#loaded?}, and {#compatible?}
  # all being truthy.
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/patchable.rb#61
  def patchable?; end

  # Version of the integration target code in the environment.
  #
  # This is the gem version, when the instrumentation target is a Ruby gem.
  #
  # If the target for instrumentation has concept of versioning, override {.version},
  # otherwise override {.available?} and implement a custom target presence check.
  #
  # @return [Object] the target version
  #
  # source://ddtrace//lib/datadog/tracing/contrib/patchable.rb#23
  def version; end
end

# Instance methods for integrations
#
# source://ddtrace//lib/datadog/tracing/contrib/patchable.rb#68
module Datadog::Tracing::Contrib::Patchable::InstanceMethods
  # Can the patch for this integration be applied automatically?
  # For example: test integrations should only be applied
  # by the user explicitly setting `c.ci.instrument :rspec`
  # and rails sub-modules are auto-instrumented by enabling rails
  # so auto-instrumenting them on their own will cause changes in
  # service naming behavior
  #
  # @return [Boolean] can the tracer activate this instrumentation without explicit user input?
  #
  # source://ddtrace//lib/datadog/tracing/contrib/patchable.rb#102
  def auto_instrument?; end

  # source://ddtrace//lib/datadog/tracing/contrib/patchable.rb#80
  def patch; end

  # The patcher module to inject instrumented objects into the instrumentation target.
  #
  # {Contrib::Patcher} includes the basic functionality of a patcher. `include`ing
  # {Contrib::Patcher} into a new module is the recommend way to create a custom patcher.
  #
  # @return [Contrib::Patcher] a module that `include`s {Contrib::Patcher}
  #
  # source://ddtrace//lib/datadog/tracing/contrib/patchable.rb#75
  def patcher; end
end

# Common behavior for patcher modules.
#
# `include`ing {Contrib::Patcher} into a new module is the recommend way to create a custom patcher.
# The patcher can then be provided to a custom {Datadog::Tracing::Contrib::Integration} for instrumentation.
#
# source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#10
module Datadog::Tracing::Contrib::Patcher
  mixes_in_class_methods ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#11
    def included(base); end
  end
end

# Prepended instance methods for all patchers
#
# source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#18
module Datadog::Tracing::Contrib::Patcher::CommonMethods
  # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#66
  def default_tags; end

  # Processes patching errors. This default implementation logs the error and reports relevant metrics.
  #
  # @param e [Exception]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#49
  def on_patch_error(e); end

  # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
  def patch; end

  # Returns the value of attribute patch_error_result.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#19
  def patch_error_result; end

  # Sets the attribute patch_error_result
  #
  # @param value the value to set the attribute patch_error_result to.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#19
  def patch_error_result=(_arg0); end

  # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#23
  def patch_name; end

  # Returns the value of attribute patch_successful.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#19
  def patch_successful; end

  # Sets the attribute patch_successful
  #
  # @param value the value to set the attribute patch_successful to.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#19
  def patch_successful=(_arg0); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#27
  def patched?; end

  private

  # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#75
  def patch_only_once; end
end

# source://ddtrace//lib/datadog/tracing/contrib/pg/ext.rb#6
module Datadog::Tracing::Contrib::Pg; end

# source://ddtrace//lib/datadog/tracing/contrib/pg/configuration/settings.rb#12
module Datadog::Tracing::Contrib::Pg::Configuration; end

# Custom settings for the Pg integration
#
# source://ddtrace//lib/datadog/tracing/contrib/pg/configuration/settings.rb#15
class Datadog::Tracing::Contrib::Pg::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def comment_propagation; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def comment_propagation=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def peer_service; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def peer_service=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# pg integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/pg/ext.rb#9
module Datadog::Tracing::Contrib::Pg::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/pg/ext.rb#15
Datadog::Tracing::Contrib::Pg::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/pg/ext.rb#13
Datadog::Tracing::Contrib::Pg::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/pg/ext.rb#14
Datadog::Tracing::Contrib::Pg::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/pg/ext.rb#10
Datadog::Tracing::Contrib::Pg::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/pg/ext.rb#12
Datadog::Tracing::Contrib::Pg::Ext::ENV_PEER_SERVICE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/pg/ext.rb#11
Datadog::Tracing::Contrib::Pg::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/pg/ext.rb#29
Datadog::Tracing::Contrib::Pg::Ext::PEER_SERVICE_SOURCES = T.let(T.unsafe(nil), Array)

# source://ddtrace//lib/datadog/tracing/contrib/pg/ext.rb#19
Datadog::Tracing::Contrib::Pg::Ext::SPAN_ASYNC_EXEC = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/pg/ext.rb#20
Datadog::Tracing::Contrib::Pg::Ext::SPAN_ASYNC_EXEC_PARAMS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/pg/ext.rb#21
Datadog::Tracing::Contrib::Pg::Ext::SPAN_ASYNC_EXEC_PREPARED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/pg/ext.rb#16
Datadog::Tracing::Contrib::Pg::Ext::SPAN_EXEC = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/pg/ext.rb#17
Datadog::Tracing::Contrib::Pg::Ext::SPAN_EXEC_PARAMS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/pg/ext.rb#18
Datadog::Tracing::Contrib::Pg::Ext::SPAN_EXEC_PREPARED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/pg/ext.rb#22
Datadog::Tracing::Contrib::Pg::Ext::SPAN_SYNC_EXEC = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/pg/ext.rb#23
Datadog::Tracing::Contrib::Pg::Ext::SPAN_SYNC_EXEC_PARAMS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/pg/ext.rb#24
Datadog::Tracing::Contrib::Pg::Ext::SPAN_SYNC_EXEC_PREPARED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/pg/ext.rb#26
Datadog::Tracing::Contrib::Pg::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/pg/ext.rb#25
Datadog::Tracing::Contrib::Pg::Ext::TAG_DB_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/pg/ext.rb#27
Datadog::Tracing::Contrib::Pg::Ext::TAG_OPERATION_QUERY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/pg/ext.rb#28
Datadog::Tracing::Contrib::Pg::Ext::TAG_SYSTEM = T.let(T.unsafe(nil), String)

# PG::Connection patch module
#
# source://ddtrace//lib/datadog/tracing/contrib/pg/instrumentation.rb#16
module Datadog::Tracing::Contrib::Pg::Instrumentation
  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/pg/instrumentation.rb#17
    def included(base); end
  end
end

# PG::Connection patch methods
#
# source://ddtrace//lib/datadog/tracing/contrib/pg/instrumentation.rb#22
module Datadog::Tracing::Contrib::Pg::Instrumentation::InstanceMethods
  # async_exec is an alias to exec
  #
  # source://ddtrace//lib/datadog/tracing/contrib/pg/instrumentation.rb#42
  def async_exec(sql, *args, &block); end

  # async_exec_params is an alias to exec_params
  #
  # source://ddtrace//lib/datadog/tracing/contrib/pg/instrumentation.rb#49
  def async_exec_params(sql, params, *args, &block); end

  # async_exec_prepared is an alias to exec_prepared
  #
  # source://ddtrace//lib/datadog/tracing/contrib/pg/instrumentation.rb#56
  def async_exec_prepared(statement_name, params, *args, &block); end

  # source://ddtrace//lib/datadog/tracing/contrib/pg/instrumentation.rb#23
  def exec(sql, *args, &block); end

  # source://ddtrace//lib/datadog/tracing/contrib/pg/instrumentation.rb#29
  def exec_params(sql, params, *args, &block); end

  # source://ddtrace//lib/datadog/tracing/contrib/pg/instrumentation.rb#35
  def exec_prepared(statement_name, params, *args, &block); end

  # source://ddtrace//lib/datadog/tracing/contrib/pg/instrumentation.rb#62
  def sync_exec(sql, *args, &block); end

  # source://ddtrace//lib/datadog/tracing/contrib/pg/instrumentation.rb#68
  def sync_exec_params(sql, params, *args, &block); end

  # source://ddtrace//lib/datadog/tracing/contrib/pg/instrumentation.rb#74
  def sync_exec_prepared(statement_name, params, *args, &block); end

  private

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/pg/instrumentation.rb#159
  def analytics_enabled?; end

  # source://ddtrace//lib/datadog/tracing/contrib/pg/instrumentation.rb#163
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/tracing/contrib/pg/instrumentation.rb#122
  def annotate_span_with_query!(span, service); end

  # @param result [PG::Result]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/pg/instrumentation.rb#151
  def annotate_span_with_result!(span, result); end

  # source://ddtrace//lib/datadog/tracing/contrib/pg/instrumentation.rb#167
  def comment_propagation; end

  # source://ddtrace//lib/datadog/tracing/contrib/pg/instrumentation.rb#155
  def datadog_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/pg/instrumentation.rb#82
  def trace(name, sql: T.unsafe(nil), statement_name: T.unsafe(nil), block: T.unsafe(nil)); end
end

# Description of pg integration
#
# source://ddtrace//lib/datadog/tracing/contrib/pg/integration.rb#10
class Datadog::Tracing::Contrib::Pg::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/pg/integration.rb#30
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/pg/integration.rb#34
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/pg/integration.rb#26
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/pg/integration.rb#22
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/pg/integration.rb#18
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/pg/integration.rb#13
Datadog::Tracing::Contrib::Pg::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'pg' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/pg/patcher.rb#11
module Datadog::Tracing::Contrib::Pg::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/pg/patcher.rb#20
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/pg/patcher.rb#24
  def patch_pg_connection; end

  # source://ddtrace//lib/datadog/tracing/contrib/pg/patcher.rb#16
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/pg/patcher.rb#24
    def patch_pg_connection; end

    # source://ddtrace//lib/datadog/tracing/contrib/pg/patcher.rb#16
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#6
module Datadog::Tracing::Contrib::Presto; end

# source://ddtrace//lib/datadog/tracing/contrib/presto/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Presto::Configuration; end

# Custom settings for the Presto integration
#
# source://ddtrace//lib/datadog/tracing/contrib/presto/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Presto::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def peer_service; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def peer_service=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# Presto integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#9
module Datadog::Tracing::Contrib::Presto::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#15
Datadog::Tracing::Contrib::Presto::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#13
Datadog::Tracing::Contrib::Presto::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#14
Datadog::Tracing::Contrib::Presto::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#10
Datadog::Tracing::Contrib::Presto::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#12
Datadog::Tracing::Contrib::Presto::Ext::ENV_PEER_SERVICE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#11
Datadog::Tracing::Contrib::Presto::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#31
Datadog::Tracing::Contrib::Presto::Ext::PEER_SERVICE_SOURCES = T.let(T.unsafe(nil), Array)

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#17
Datadog::Tracing::Contrib::Presto::Ext::SPAN_KILL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#16
Datadog::Tracing::Contrib::Presto::Ext::SPAN_QUERY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#19
Datadog::Tracing::Contrib::Presto::Ext::TAG_CATALOG_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#27
Datadog::Tracing::Contrib::Presto::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#22
Datadog::Tracing::Contrib::Presto::Ext::TAG_LANGUAGE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#24
Datadog::Tracing::Contrib::Presto::Ext::TAG_MODEL_VERSION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#29
Datadog::Tracing::Contrib::Presto::Ext::TAG_OPERATION_KILL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#28
Datadog::Tracing::Contrib::Presto::Ext::TAG_OPERATION_QUERY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#23
Datadog::Tracing::Contrib::Presto::Ext::TAG_PROXY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#26
Datadog::Tracing::Contrib::Presto::Ext::TAG_QUERY_ASYNC = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#25
Datadog::Tracing::Contrib::Presto::Ext::TAG_QUERY_ID = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#18
Datadog::Tracing::Contrib::Presto::Ext::TAG_SCHEMA_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#30
Datadog::Tracing::Contrib::Presto::Ext::TAG_SYSTEM = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#21
Datadog::Tracing::Contrib::Presto::Ext::TAG_TIME_ZONE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/presto/ext.rb#20
Datadog::Tracing::Contrib::Presto::Ext::TAG_USER_NAME = T.let(T.unsafe(nil), String)

# Instrumentation for Presto integration
#
# source://ddtrace//lib/datadog/tracing/contrib/presto/instrumentation.rb#9
module Datadog::Tracing::Contrib::Presto::Instrumentation; end

# Instrumentation for Presto::Client::Client
#
# source://ddtrace//lib/datadog/tracing/contrib/presto/instrumentation.rb#11
module Datadog::Tracing::Contrib::Presto::Instrumentation::Client
  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/presto/instrumentation.rb#12
    def included(base); end
  end
end

# Instance methods for Presto::Client
#
# source://ddtrace//lib/datadog/tracing/contrib/presto/instrumentation.rb#17
module Datadog::Tracing::Contrib::Presto::Instrumentation::Client::InstanceMethods
  # source://ddtrace//lib/datadog/tracing/contrib/presto/instrumentation.rb#54
  def kill(query_id); end

  # source://ddtrace//lib/datadog/tracing/contrib/presto/instrumentation.rb#36
  def query(query, &blk); end

  # source://ddtrace//lib/datadog/tracing/contrib/presto/instrumentation.rb#18
  def run(query); end

  private

  # source://ddtrace//lib/datadog/tracing/contrib/presto/instrumentation.rb#75
  def datadog_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/presto/instrumentation.rb#79
  def decorate!(span, operation); end

  # source://ddtrace//lib/datadog/tracing/contrib/presto/instrumentation.rb#122
  def set_nilable_tag!(span, key, tag_name); end
end

# Description of Presto integration
#
# source://ddtrace//lib/datadog/tracing/contrib/presto/integration.rb#10
class Datadog::Tracing::Contrib::Presto::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/presto/integration.rb#30
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/presto/integration.rb#34
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/presto/integration.rb#26
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/presto/integration.rb#22
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/presto/integration.rb#18
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/presto/integration.rb#13
Datadog::Tracing::Contrib::Presto::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'presto-client' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/presto/patcher.rb#11
module Datadog::Tracing::Contrib::Presto::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/presto/patcher.rb#22
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/presto/patcher.rb#18
  def patched?; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#27
    def patched?; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/presto/patcher.rb#14
Datadog::Tracing::Contrib::Presto::Patcher::PATCH_ONLY_ONCE = T.let(T.unsafe(nil), Datadog::Core::Utils::OnlyOnce)

# source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment/comment.rb#8
module Datadog::Tracing::Contrib::Propagation; end

# Implements sql comment propagation related contracts.
#
# source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment/comment.rb#9
module Datadog::Tracing::Contrib::Propagation::SqlComment
  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment.rb#12
    def annotate!(span_op, mode); end

    # source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment.rb#46
    def datadog_configuration; end

    # Inject span_op and trace_op instead of TraceDigest to improve memory usage
    # for `disabled` and `service` mode
    #
    # source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment.rb#20
    def prepend_comment(sql, span_op, trace_op, mode); end
  end
end

# To be prepended to a sql statement.
#
# source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment/comment.rb#11
class Datadog::Tracing::Contrib::Propagation::SqlComment::Comment
  # @return [Comment] a new instance of Comment
  #
  # source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment/comment.rb#12
  def initialize(hash); end

  # source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment/comment.rb#16
  def to_s; end
end

# source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment/ext.rb#8
module Datadog::Tracing::Contrib::Propagation::SqlComment::Ext; end

# The default mode for sql comment propagation
#
# source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment/ext.rb#12
Datadog::Tracing::Contrib::Propagation::SqlComment::Ext::DISABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment/ext.rb#9
Datadog::Tracing::Contrib::Propagation::SqlComment::Ext::ENV_DBM_PROPAGATION_MODE = T.let(T.unsafe(nil), String)

# The `full` mode propagates service configuration + trace context
#
# source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment/ext.rb#18
Datadog::Tracing::Contrib::Propagation::SqlComment::Ext::FULL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment/ext.rb#23
Datadog::Tracing::Contrib::Propagation::SqlComment::Ext::KEY_DATABASE_SERVICE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment/ext.rb#24
Datadog::Tracing::Contrib::Propagation::SqlComment::Ext::KEY_ENVIRONMENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment/ext.rb#25
Datadog::Tracing::Contrib::Propagation::SqlComment::Ext::KEY_PARENT_SERVICE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment/ext.rb#27
Datadog::Tracing::Contrib::Propagation::SqlComment::Ext::KEY_TRACEPARENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment/ext.rb#26
Datadog::Tracing::Contrib::Propagation::SqlComment::Ext::KEY_VERSION = T.let(T.unsafe(nil), String)

# The `service` mode propagates service configuration
#
# source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment/ext.rb#15
Datadog::Tracing::Contrib::Propagation::SqlComment::Ext::SERVICE = T.let(T.unsafe(nil), String)

# The value should be `true` when `full` mode
#
# source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment/ext.rb#21
Datadog::Tracing::Contrib::Propagation::SqlComment::Ext::TAG_DBM_TRACE_INJECTED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment/mode.rb#11
class Datadog::Tracing::Contrib::Propagation::SqlComment::Mode < ::Struct
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment/mode.rb#12
  def enabled?; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment/mode.rb#20
  def full?; end

  # Returns the value of attribute mode
  #
  # @return [Object] the current value of mode
  def mode; end

  # Sets the attribute mode
  #
  # @param value [Object] the value to set the attribute mode to.
  # @return [Object] the newly set value
  def mode=(_); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/propagation/sql_comment/mode.rb#16
  def service?; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/qless/ext.rb#6
module Datadog::Tracing::Contrib::Qless; end

# source://ddtrace//lib/datadog/tracing/contrib/qless/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Qless::Configuration; end

# Custom settings for the Qless integration
#
# source://ddtrace//lib/datadog/tracing/contrib/qless/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Qless::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def tag_job_data; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def tag_job_data=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def tag_job_tags; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def tag_job_tags=(value); end
end

# Qless integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/qless/ext.rb#9
module Datadog::Tracing::Contrib::Qless::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/qless/ext.rb#10
Datadog::Tracing::Contrib::Qless::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/qless/ext.rb#11
Datadog::Tracing::Contrib::Qless::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/qless/ext.rb#12
Datadog::Tracing::Contrib::Qless::Ext::ENV_TAG_JOB_DATA = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/qless/ext.rb#13
Datadog::Tracing::Contrib::Qless::Ext::ENV_TAG_JOB_TAGS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/qless/ext.rb#14
Datadog::Tracing::Contrib::Qless::Ext::SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/qless/ext.rb#15
Datadog::Tracing::Contrib::Qless::Ext::SPAN_JOB = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/qless/ext.rb#20
Datadog::Tracing::Contrib::Qless::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/qless/ext.rb#17
Datadog::Tracing::Contrib::Qless::Ext::TAG_JOB_DATA = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/qless/ext.rb#16
Datadog::Tracing::Contrib::Qless::Ext::TAG_JOB_ID = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/qless/ext.rb#18
Datadog::Tracing::Contrib::Qless::Ext::TAG_JOB_QUEUE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/qless/ext.rb#19
Datadog::Tracing::Contrib::Qless::Ext::TAG_JOB_TAGS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/qless/ext.rb#21
Datadog::Tracing::Contrib::Qless::Ext::TAG_OPERATION_JOB = T.let(T.unsafe(nil), String)

# Description of Qless integration
#
# source://ddtrace//lib/datadog/tracing/contrib/qless/integration.rb#10
class Datadog::Tracing::Contrib::Qless::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/qless/integration.rb#30
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/qless/integration.rb#34
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/qless/integration.rb#26
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/qless/integration.rb#22
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/qless/integration.rb#18
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/qless/integration.rb#13
Datadog::Tracing::Contrib::Qless::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'qless' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/qless/patcher.rb#10
module Datadog::Tracing::Contrib::Qless::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/qless/patcher.rb#29
  def get_option(option); end

  # source://ddtrace//lib/datadog/tracing/contrib/qless/patcher.rb#19
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/qless/patcher.rb#15
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/qless/patcher.rb#29
    def get_option(option); end

    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/qless/patcher.rb#15
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/que/ext.rb#6
module Datadog::Tracing::Contrib::Que; end

# source://ddtrace//lib/datadog/tracing/contrib/que/configuration/settings.rb#11
module Datadog::Tracing::Contrib::Que::Configuration; end

# Default settings for the Que integration
#
# source://ddtrace//lib/datadog/tracing/contrib/que/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Que::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def distributed_tracing; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def distributed_tracing=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def error_handler; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def error_handler=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def tag_args; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def tag_args=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def tag_data; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def tag_data=(value); end
end

# Que integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/que/ext.rb#9
module Datadog::Tracing::Contrib::Que::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/que/ext.rb#10
Datadog::Tracing::Contrib::Que::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/que/ext.rb#11
Datadog::Tracing::Contrib::Que::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/que/ext.rb#12
Datadog::Tracing::Contrib::Que::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/que/ext.rb#13
Datadog::Tracing::Contrib::Que::Ext::ENV_TAG_ARGS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/que/ext.rb#14
Datadog::Tracing::Contrib::Que::Ext::ENV_TAG_DATA_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/que/ext.rb#15
Datadog::Tracing::Contrib::Que::Ext::SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/que/ext.rb#16
Datadog::Tracing::Contrib::Que::Ext::SPAN_JOB = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/que/ext.rb#26
Datadog::Tracing::Contrib::Que::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/que/ext.rb#17
Datadog::Tracing::Contrib::Que::Ext::TAG_JOB_ARGS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/que/ext.rb#18
Datadog::Tracing::Contrib::Que::Ext::TAG_JOB_DATA = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/que/ext.rb#19
Datadog::Tracing::Contrib::Que::Ext::TAG_JOB_ERROR_COUNT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/que/ext.rb#20
Datadog::Tracing::Contrib::Que::Ext::TAG_JOB_EXPIRED_AT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/que/ext.rb#21
Datadog::Tracing::Contrib::Que::Ext::TAG_JOB_FINISHED_AT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/que/ext.rb#22
Datadog::Tracing::Contrib::Que::Ext::TAG_JOB_ID = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/que/ext.rb#23
Datadog::Tracing::Contrib::Que::Ext::TAG_JOB_PRIORITY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/que/ext.rb#24
Datadog::Tracing::Contrib::Que::Ext::TAG_JOB_QUEUE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/que/ext.rb#25
Datadog::Tracing::Contrib::Que::Ext::TAG_JOB_RUN_AT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/que/ext.rb#27
Datadog::Tracing::Contrib::Que::Ext::TAG_OPERATION_JOB = T.let(T.unsafe(nil), String)

# Description of Que integration
#
# source://ddtrace//lib/datadog/tracing/contrib/que/integration.rb#13
class Datadog::Tracing::Contrib::Que::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/que/integration.rb#33
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/que/integration.rb#37
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/que/integration.rb#29
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/que/integration.rb#25
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/que/integration.rb#21
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/que/integration.rb#16
Datadog::Tracing::Contrib::Que::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'que' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/que/patcher.rb#10
module Datadog::Tracing::Contrib::Que::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/que/patcher.rb#19
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/que/patcher.rb#15
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/que/patcher.rb#15
    def target_version; end
  end
end

# Tracer is a Que's server-side middleware which traces executed jobs
#
# source://ddtrace//lib/datadog/tracing/contrib/que/tracer.rb#10
class Datadog::Tracing::Contrib::Que::Tracer
  # source://ddtrace//lib/datadog/tracing/contrib/que/tracer.rb#11
  def call(job); end

  private

  # source://ddtrace//lib/datadog/tracing/contrib/que/tracer.rb#56
  def configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/que/tracer.rb#47
  def set_sample_rate(request_span); end
end

# Registry is a global, declarative repository of all available integrations.
#
# Integrations should register themselves with the registry as early as
# possible as the initial tracer configuration can only activate integrations
# if they have already been registered.
#
# Despite that, integrations *can* be appended to the registry at any point
# of the program execution. Newly appended integrations can then be
# activated during tracer reconfiguration.
#
# The registry does not depend on runtime configuration and registered integrations
# must execute correctly after successive configuration changes.
# The registered integrations themselves can depend on the stateful configuration
# of the tracer.
#
# `Datadog.registry` is a helper accessor to this constant, but it's only available
# after the tracer has complete initialization. Use `Datadog::Tracing::Contrib::REGISTRY` instead
# of `Datadog.registry` when you code might be called during tracer initialization.
#
# source://ddtrace//lib/datadog/tracing/contrib.rb#28
Datadog::Tracing::Contrib::REGISTRY = T.let(T.unsafe(nil), Datadog::Tracing::Contrib::Registry)

# source://ddtrace//lib/datadog/tracing/contrib/racecar/ext.rb#6
module Datadog::Tracing::Contrib::Racecar; end

# source://ddtrace//lib/datadog/tracing/contrib/racecar/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Racecar::Configuration; end

# Custom settings for the Racecar integration
#
# source://ddtrace//lib/datadog/tracing/contrib/racecar/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Racecar::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# Defines basic behaviors for an ActiveRecord event.
#
# source://ddtrace//lib/datadog/tracing/contrib/racecar/event.rb#13
module Datadog::Tracing::Contrib::Racecar::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event

  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  mixes_in_class_methods ::Datadog::Tracing::Contrib::Racecar::Event::ClassMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/racecar/event.rb#14
    def included(base); end
  end
end

# Class methods for Racecar events.
# Note, they share the same process method and before_trace method.
#
# source://ddtrace//lib/datadog/tracing/contrib/racecar/event.rb#21
module Datadog::Tracing::Contrib::Racecar::Event::ClassMethods
  # source://ddtrace//lib/datadog/tracing/contrib/racecar/event.rb#32
  def configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/racecar/event.rb#36
  def process(span, event, _id, payload); end

  # source://ddtrace//lib/datadog/tracing/contrib/racecar/event.rb#28
  def span_options; end

  # source://ddtrace//lib/datadog/tracing/contrib/racecar/event.rb#22
  def subscription(*args); end

  private

  # Context objects are thread-bound.
  # If Racecar re-uses threads, context from a previous trace
  # could leak into the new trace. This "cleans" current context,
  # preventing such a leak.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/racecar/event.rb#66
  def ensure_clean_context!; end
end

# Defines collection of instrumented Racecar events
#
# source://ddtrace//lib/datadog/tracing/contrib/racecar/events/batch.rb#8
module Datadog::Tracing::Contrib::Racecar::Events
  private

  # source://ddtrace//lib/datadog/tracing/contrib/racecar/events.rb#21
  def all; end

  # source://ddtrace//lib/datadog/tracing/contrib/racecar/events.rb#29
  def subscribe!; end

  # source://ddtrace//lib/datadog/tracing/contrib/racecar/events.rb#25
  def subscriptions; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/racecar/events.rb#21
    def all; end

    # source://ddtrace//lib/datadog/tracing/contrib/racecar/events.rb#29
    def subscribe!; end

    # source://ddtrace//lib/datadog/tracing/contrib/racecar/events.rb#25
    def subscriptions; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/racecar/events.rb#13
Datadog::Tracing::Contrib::Racecar::Events::ALL = T.let(T.unsafe(nil), Array)

# Defines instrumentation for process_batch.racecar event
#
# source://ddtrace//lib/datadog/tracing/contrib/racecar/events/batch.rb#10
module Datadog::Tracing::Contrib::Racecar::Events::Batch
  include ::Datadog::Tracing::Contrib::Racecar::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Racecar::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/racecar/events/batch.rb#17
  def event_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/racecar/events/batch.rb#21
  def span_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/racecar/events/batch.rb#25
  def span_options; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/racecar/events/batch.rb#17
    def event_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/racecar/events/batch.rb#21
    def span_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/racecar/events/batch.rb#25
    def span_options; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/racecar/events/batch.rb#13
Datadog::Tracing::Contrib::Racecar::Events::Batch::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for main_loop.racecar event
#
# source://ddtrace//lib/datadog/tracing/contrib/racecar/events/consume.rb#10
module Datadog::Tracing::Contrib::Racecar::Events::Consume
  include ::Datadog::Tracing::Contrib::Racecar::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Racecar::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/racecar/events/consume.rb#17
  def event_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/racecar/events/consume.rb#21
  def span_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/racecar/events/consume.rb#25
  def span_options; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/racecar/events/consume.rb#17
    def event_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/racecar/events/consume.rb#21
    def span_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/racecar/events/consume.rb#25
    def span_options; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/racecar/events/consume.rb#13
Datadog::Tracing::Contrib::Racecar::Events::Consume::EVENT_NAME = T.let(T.unsafe(nil), String)

# Defines instrumentation for process_message.racecar event
#
# source://ddtrace//lib/datadog/tracing/contrib/racecar/events/message.rb#10
module Datadog::Tracing::Contrib::Racecar::Events::Message
  include ::Datadog::Tracing::Contrib::Racecar::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Subscriber::ClassMethods
  extend ::Datadog::Tracing::Contrib::ActiveSupport::Notifications::Event::ClassMethods
  extend ::Datadog::Tracing::Contrib::Racecar::Event::ClassMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/racecar/events/message.rb#17
  def event_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/racecar/events/message.rb#21
  def span_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/racecar/events/message.rb#25
  def span_options; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/racecar/events/message.rb#17
    def event_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/racecar/events/message.rb#21
    def span_name; end

    # source://ddtrace//lib/datadog/tracing/contrib/racecar/events/message.rb#25
    def span_options; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/racecar/events/message.rb#13
Datadog::Tracing::Contrib::Racecar::Events::Message::EVENT_NAME = T.let(T.unsafe(nil), String)

# Racecar integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/racecar/ext.rb#9
module Datadog::Tracing::Contrib::Racecar::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/racecar/ext.rb#13
Datadog::Tracing::Contrib::Racecar::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/racecar/ext.rb#11
Datadog::Tracing::Contrib::Racecar::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/racecar/ext.rb#12
Datadog::Tracing::Contrib::Racecar::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/racecar/ext.rb#10
Datadog::Tracing::Contrib::Racecar::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/racecar/ext.rb#15
Datadog::Tracing::Contrib::Racecar::Ext::SPAN_BATCH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/racecar/ext.rb#14
Datadog::Tracing::Contrib::Racecar::Ext::SPAN_CONSUME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/racecar/ext.rb#16
Datadog::Tracing::Contrib::Racecar::Ext::SPAN_MESSAGE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/racecar/ext.rb#23
Datadog::Tracing::Contrib::Racecar::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/racecar/ext.rb#17
Datadog::Tracing::Contrib::Racecar::Ext::TAG_CONSUMER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/racecar/ext.rb#18
Datadog::Tracing::Contrib::Racecar::Ext::TAG_FIRST_OFFSET = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/racecar/ext.rb#19
Datadog::Tracing::Contrib::Racecar::Ext::TAG_MESSAGE_COUNT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/racecar/ext.rb#27
Datadog::Tracing::Contrib::Racecar::Ext::TAG_MESSAGING_SYSTEM = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/racecar/ext.rb#20
Datadog::Tracing::Contrib::Racecar::Ext::TAG_OFFSET = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/racecar/ext.rb#25
Datadog::Tracing::Contrib::Racecar::Ext::TAG_OPERATION_BATCH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/racecar/ext.rb#24
Datadog::Tracing::Contrib::Racecar::Ext::TAG_OPERATION_CONSUME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/racecar/ext.rb#26
Datadog::Tracing::Contrib::Racecar::Ext::TAG_OPERATION_MESSAGE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/racecar/ext.rb#21
Datadog::Tracing::Contrib::Racecar::Ext::TAG_PARTITION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/racecar/ext.rb#22
Datadog::Tracing::Contrib::Racecar::Ext::TAG_TOPIC = T.let(T.unsafe(nil), String)

# Description of Racecar integration
#
# source://ddtrace//lib/datadog/tracing/contrib/racecar/integration.rb#10
class Datadog::Tracing::Contrib::Racecar::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/racecar/integration.rb#31
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/racecar/integration.rb#35
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/racecar/integration.rb#27
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/racecar/integration.rb#22
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/racecar/integration.rb#18
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/racecar/integration.rb#13
Datadog::Tracing::Contrib::Racecar::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'racecar' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/racecar/patcher.rb#12
module Datadog::Tracing::Contrib::Racecar::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/racecar/patcher.rb#21
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/racecar/patcher.rb#17
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/racecar/patcher.rb#17
    def target_version; end
  end
end

# Rack module includes middlewares that are required to trace any framework
# and application built on top of Rack.
#
# source://ddtrace//lib/datadog/tracing/contrib/rack/ext.rb#6
module Datadog::Tracing::Contrib::Rack; end

# source://ddtrace//lib/datadog/tracing/contrib/rack/configuration/settings.rb#8
module Datadog::Tracing::Contrib::Rack::Configuration; end

# Custom settings for the Rack integration
#
# source://ddtrace//lib/datadog/tracing/contrib/rack/configuration/settings.rb#11
class Datadog::Tracing::Contrib::Rack::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def application; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def application=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def distributed_tracing; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def distributed_tracing=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def headers; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def headers=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def middleware_names; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def middleware_names=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def quantize; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def quantize=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def request_queuing; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def request_queuing=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def web_service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def web_service_name=(value); end
end

# source://ddtrace//lib/datadog/tracing/contrib/rack/configuration/settings.rb#12
Datadog::Tracing::Contrib::Rack::Configuration::Settings::DEFAULT_HEADERS = T.let(T.unsafe(nil), Hash)

# Rack integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/rack/ext.rb#9
module Datadog::Tracing::Contrib::Rack::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/rack/ext.rb#25
Datadog::Tracing::Contrib::Rack::Ext::DEFAULT_PEER_WEBSERVER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rack/ext.rb#11
Datadog::Tracing::Contrib::Rack::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rack/ext.rb#12
Datadog::Tracing::Contrib::Rack::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rack/ext.rb#10
Datadog::Tracing::Contrib::Rack::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rack/ext.rb#13
Datadog::Tracing::Contrib::Rack::Ext::RACK_ENV_REQUEST_SPAN = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rack/ext.rb#15
Datadog::Tracing::Contrib::Rack::Ext::SPAN_HTTP_PROXY_QUEUE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rack/ext.rb#14
Datadog::Tracing::Contrib::Rack::Ext::SPAN_HTTP_PROXY_REQUEST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rack/ext.rb#16
Datadog::Tracing::Contrib::Rack::Ext::SPAN_HTTP_SERVER_QUEUE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rack/ext.rb#17
Datadog::Tracing::Contrib::Rack::Ext::SPAN_REQUEST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rack/ext.rb#18
Datadog::Tracing::Contrib::Rack::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rack/ext.rb#19
Datadog::Tracing::Contrib::Rack::Ext::TAG_COMPONENT_HTTP_PROXY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rack/ext.rb#22
Datadog::Tracing::Contrib::Rack::Ext::TAG_OPERATION_HTTP_PROXY_QUEUE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rack/ext.rb#21
Datadog::Tracing::Contrib::Rack::Ext::TAG_OPERATION_HTTP_PROXY_REQUEST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rack/ext.rb#23
Datadog::Tracing::Contrib::Rack::Ext::TAG_OPERATION_HTTP_SERVER_QUEUE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rack/ext.rb#20
Datadog::Tracing::Contrib::Rack::Ext::TAG_OPERATION_REQUEST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rack/ext.rb#24
Datadog::Tracing::Contrib::Rack::Ext::WEBSERVER_APP = T.let(T.unsafe(nil), String)

# Classes and utilities for handling headers in Rack.
#
# source://ddtrace//lib/datadog/tracing/contrib/rack/header_collection.rb#8
module Datadog::Tracing::Contrib::Rack::Header
  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/rack/header_collection.rb#31
    def to_rack_header(name); end
  end
end

# An implementation of a header collection that looks up headers from a Rack environment.
#
# source://ddtrace//lib/datadog/tracing/contrib/rack/header_collection.rb#10
class Datadog::Tracing::Contrib::Rack::Header::RequestHeaderCollection < ::Datadog::Core::HeaderCollection
  # Creates a header collection from a rack environment.
  #
  # @return [RequestHeaderCollection] a new instance of RequestHeaderCollection
  #
  # source://ddtrace//lib/datadog/tracing/contrib/rack/header_collection.rb#12
  def initialize(env); end

  # Gets the value of the header with the given name.
  # Allows this class to have a similar API to a {Hash}.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/rack/header_collection.rb#18
  def [](header_name); end

  # Gets the value of the header with the given name.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/rack/header_collection.rb#18
  def get(header_name); end

  # Tests whether a header with the given name exists in the environment.
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/rack/header_collection.rb#26
  def key?(header_name); end
end

# Matches Rack-style headers with a matcher and sets matching headers into a span.
#
# source://ddtrace//lib/datadog/tracing/contrib/rack/header_tagging.rb#8
module Datadog::Tracing::Contrib::Rack::HeaderTagging
  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/rack/header_tagging.rb#9
    def tag_request_headers(span, env, configuration); end

    # source://ddtrace//lib/datadog/tracing/contrib/rack/header_tagging.rb#30
    def tag_response_headers(span, headers, configuration); end
  end
end

# Description of Rack integration
#
# source://ddtrace//lib/datadog/tracing/contrib/rack/integration.rb#11
class Datadog::Tracing::Contrib::Rack::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # enabled by rails integration so should only auto instrument
  # if detected that it is being used without rails
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/rack/integration.rb#33
  def auto_instrument?; end

  # source://ddtrace//lib/datadog/tracing/contrib/rack/integration.rb#37
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/rack/integration.rb#41
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/rack/integration.rb#27
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/rack/integration.rb#23
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/rack/integration.rb#19
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/rack/integration.rb#14
Datadog::Tracing::Contrib::Rack::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Provides instrumentation for Rack middleware names
#
# source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#22
module Datadog::Tracing::Contrib::Rack::MiddlewareNamePatcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#62
  def get_option(option); end

  # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#31
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#35
  def patch_middleware_names; end

  # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#45
  def retain_middleware_name(middleware); end

  # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#27
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#62
    def get_option(option); end

    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#35
    def patch_middleware_names; end

    # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#45
    def retain_middleware_name(middleware); end

    # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#27
    def target_version; end
  end
end

# Provides instrumentation for `rack`
#
# source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#6
module Datadog::Tracing::Contrib::Rack::MiddlewarePatcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#15
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#11
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#11
    def target_version; end
  end
end

# Applies multiple patches
#
# source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#68
module Datadog::Tracing::Contrib::Rack::Patcher
  private

  # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#102
  def get_option(option); end

  # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#84
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#110
  def patch_error_result; end

  # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#106
  def patch_successful; end

  # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#76
  def patched?; end

  # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#80
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#102
    def get_option(option); end

    # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#84
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#110
    def patch_error_result; end

    # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#106
    def patch_successful; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#76
    def patched?; end

    # source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#80
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/rack/patcher.rb#69
Datadog::Tracing::Contrib::Rack::Patcher::PATCHERS = T.let(T.unsafe(nil), Array)

# Retrieves the time spent in an upstream proxy
# for the current Rack request.
#
# This time captures the request delay introduced but
# such proxy before the request made it to the Ruby
# process.
#
# source://ddtrace//lib/datadog/tracing/contrib/rack/request_queue.rb#11
module Datadog::Tracing::Contrib::Rack::QueueTime
  private

  # source://ddtrace//lib/datadog/tracing/contrib/rack/request_queue.rb#18
  def get_request_start(env, now = T.unsafe(nil)); end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/rack/request_queue.rb#18
    def get_request_start(env, now = T.unsafe(nil)); end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/rack/request_queue.rb#14
Datadog::Tracing::Contrib::Rack::QueueTime::MINIMUM_ACCEPTABLE_TIME_VALUE = T.let(T.unsafe(nil), Integer)

# source://ddtrace//lib/datadog/tracing/contrib/rack/request_queue.rb#13
Datadog::Tracing::Contrib::Rack::QueueTime::QUEUE_START = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rack/request_queue.rb#12
Datadog::Tracing::Contrib::Rack::QueueTime::REQUEST_START = T.let(T.unsafe(nil), String)

# TraceMiddleware ensures that the Rack Request is properly traced
# from the beginning to the end. The middleware adds the request span
# in the Rack environment so that it can be retrieved by the underlying
# application. If request tags are not set by the app, they will be set using
# information available at the Rack level.
#
# source://ddtrace//lib/datadog/tracing/contrib/rack/middlewares.rb#26
class Datadog::Tracing::Contrib::Rack::TraceMiddleware
  # @return [TraceMiddleware] a new instance of TraceMiddleware
  #
  # source://ddtrace//lib/datadog/tracing/contrib/rack/middlewares.rb#27
  def initialize(app); end

  # source://ddtrace//lib/datadog/tracing/contrib/rack/middlewares.rb#68
  def call(env); end

  # source://ddtrace//lib/datadog/tracing/contrib/rack/middlewares.rb#31
  def compute_queue_time(env); end

  # source://ddtrace//lib/datadog/tracing/contrib/rack/middlewares.rb#142
  def set_request_tags!(trace, request_span, env, status, headers, response, original_env); end

  private

  # source://ddtrace//lib/datadog/tracing/contrib/rack/middlewares.rb#246
  def configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/rack/middlewares.rb#259
  def parse_url(env, original_env); end

  # source://ddtrace//lib/datadog/tracing/contrib/rack/middlewares.rb#301
  def parse_user_agent_header(headers); end

  # source://ddtrace//lib/datadog/tracing/contrib/rack/middlewares.rb#250
  def trace_http_server(span_name, start_time:); end
end

# Rails module includes middlewares that are required for Rails to be properly instrumented.
#
# source://ddtrace//lib/datadog/tracing/contrib/rails/utils.rb#8
module Datadog::Tracing::Contrib::Rails; end

# source://ddtrace//lib/datadog/tracing/contrib/rails/configuration/settings.rb#9
module Datadog::Tracing::Contrib::Rails::Configuration; end

# Custom settings for the Rails integration
#
# source://ddtrace//lib/datadog/tracing/contrib/rails/configuration/settings.rb#12
class Datadog::Tracing::Contrib::Rails::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # @return [Settings] a new instance of Settings
  #
  # source://ddtrace//lib/datadog/tracing/contrib/rails/configuration/settings.rb#13
  def initialize(options = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def distributed_tracing; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def distributed_tracing=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def exception_controller; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def exception_controller=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def middleware; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def middleware=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def middleware_names; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def middleware_names=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def request_queuing; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def request_queuing=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def template_base_path; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def template_base_path=(value); end
end

# This is only here to catch errors, the Rack module does something very similar, however,
# since it's not in the same place in the stack, when the Rack middleware is called,
# error is already swallowed and handled by Rails so we miss the call stack, for instance.
#
# source://ddtrace//lib/datadog/tracing/contrib/rails/middlewares.rb#13
class Datadog::Tracing::Contrib::Rails::ExceptionMiddleware
  # @return [ExceptionMiddleware] a new instance of ExceptionMiddleware
  #
  # source://ddtrace//lib/datadog/tracing/contrib/rails/middlewares.rb#14
  def initialize(app); end

  # source://ddtrace//lib/datadog/tracing/contrib/rails/middlewares.rb#18
  def call(env); end
end

# Rails integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/rails/ext.rb#9
module Datadog::Tracing::Contrib::Rails::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/rails/ext.rb#10
Datadog::Tracing::Contrib::Rails::Ext::APP = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rails/ext.rb#12
Datadog::Tracing::Contrib::Rails::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rails/ext.rb#13
Datadog::Tracing::Contrib::Rails::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rails/ext.rb#14
Datadog::Tracing::Contrib::Rails::Ext::ENV_DISABLE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rails/ext.rb#11
Datadog::Tracing::Contrib::Rails::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# Rails framework code, used to essentially:
# - handle configuration entries which are specific to Datadog tracing
# - instrument parts of the framework when needed
#
# source://ddtrace//lib/datadog/tracing/contrib/rails/framework.rb#23
module Datadog::Tracing::Contrib::Rails::Framework
  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/rails/framework.rb#77
    def activate_action_cable!(datadog_config, rails_config); end

    # source://ddtrace//lib/datadog/tracing/contrib/rails/framework.rb#83
    def activate_action_mailer!(datadog_config, rails_config); end

    # source://ddtrace//lib/datadog/tracing/contrib/rails/framework.rb#92
    def activate_action_pack!(datadog_config, rails_config); end

    # source://ddtrace//lib/datadog/tracing/contrib/rails/framework.rb#101
    def activate_action_view!(datadog_config, rails_config); end

    # source://ddtrace//lib/datadog/tracing/contrib/rails/framework.rb#110
    def activate_active_job!(datadog_config, rails_config); end

    # source://ddtrace//lib/datadog/tracing/contrib/rails/framework.rb#119
    def activate_active_record!(datadog_config, rails_config); end

    # source://ddtrace//lib/datadog/tracing/contrib/rails/framework.rb#71
    def activate_active_support!(datadog_config, rails_config); end

    # source://ddtrace//lib/datadog/tracing/contrib/rails/framework.rb#125
    def activate_lograge!(datadog_config, rails_config); end

    # source://ddtrace//lib/datadog/tracing/contrib/rails/framework.rb#60
    def activate_rack!(datadog_config, rails_config); end

    # source://ddtrace//lib/datadog/tracing/contrib/rails/framework.rb#135
    def activate_semantic_logger!(datadog_config, rails_config); end

    # After the Rails application finishes initializing, we configure the Rails
    # integration and all its sub-components with the application information
    # available.
    # We do this after the initialization because not all the information we
    # require is available before then.
    #
    # source://ddtrace//lib/datadog/tracing/contrib/rails/framework.rb#29
    def setup; end
  end
end

# Description of Rails integration
#
# source://ddtrace//lib/datadog/tracing/contrib/rails/integration.rb#12
class Datadog::Tracing::Contrib::Rails::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/rails/integration.rb#36
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/rails/integration.rb#40
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/rails/integration.rb#28
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/rails/integration.rb#24
    def loaded?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/rails/integration.rb#32
    def patchable?; end

    # source://ddtrace//lib/datadog/tracing/contrib/rails/integration.rb#20
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/rails/integration.rb#15
Datadog::Tracing::Contrib::Rails::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Rails log injection helper methods
#
# source://ddtrace//lib/datadog/tracing/contrib/rails/log_injection.rb#7
module Datadog::Tracing::Contrib::Rails::LogInjection
  private

  # Use `app.config.log_tags` to inject propagation tags into the default Rails logger.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/rails/log_injection.rb#11
  def configure_log_tags(app_config); end

  class << self
    # Use `app.config.log_tags` to inject propagation tags into the default Rails logger.
    #
    # source://ddtrace//lib/datadog/tracing/contrib/rails/log_injection.rb#11
    def configure_log_tags(app_config); end
  end
end

# Patcher enables patching of 'rails' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/rails/patcher.rb#14
module Datadog::Tracing::Contrib::Rails::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/rails/patcher.rb#48
  def add_middleware(app); end

  # source://ddtrace//lib/datadog/tracing/contrib/rails/patcher.rb#71
  def after_initialize(app); end

  # source://ddtrace//lib/datadog/tracing/contrib/rails/patcher.rb#37
  def before_initialize(app); end

  # source://ddtrace//lib/datadog/tracing/contrib/rails/patcher.rb#26
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/rails/patcher.rb#65
  def patch_after_initialize; end

  # source://ddtrace//lib/datadog/tracing/contrib/rails/patcher.rb#31
  def patch_before_initialize; end

  # Configure Rails tracing with settings
  #
  # source://ddtrace//lib/datadog/tracing/contrib/rails/patcher.rb#80
  def setup_tracer; end

  # source://ddtrace//lib/datadog/tracing/contrib/rails/patcher.rb#22
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/rails/patcher.rb#48
    def add_middleware(app); end

    # source://ddtrace//lib/datadog/tracing/contrib/rails/patcher.rb#71
    def after_initialize(app); end

    # source://ddtrace//lib/datadog/tracing/contrib/rails/patcher.rb#37
    def before_initialize(app); end

    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/rails/patcher.rb#65
    def patch_after_initialize; end

    # source://ddtrace//lib/datadog/tracing/contrib/rails/patcher.rb#31
    def patch_before_initialize; end

    # Configure Rails tracing with settings
    #
    # source://ddtrace//lib/datadog/tracing/contrib/rails/patcher.rb#80
    def setup_tracer; end

    # source://ddtrace//lib/datadog/tracing/contrib/rails/patcher.rb#22
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/rails/patcher.rb#18
Datadog::Tracing::Contrib::Rails::Patcher::AFTER_INITIALIZE_ONLY_ONCE_PER_APP = T.let(T.unsafe(nil), Hash)

# source://ddtrace//lib/datadog/tracing/contrib/rails/patcher.rb#17
Datadog::Tracing::Contrib::Rails::Patcher::BEFORE_INITIALIZE_ONLY_ONCE_PER_APP = T.let(T.unsafe(nil), Hash)

# common utilities for Rails
#
# source://ddtrace//lib/datadog/tracing/contrib/rails/utils.rb#10
module Datadog::Tracing::Contrib::Rails::Utils
  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/rails/utils.rb#11
    def app_name; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/rails/utils.rb#21
    def railtie_supported?; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/rake/ext.rb#6
module Datadog::Tracing::Contrib::Rake; end

# source://ddtrace//lib/datadog/tracing/contrib/rake/configuration/settings.rb#12
module Datadog::Tracing::Contrib::Rake::Configuration; end

# Custom settings for the Rake integration
#
# source://ddtrace//lib/datadog/tracing/contrib/rake/configuration/settings.rb#15
class Datadog::Tracing::Contrib::Rake::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def quantize; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def quantize=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def tasks; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def tasks=(value); end
end

# Rake integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/rake/ext.rb#9
module Datadog::Tracing::Contrib::Rake::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/rake/ext.rb#11
Datadog::Tracing::Contrib::Rake::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rake/ext.rb#12
Datadog::Tracing::Contrib::Rake::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rake/ext.rb#10
Datadog::Tracing::Contrib::Rake::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rake/ext.rb#13
Datadog::Tracing::Contrib::Rake::Ext::SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rake/ext.rb#15
Datadog::Tracing::Contrib::Rake::Ext::SPAN_EXECUTE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rake/ext.rb#14
Datadog::Tracing::Contrib::Rake::Ext::SPAN_INVOKE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rake/ext.rb#19
Datadog::Tracing::Contrib::Rake::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rake/ext.rb#16
Datadog::Tracing::Contrib::Rake::Ext::TAG_EXECUTE_ARGS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rake/ext.rb#17
Datadog::Tracing::Contrib::Rake::Ext::TAG_INVOKE_ARGS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rake/ext.rb#20
Datadog::Tracing::Contrib::Rake::Ext::TAG_OPERATION_EXECUTE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rake/ext.rb#21
Datadog::Tracing::Contrib::Rake::Ext::TAG_OPERATION_INVOKE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rake/ext.rb#18
Datadog::Tracing::Contrib::Rake::Ext::TAG_TASK_ARG_NAMES = T.let(T.unsafe(nil), String)

# Instrumentation for Rake tasks
#
# source://ddtrace//lib/datadog/tracing/contrib/rake/instrumentation.rb#11
module Datadog::Tracing::Contrib::Rake::Instrumentation
  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/rake/instrumentation.rb#12
    def included(base); end
  end
end

# Instance methods for Rake instrumentation
#
# source://ddtrace//lib/datadog/tracing/contrib/rake/instrumentation.rb#17
module Datadog::Tracing::Contrib::Rake::Instrumentation::InstanceMethods
  # source://ddtrace//lib/datadog/tracing/contrib/rake/instrumentation.rb#29
  def execute(args = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/contrib/rake/instrumentation.rb#18
  def invoke(*args); end

  private

  # source://ddtrace//lib/datadog/tracing/contrib/rake/instrumentation.rb#70
  def annotate_execute!(span, args); end

  # source://ddtrace//lib/datadog/tracing/contrib/rake/instrumentation.rb#52
  def annotate_invoke!(span, args); end

  # source://ddtrace//lib/datadog/tracing/contrib/rake/instrumentation.rb#93
  def configuration; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/rake/instrumentation.rb#84
  def enabled?; end

  # Task names are verified dynamically, in order to be agnostic of
  # when tracing is configured in relation to Rake task declaration.
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/rake/instrumentation.rb#44
  def instrumented_task?; end

  # source://ddtrace//lib/datadog/tracing/contrib/rake/instrumentation.rb#79
  def quantize_args(args); end

  # source://ddtrace//lib/datadog/tracing/contrib/rake/instrumentation.rb#48
  def shutdown_tracer!; end

  # source://ddtrace//lib/datadog/tracing/contrib/rake/instrumentation.rb#89
  def span_options; end
end

# Description of Rake integration
#
# source://ddtrace//lib/datadog/tracing/contrib/rake/integration.rb#10
class Datadog::Tracing::Contrib::Rake::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/rake/integration.rb#30
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/rake/integration.rb#34
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/rake/integration.rb#26
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/rake/integration.rb#22
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/rake/integration.rb#18
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/rake/integration.rb#13
Datadog::Tracing::Contrib::Rake::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'rake' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/rake/patcher.rb#12
module Datadog::Tracing::Contrib::Rake::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/rake/patcher.rb#26
  def get_option(option); end

  # source://ddtrace//lib/datadog/tracing/contrib/rake/patcher.rb#21
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/rake/patcher.rb#17
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/rake/patcher.rb#26
    def get_option(option); end

    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/rake/patcher.rb#17
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/redis/ext.rb#6
module Datadog::Tracing::Contrib::Redis; end

# source://ddtrace//lib/datadog/tracing/contrib/redis/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Redis::Configuration; end

# Converts String URLs and Hashes to a normalized connection settings Hash.
#
# source://ddtrace//lib/datadog/tracing/contrib/redis/configuration/resolver.rb#11
class Datadog::Tracing::Contrib::Redis::Configuration::Resolver < ::Datadog::Tracing::Contrib::Configuration::Resolver
  # @param Redis [Hash, String] connection information
  #
  # source://ddtrace//lib/datadog/tracing/contrib/redis/configuration/resolver.rb#13
  def resolve(hash); end

  protected

  # source://ddtrace//lib/datadog/tracing/contrib/redis/configuration/resolver.rb#39
  def connection_resolver; end

  # source://ddtrace//lib/datadog/tracing/contrib/redis/configuration/resolver.rb#25
  def normalize(hash); end

  # source://ddtrace//lib/datadog/tracing/contrib/redis/configuration/resolver.rb#19
  def parse_matcher(matcher); end
end

# Custom settings for the Redis integration
#
# source://ddtrace//lib/datadog/tracing/contrib/redis/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Redis::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def command_args; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def command_args=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def peer_service; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def peer_service=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# source://ddtrace//lib/datadog/tracing/contrib/redis/configuration/resolver.rb#8
Datadog::Tracing::Contrib::Redis::Configuration::UNIX_SCHEME = T.let(T.unsafe(nil), String)

# Redis integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/redis/ext.rb#9
module Datadog::Tracing::Contrib::Redis::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/redis/ext.rb#17
Datadog::Tracing::Contrib::Redis::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/redis/ext.rb#13
Datadog::Tracing::Contrib::Redis::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/redis/ext.rb#14
Datadog::Tracing::Contrib::Redis::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/redis/ext.rb#15
Datadog::Tracing::Contrib::Redis::Ext::ENV_COMMAND_ARGS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/redis/ext.rb#10
Datadog::Tracing::Contrib::Redis::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/redis/ext.rb#12
Datadog::Tracing::Contrib::Redis::Ext::ENV_PEER_SERVICE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/redis/ext.rb#11
Datadog::Tracing::Contrib::Redis::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/redis/ext.rb#16
Datadog::Tracing::Contrib::Redis::Ext::METRIC_PIPELINE_LEN = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/redis/ext.rb#26
Datadog::Tracing::Contrib::Redis::Ext::PEER_SERVICE_SOURCES = T.let(T.unsafe(nil), Array)

# source://ddtrace//lib/datadog/tracing/contrib/redis/ext.rb#18
Datadog::Tracing::Contrib::Redis::Ext::SPAN_COMMAND = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/redis/ext.rb#22
Datadog::Tracing::Contrib::Redis::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/redis/ext.rb#25
Datadog::Tracing::Contrib::Redis::Ext::TAG_DATABASE_INDEX = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/redis/ext.rb#19
Datadog::Tracing::Contrib::Redis::Ext::TAG_DB = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/redis/ext.rb#23
Datadog::Tracing::Contrib::Redis::Ext::TAG_OPERATION_COMMAND = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/redis/ext.rb#20
Datadog::Tracing::Contrib::Redis::Ext::TAG_RAW_COMMAND = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/redis/ext.rb#24
Datadog::Tracing::Contrib::Redis::Ext::TAG_SYSTEM = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/redis/ext.rb#21
Datadog::Tracing::Contrib::Redis::Ext::TYPE = T.let(T.unsafe(nil), String)

# Description of Redis integration
#
# source://ddtrace//lib/datadog/tracing/contrib/redis/integration.rb#10
class Datadog::Tracing::Contrib::Redis::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/redis/integration.rb#63
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/redis/integration.rb#67
  def patcher; end

  # source://ddtrace//lib/datadog/tracing/contrib/redis/integration.rb#71
  def resolver; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/redis/integration.rb#51
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/redis/integration.rb#39
    def loaded?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/redis/integration.rb#59
    def redis_client_compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/redis/integration.rb#47
    def redis_client_loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/redis/integration.rb#35
    def redis_client_version; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/redis/integration.rb#55
    def redis_compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/redis/integration.rb#43
    def redis_loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/redis/integration.rb#31
    def redis_version; end

    # Until Redis 4, all instrumentation happened in one gem: redis.
    # Since Redis 5, instrumentation happens in a separate gem: redis-client.
    # Because Redis 4 does not depend on redis-client, it's possible for both gems to be installed at the same time.
    # For example, if Sidekiq 7 and Redis 4 are installed: both redis and redis-client will be installed.
    # If redis-client and redis > 5 are installed, than they will be in sync, and only redis-client will be installed.
    #
    # source://ddtrace//lib/datadog/tracing/contrib/redis/integration.rb#27
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/redis/integration.rb#13
Datadog::Tracing::Contrib::Redis::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Support `Config#custom`
# https://github.com/redis-rb/redis-client/blob/master/CHANGELOG.md#0110
#
# source://ddtrace//lib/datadog/tracing/contrib/redis/integration.rb#17
Datadog::Tracing::Contrib::Redis::Integration::REDISCLIENT_MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'redis' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/redis/patcher.rb#10
module Datadog::Tracing::Contrib::Redis::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/redis/patcher.rb#50
  def default_tags; end

  # source://ddtrace//lib/datadog/tracing/contrib/redis/patcher.rb#57
  def patch; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#66
    def default_tags; end

    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end
  end
end

# Patch for redis client
#
# source://ddtrace//lib/datadog/tracing/contrib/redis/patcher.rb#29
module Datadog::Tracing::Contrib::Redis::Patcher::ClientPatch
  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/redis/patcher.rb#30
    def included(base); end
  end
end

# Instance method patch for redis client
#
# source://ddtrace//lib/datadog/tracing/contrib/redis/patcher.rb#35
module Datadog::Tracing::Contrib::Redis::Patcher::ClientPatch::InstanceMethods
  # source://ddtrace//lib/datadog/tracing/contrib/redis/patcher.rb#36
  def initialize(options = T.unsafe(nil)); end

  private

  # Returns the value of attribute redis_instance.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/redis/patcher.rb#44
  def redis_instance; end
end

# Patch for redis instance
#
# source://ddtrace//lib/datadog/tracing/contrib/redis/patcher.rb#14
module Datadog::Tracing::Contrib::Redis::Patcher::InstancePatch
  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/redis/patcher.rb#15
    def included(base); end
  end
end

# Instance method patch for redis instance
#
# source://ddtrace//lib/datadog/tracing/contrib/redis/patcher.rb#20
module Datadog::Tracing::Contrib::Redis::Patcher::InstancePatch::InstanceMethods
  # `options` could be frozen
  #
  # source://ddtrace//lib/datadog/tracing/contrib/redis/patcher.rb#22
  def initialize(options = T.unsafe(nil)); end
end

# source://ddtrace//lib/datadog/tracing/contrib/redis/vendor/resolver.rb#12
module Datadog::Tracing::Contrib::Redis::Vendor; end

# source://ddtrace//lib/datadog/tracing/contrib/redis/vendor/resolver.rb#13
class Datadog::Tracing::Contrib::Redis::Vendor::Resolver
  #
  # This method is a subset of the implementation provided in v3.0.0
  # https://github.com/redis/redis-rb/blob/v3.0.0/lib/redis/client.rb
  # https://github.com/redis/redis-rb/blob/v4.1.3/lib/redis/client.rb
  #
  # Since it has been backported from the original gem, some linting
  # cops have been disabled
  #
  # source://ddtrace//lib/datadog/tracing/contrib/redis/vendor/resolver.rb#52
  def _parse_options(options); end

  # source://ddtrace//lib/datadog/tracing/contrib/redis/vendor/resolver.rb#38
  def resolve(options); end
end

# Connection DEFAULTS for a Redis::Client are unchanged for
# the integration supported options.
# https://github.com/redis/redis-rb/blob/v3.0.0/lib/redis/client.rb#L6-L14
# https://github.com/redis/redis-rb/blob/v4.1.3/lib/redis/client.rb#L10-L26
# Since the integration takes in consideration only few attributes, all
# versions are compatible for :url, :scheme, :host, :port, :db
#
# source://ddtrace//lib/datadog/tracing/contrib/redis/vendor/resolver.rb#20
Datadog::Tracing::Contrib::Redis::Vendor::Resolver::DEFAULTS = T.let(T.unsafe(nil), Hash)

# Defines registerable behavior for integrations
#
# source://ddtrace//lib/datadog/tracing/contrib/registerable.rb#7
module Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods

  mixes_in_class_methods ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/registerable.rb#8
    def included(base); end
  end
end

# Class methods for registerable behavior
#
# source://ddtrace//lib/datadog/tracing/contrib/registerable.rb#15
module Datadog::Tracing::Contrib::Registerable::ClassMethods
  # Registers this integration in the global tracer registry.
  # Once registered, this integration can be activated with:
  #
  # ```
  # Datadog.configure do |c|
  #   c.tracing.instrument :name
  # end
  # ```
  #
  # @param name [Symbol] integration name. Used during activation.
  # @param registry [Datadog::Tracing::Contrib::Registry] a custom registry.
  #   Defaults to the global tracing registry.
  # @param auto_patch [Boolean] will this integration be activated during
  #   {file:docs/AutoInstrumentation.md Auto Instrumentation}?
  # @param options [Hash] additional keyword options passed to the initializer of
  #   a custom {Registerable} instrumentation
  # @see Datadog::Tracing::Contrib::Integration
  #
  # source://ddtrace//lib/datadog/tracing/contrib/registerable.rb#33
  def register_as(name, registry: T.unsafe(nil), auto_patch: T.unsafe(nil), **options); end
end

# Instance methods for registerable behavior
#
# source://ddtrace//lib/datadog/tracing/contrib/registerable.rb#39
module Datadog::Tracing::Contrib::Registerable::InstanceMethods
  # source://ddtrace//lib/datadog/tracing/contrib/registerable.rb#43
  def initialize(name, **options); end

  # Returns the value of attribute name.
  #
  # source://ddtrace//lib/datadog/tracing/contrib/registerable.rb#40
  def name; end
end

# Registry is a collection of tracing integrations.
#
# source://ddtrace//lib/datadog/tracing/contrib/registry.rb#8
class Datadog::Tracing::Contrib::Registry
  include ::Enumerable

  # @return [Registry] a new instance of Registry
  #
  # source://ddtrace//lib/datadog/tracing/contrib/registry.rb#14
  def initialize; end

  # source://ddtrace//lib/datadog/tracing/contrib/registry.rb#35
  def [](name); end

  # @param name [Symbol] instrumentation name, to be used when activating this integration
  # @param klass [Object] instrumentation implementation
  # @param auto_patch [Boolean] is the tracer allowed to automatically patch
  #   the host application with this instrumentation?
  #
  # source://ddtrace//lib/datadog/tracing/contrib/registry.rb#23
  def add(name, klass, auto_patch = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/contrib/registry.rb#29
  def each(&block); end

  # source://ddtrace//lib/datadog/tracing/contrib/registry.rb#42
  def to_h; end
end

# source://ddtrace//lib/datadog/tracing/contrib/registry.rb#11
class Datadog::Tracing::Contrib::Registry::Entry < ::Struct
  # Returns the value of attribute auto_patch
  #
  # @return [Object] the current value of auto_patch
  def auto_patch; end

  # Sets the attribute auto_patch
  #
  # @param value [Object] the value to set the attribute auto_patch to.
  # @return [Object] the newly set value
  def auto_patch=(_); end

  # Returns the value of attribute klass
  #
  # @return [Object] the current value of klass
  def klass; end

  # Sets the attribute klass
  #
  # @param value [Object] the value to set the attribute klass to.
  # @return [Object] the newly set value
  def klass=(_); end

  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  def name=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/resque/ext.rb#6
module Datadog::Tracing::Contrib::Resque; end

# source://ddtrace//lib/datadog/tracing/contrib/resque/configuration/settings.rb#11
module Datadog::Tracing::Contrib::Resque::Configuration; end

# Custom settings for the Resque integration
#
# source://ddtrace//lib/datadog/tracing/contrib/resque/configuration/settings.rb#14
class Datadog::Tracing::Contrib::Resque::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def error_handler; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def error_handler=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# Resque integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/resque/ext.rb#9
module Datadog::Tracing::Contrib::Resque::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/resque/ext.rb#11
Datadog::Tracing::Contrib::Resque::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/resque/ext.rb#12
Datadog::Tracing::Contrib::Resque::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/resque/ext.rb#10
Datadog::Tracing::Contrib::Resque::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/resque/ext.rb#13
Datadog::Tracing::Contrib::Resque::Ext::SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/resque/ext.rb#14
Datadog::Tracing::Contrib::Resque::Ext::SPAN_JOB = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/resque/ext.rb#15
Datadog::Tracing::Contrib::Resque::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/resque/ext.rb#16
Datadog::Tracing::Contrib::Resque::Ext::TAG_OPERATION_JOB = T.let(T.unsafe(nil), String)

# Description of Resque integration
#
# source://ddtrace//lib/datadog/tracing/contrib/resque/integration.rb#10
class Datadog::Tracing::Contrib::Resque::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/resque/integration.rb#30
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/resque/integration.rb#34
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/resque/integration.rb#26
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/resque/integration.rb#22
    def loaded?; end

    # Globally-acccesible reference for pre-forking optimization
    #
    # source://ddtrace//lib/datadog/tracing/contrib/resque/integration.rb#40
    def sync_writer; end

    # Globally-acccesible reference for pre-forking optimization
    #
    # source://ddtrace//lib/datadog/tracing/contrib/resque/integration.rb#40
    def sync_writer=(_arg0); end

    # source://ddtrace//lib/datadog/tracing/contrib/resque/integration.rb#18
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/resque/integration.rb#13
Datadog::Tracing::Contrib::Resque::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'resque' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/resque/patcher.rb#11
module Datadog::Tracing::Contrib::Resque::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/resque/patcher.rb#20
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/resque/patcher.rb#16
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/resque/patcher.rb#16
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/rest_client/ext.rb#6
module Datadog::Tracing::Contrib::RestClient; end

# source://ddtrace//lib/datadog/tracing/contrib/rest_client/configuration/settings.rb#10
module Datadog::Tracing::Contrib::RestClient::Configuration; end

# Custom settings for the RestClient integration
#
# source://ddtrace//lib/datadog/tracing/contrib/rest_client/configuration/settings.rb#13
class Datadog::Tracing::Contrib::RestClient::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def distributed_tracing; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def distributed_tracing=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def peer_service; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def peer_service=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def split_by_domain; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def split_by_domain=(value); end
end

# RestClient integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/rest_client/ext.rb#9
module Datadog::Tracing::Contrib::RestClient::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/rest_client/ext.rb#15
Datadog::Tracing::Contrib::RestClient::Ext::DEFAULT_PEER_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rest_client/ext.rb#13
Datadog::Tracing::Contrib::RestClient::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rest_client/ext.rb#14
Datadog::Tracing::Contrib::RestClient::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rest_client/ext.rb#10
Datadog::Tracing::Contrib::RestClient::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rest_client/ext.rb#12
Datadog::Tracing::Contrib::RestClient::Ext::ENV_PEER_SERVICE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rest_client/ext.rb#11
Datadog::Tracing::Contrib::RestClient::Ext::ENV_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rest_client/ext.rb#19
Datadog::Tracing::Contrib::RestClient::Ext::PEER_SERVICE_SOURCES = T.let(T.unsafe(nil), Array)

# source://ddtrace//lib/datadog/tracing/contrib/rest_client/ext.rb#16
Datadog::Tracing::Contrib::RestClient::Ext::SPAN_REQUEST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rest_client/ext.rb#17
Datadog::Tracing::Contrib::RestClient::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/rest_client/ext.rb#18
Datadog::Tracing::Contrib::RestClient::Ext::TAG_OPERATION_REQUEST = T.let(T.unsafe(nil), String)

# Description of RestClient integration
#
# source://ddtrace//lib/datadog/tracing/contrib/rest_client/integration.rb#10
class Datadog::Tracing::Contrib::RestClient::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/rest_client/integration.rb#30
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/rest_client/integration.rb#34
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/rest_client/integration.rb#26
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/rest_client/integration.rb#22
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/rest_client/integration.rb#18
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/rest_client/integration.rb#13
Datadog::Tracing::Contrib::RestClient::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'rest_client' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/rest_client/patcher.rb#10
module Datadog::Tracing::Contrib::RestClient::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/rest_client/patcher.rb#19
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/rest_client/patcher.rb#15
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/rest_client/patcher.rb#15
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/roda/ext.rb#6
module Datadog::Tracing::Contrib::Roda; end

# source://ddtrace//lib/datadog/tracing/contrib/roda/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Roda::Configuration; end

# Custom settings for the Roda integration
#
# source://ddtrace//lib/datadog/tracing/contrib/roda/configuration/settings.rb#12
class Datadog::Tracing::Contrib::Roda::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# Roda integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/roda/ext.rb#8
module Datadog::Tracing::Contrib::Roda::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/roda/ext.rb#9
Datadog::Tracing::Contrib::Roda::Ext::APP = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/roda/ext.rb#11
Datadog::Tracing::Contrib::Roda::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/roda/ext.rb#12
Datadog::Tracing::Contrib::Roda::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/roda/ext.rb#10
Datadog::Tracing::Contrib::Roda::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/roda/ext.rb#13
Datadog::Tracing::Contrib::Roda::Ext::SPAN_REQUEST = T.let(T.unsafe(nil), String)

# Instrumentation for Roda
#
# source://ddtrace//lib/datadog/tracing/contrib/roda/instrumentation.rb#12
module Datadog::Tracing::Contrib::Roda::Instrumentation
  # source://ddtrace//lib/datadog/tracing/contrib/roda/instrumentation.rb#13
  def _roda_handle_main_route; end

  # source://ddtrace//lib/datadog/tracing/contrib/roda/instrumentation.rb#17
  def call; end

  private

  # source://ddtrace//lib/datadog/tracing/contrib/roda/instrumentation.rb#69
  def configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/roda/instrumentation.rb#23
  def instrument(span_name, &block); end
end

# Description of Roda integration
#
# source://ddtrace//lib/datadog/tracing/contrib/roda/integration.rb#14
class Datadog::Tracing::Contrib::Roda::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/roda/integration.rb#34
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/roda/integration.rb#38
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/roda/integration.rb#30
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/roda/integration.rb#26
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/roda/integration.rb#22
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/roda/integration.rb#18
Datadog::Tracing::Contrib::Roda::Integration::MAXIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# source://ddtrace//lib/datadog/tracing/contrib/roda/integration.rb#17
Datadog::Tracing::Contrib::Roda::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# source://ddtrace//lib/datadog/tracing/contrib/roda/patcher.rb#14
module Datadog::Tracing::Contrib::Roda::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods
end

# Datadog SemanticLogger integration.
#
# source://ddtrace//lib/datadog/tracing/contrib/semantic_logger/ext.rb#6
module Datadog::Tracing::Contrib::SemanticLogger; end

# source://ddtrace//lib/datadog/tracing/contrib/semantic_logger/configuration/settings.rb#10
module Datadog::Tracing::Contrib::SemanticLogger::Configuration; end

# Custom settings for the SemanticLogger integration
#
# source://ddtrace//lib/datadog/tracing/contrib/semantic_logger/configuration/settings.rb#13
class Datadog::Tracing::Contrib::SemanticLogger::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end
end

# SemanticLogger integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/semantic_logger/ext.rb#9
module Datadog::Tracing::Contrib::SemanticLogger::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/semantic_logger/ext.rb#10
Datadog::Tracing::Contrib::SemanticLogger::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# Instrumentation for SemanticLogger
#
# source://ddtrace//lib/datadog/tracing/contrib/semantic_logger/instrumentation.rb#10
module Datadog::Tracing::Contrib::SemanticLogger::Instrumentation
  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/semantic_logger/instrumentation.rb#11
    def included(base); end
  end
end

# Instance methods for configuration
#
# source://ddtrace//lib/datadog/tracing/contrib/semantic_logger/instrumentation.rb#16
module Datadog::Tracing::Contrib::SemanticLogger::Instrumentation::InstanceMethods
  # source://ddtrace//lib/datadog/tracing/contrib/semantic_logger/instrumentation.rb#17
  def log(log, message = T.unsafe(nil), progname = T.unsafe(nil), &block); end
end

# Description of SemanticLogger integration
#
# source://ddtrace//lib/datadog/tracing/contrib/semantic_logger/integration.rb#10
class Datadog::Tracing::Contrib::SemanticLogger::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # TODO: abstract out the log injection related instrumentation into it's own module so we dont
  # keep having to do these workarounds
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/semantic_logger/integration.rb#35
  def auto_instrument?; end

  # source://ddtrace//lib/datadog/tracing/contrib/semantic_logger/integration.rb#39
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/semantic_logger/integration.rb#43
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/semantic_logger/integration.rb#29
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/semantic_logger/integration.rb#25
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/semantic_logger/integration.rb#21
    def version; end
  end
end

# v4 had a migration to `named_tags` instead of `payload`
# and has been out for almost 5 years at this point
# it's probably reasonable to nudge users to using modern ruby libs
#
# source://ddtrace//lib/datadog/tracing/contrib/semantic_logger/integration.rb#16
Datadog::Tracing::Contrib::SemanticLogger::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'semantic_logger' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/semantic_logger/patcher.rb#12
module Datadog::Tracing::Contrib::SemanticLogger::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # patch applies our patch
  #
  # source://ddtrace//lib/datadog/tracing/contrib/semantic_logger/patcher.rb#22
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/semantic_logger/patcher.rb#17
  def target_version; end

  class << self
    # patch applies our patch
    #
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/semantic_logger/patcher.rb#17
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/sequel/ext.rb#6
module Datadog::Tracing::Contrib::Sequel; end

# source://ddtrace//lib/datadog/tracing/contrib/sequel/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Sequel::Configuration; end

# Custom settings for the Sequel integration
#
# source://ddtrace//lib/datadog/tracing/contrib/sequel/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Sequel::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end
end

# Adds instrumentation to Sequel::Database
#
# source://ddtrace//lib/datadog/tracing/contrib/sequel/database.rb#11
module Datadog::Tracing::Contrib::Sequel::Database
  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sequel/database.rb#12
    def included(base); end
  end
end

# Instance methods for instrumenting Sequel::Database
#
# source://ddtrace//lib/datadog/tracing/contrib/sequel/database.rb#17
module Datadog::Tracing::Contrib::Sequel::Database::InstanceMethods
  # source://ddtrace//lib/datadog/tracing/contrib/sequel/database.rb#18
  def run(sql, options = T.unsafe(nil)); end

  private

  # source://ddtrace//lib/datadog/tracing/contrib/sequel/database.rb#41
  def adapter_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/sequel/database.rb#45
  def parse_opts(sql, opts); end
end

# Adds instrumentation to Sequel::Dataset
#
# source://ddtrace//lib/datadog/tracing/contrib/sequel/dataset.rb#13
module Datadog::Tracing::Contrib::Sequel::Dataset
  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sequel/dataset.rb#14
    def included(base); end
  end
end

# Instance methods for instrumenting Sequel::Dataset
#
# source://ddtrace//lib/datadog/tracing/contrib/sequel/dataset.rb#19
module Datadog::Tracing::Contrib::Sequel::Dataset::InstanceMethods
  # source://ddtrace//lib/datadog/tracing/contrib/sequel/dataset.rb#20
  def execute(sql, options = T.unsafe(nil), &block); end

  # source://ddtrace//lib/datadog/tracing/contrib/sequel/dataset.rb#24
  def execute_ddl(sql, options = T.unsafe(nil), &block); end

  # source://ddtrace//lib/datadog/tracing/contrib/sequel/dataset.rb#28
  def execute_dui(sql, options = T.unsafe(nil), &block); end

  # source://ddtrace//lib/datadog/tracing/contrib/sequel/dataset.rb#32
  def execute_insert(sql, options = T.unsafe(nil), &block); end

  private

  # source://ddtrace//lib/datadog/tracing/contrib/sequel/dataset.rb#59
  def adapter_name; end

  # source://ddtrace//lib/datadog/tracing/contrib/sequel/dataset.rb#38
  def trace_execute(super_method, sql, options, &block); end
end

# Sequel integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/sequel/ext.rb#9
module Datadog::Tracing::Contrib::Sequel::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/sequel/ext.rb#11
Datadog::Tracing::Contrib::Sequel::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sequel/ext.rb#12
Datadog::Tracing::Contrib::Sequel::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sequel/ext.rb#10
Datadog::Tracing::Contrib::Sequel::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sequel/ext.rb#13
Datadog::Tracing::Contrib::Sequel::Ext::SPAN_QUERY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sequel/ext.rb#16
Datadog::Tracing::Contrib::Sequel::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sequel/ext.rb#14
Datadog::Tracing::Contrib::Sequel::Ext::TAG_DB_VENDOR = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sequel/ext.rb#17
Datadog::Tracing::Contrib::Sequel::Ext::TAG_OPERATION_QUERY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sequel/ext.rb#15
Datadog::Tracing::Contrib::Sequel::Ext::TAG_PREPARED_NAME = T.let(T.unsafe(nil), String)

# Description of Sequel integration
#
# source://ddtrace//lib/datadog/tracing/contrib/sequel/integration.rb#10
class Datadog::Tracing::Contrib::Sequel::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/sequel/integration.rb#30
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/sequel/integration.rb#34
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sequel/integration.rb#26
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sequel/integration.rb#22
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/sequel/integration.rb#18
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/sequel/integration.rb#13
Datadog::Tracing::Contrib::Sequel::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'sequel' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/sequel/patcher.rb#12
module Datadog::Tracing::Contrib::Sequel::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/sequel/patcher.rb#21
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/sequel/patcher.rb#26
  def patch_sequel_database; end

  # source://ddtrace//lib/datadog/tracing/contrib/sequel/patcher.rb#30
  def patch_sequel_dataset; end

  # source://ddtrace//lib/datadog/tracing/contrib/sequel/patcher.rb#17
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/sequel/patcher.rb#26
    def patch_sequel_database; end

    # source://ddtrace//lib/datadog/tracing/contrib/sequel/patcher.rb#30
    def patch_sequel_dataset; end

    # source://ddtrace//lib/datadog/tracing/contrib/sequel/patcher.rb#17
    def target_version; end
  end
end

# General purpose functions for Sequel
#
# source://ddtrace//lib/datadog/tracing/contrib/sequel/utils.rb#9
module Datadog::Tracing::Contrib::Sequel::Utils
  class << self
    # Ruby database connector library
    #
    # e.g. adapter:mysql2 (database:mysql), adapter:jdbc (database:postgres)
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sequel/utils.rb#14
    def adapter_name(database); end

    # Database engine
    #
    # e.g. database:mysql (adapter:mysql2), database:postgres (adapter:jdbc)
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sequel/utils.rb#29
    def database_type(database); end

    # source://ddtrace//lib/datadog/tracing/contrib/sequel/utils.rb#33
    def parse_opts(sql, opts, db_opts, dataset = T.unsafe(nil)); end

    # source://ddtrace//lib/datadog/tracing/contrib/sequel/utils.rb#51
    def set_common_tags(span, db); end

    private

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sequel/utils.rb#71
    def analytics_enabled?; end

    # source://ddtrace//lib/datadog/tracing/contrib/sequel/utils.rb#75
    def analytics_sample_rate; end

    # source://ddtrace//lib/datadog/tracing/contrib/sequel/utils.rb#67
    def datadog_configuration; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/shoryuken/ext.rb#6
module Datadog::Tracing::Contrib::Shoryuken; end

# source://ddtrace//lib/datadog/tracing/contrib/shoryuken/configuration/settings.rb#11
module Datadog::Tracing::Contrib::Shoryuken::Configuration; end

# Default settings for the Shoryuken integration
#
# source://ddtrace//lib/datadog/tracing/contrib/shoryuken/configuration/settings.rb#14
class Datadog::Tracing::Contrib::Shoryuken::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def error_handler; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def error_handler=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def tag_body; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def tag_body=(value); end
end

# Shoryuken integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/shoryuken/ext.rb#9
module Datadog::Tracing::Contrib::Shoryuken::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/shoryuken/ext.rb#11
Datadog::Tracing::Contrib::Shoryuken::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/shoryuken/ext.rb#12
Datadog::Tracing::Contrib::Shoryuken::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/shoryuken/ext.rb#10
Datadog::Tracing::Contrib::Shoryuken::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/shoryuken/ext.rb#13
Datadog::Tracing::Contrib::Shoryuken::Ext::SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/shoryuken/ext.rb#14
Datadog::Tracing::Contrib::Shoryuken::Ext::SPAN_JOB = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/shoryuken/ext.rb#19
Datadog::Tracing::Contrib::Shoryuken::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/shoryuken/ext.rb#17
Datadog::Tracing::Contrib::Shoryuken::Ext::TAG_JOB_ATTRIBUTES = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/shoryuken/ext.rb#18
Datadog::Tracing::Contrib::Shoryuken::Ext::TAG_JOB_BODY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/shoryuken/ext.rb#15
Datadog::Tracing::Contrib::Shoryuken::Ext::TAG_JOB_ID = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/shoryuken/ext.rb#16
Datadog::Tracing::Contrib::Shoryuken::Ext::TAG_JOB_QUEUE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/shoryuken/ext.rb#21
Datadog::Tracing::Contrib::Shoryuken::Ext::TAG_MESSAGING_SYSTEM = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/shoryuken/ext.rb#20
Datadog::Tracing::Contrib::Shoryuken::Ext::TAG_OPERATION_JOB = T.let(T.unsafe(nil), String)

# Description of Shoryuken integration
#
# source://ddtrace//lib/datadog/tracing/contrib/shoryuken/integration.rb#11
class Datadog::Tracing::Contrib::Shoryuken::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/shoryuken/integration.rb#31
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/shoryuken/integration.rb#35
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/shoryuken/integration.rb#27
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/shoryuken/integration.rb#23
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/shoryuken/integration.rb#19
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/shoryuken/integration.rb#14
Datadog::Tracing::Contrib::Shoryuken::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'shoryuken' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/shoryuken/patcher.rb#10
module Datadog::Tracing::Contrib::Shoryuken::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/shoryuken/patcher.rb#19
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/shoryuken/patcher.rb#15
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/shoryuken/patcher.rb#15
    def target_version; end
  end
end

# Tracer is a Shoryuken server-side middleware which traces executed jobs
#
# source://ddtrace//lib/datadog/tracing/contrib/shoryuken/tracer.rb#10
class Datadog::Tracing::Contrib::Shoryuken::Tracer
  # @return [Tracer] a new instance of Tracer
  #
  # source://ddtrace//lib/datadog/tracing/contrib/shoryuken/tracer.rb#11
  def initialize(options = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/contrib/shoryuken/tracer.rb#16
  def call(worker_instance, queue, sqs_msg, body); end

  private

  # source://ddtrace//lib/datadog/tracing/contrib/shoryuken/tracer.rb#58
  def configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/shoryuken/tracer.rb#50
  def resource(worker_instance, body); end
end

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#6
module Datadog::Tracing::Contrib::Sidekiq; end

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/configuration/settings.rb#11
module Datadog::Tracing::Contrib::Sidekiq::Configuration; end

# Custom settings for the Sidekiq integration
#
# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/configuration/settings.rb#14
class Datadog::Tracing::Contrib::Sidekiq::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def client_service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def client_service_name=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def distributed_tracing; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def distributed_tracing=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def error_handler; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def error_handler=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def quantize; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def quantize=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def tag_args; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def tag_args=(value); end
end

# Sidekiq integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#9
module Datadog::Tracing::Contrib::Sidekiq::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#10
Datadog::Tracing::Contrib::Sidekiq::Ext::CLIENT_SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#12
Datadog::Tracing::Contrib::Sidekiq::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#13
Datadog::Tracing::Contrib::Sidekiq::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#11
Datadog::Tracing::Contrib::Sidekiq::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#14
Datadog::Tracing::Contrib::Sidekiq::Ext::ENV_TAG_JOB_ARGS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#15
Datadog::Tracing::Contrib::Sidekiq::Ext::SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#20
Datadog::Tracing::Contrib::Sidekiq::Ext::SPAN_HEARTBEAT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#17
Datadog::Tracing::Contrib::Sidekiq::Ext::SPAN_JOB = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#18
Datadog::Tracing::Contrib::Sidekiq::Ext::SPAN_JOB_FETCH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#16
Datadog::Tracing::Contrib::Sidekiq::Ext::SPAN_PUSH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#19
Datadog::Tracing::Contrib::Sidekiq::Ext::SPAN_REDIS_INFO = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#21
Datadog::Tracing::Contrib::Sidekiq::Ext::SPAN_SCHEDULED_PUSH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#22
Datadog::Tracing::Contrib::Sidekiq::Ext::SPAN_SCHEDULED_WAIT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#23
Datadog::Tracing::Contrib::Sidekiq::Ext::SPAN_STOP = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#31
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#30
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_JOB_ARGS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#24
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_JOB_DELAY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#25
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_JOB_ID = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#26
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_JOB_QUEUE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#27
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_JOB_RETRY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#28
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_JOB_RETRY_COUNT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#29
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_JOB_WRAPPER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#36
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_OPERATION_HEARTBEAT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#33
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_OPERATION_JOB = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#34
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_OPERATION_JOB_FETCH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#32
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_OPERATION_PUSH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#35
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_OPERATION_REDIS_INFO = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#37
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_OPERATION_SCHEDULED_PUSH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#38
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_OPERATION_SCHEDULED_WAIT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/ext.rb#39
Datadog::Tracing::Contrib::Sidekiq::Ext::TAG_OPERATION_STOP = T.let(T.unsafe(nil), String)

# Description of Sidekiq integration
#
# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/integration.rb#10
class Datadog::Tracing::Contrib::Sidekiq::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/sidekiq/integration.rb#48
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/sidekiq/integration.rb#52
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sidekiq/integration.rb#28
    def compatible?; end

    # Only patch server internals on v5.2.4+ because that's when loading of
    # `Sidekiq::Launcher` stabilized. Sidekiq 4+ technically can support our
    # patches (with minor adjustments), but in order to avoid explicitly
    # requiring `sidekiq/launcher` ourselves (which could affect gem
    # initialization order), we are limiting this tracing to v5.2.4+.
    #
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sidekiq/integration.rb#37
    def compatible_with_server_internal_tracing?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sidekiq/integration.rb#24
    def loaded?; end

    # Capsules are a new way of configuring Sidekiq that was introduced in version 7
    # that change the way some of the configuration data is exposed. Certain patches
    # are applied differently for versions of Sidekiq that support capsules.
    #
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sidekiq/integration.rb#44
    def supports_capsules?; end

    # source://ddtrace//lib/datadog/tracing/contrib/sidekiq/integration.rb#20
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/integration.rb#15
Datadog::Tracing::Contrib::Sidekiq::Integration::MINIMUM_CAPSULE_VERSION = T.let(T.unsafe(nil), Gem::Version)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/integration.rb#14
Datadog::Tracing::Contrib::Sidekiq::Integration::MINIMUM_SERVER_INTERNAL_TRACING_VERSION = T.let(T.unsafe(nil), Gem::Version)

# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/integration.rb#13
Datadog::Tracing::Contrib::Sidekiq::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'sidekiq' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/sidekiq/patcher.rb#10
module Datadog::Tracing::Contrib::Sidekiq::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/sidekiq/patcher.rb#19
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/sidekiq/patcher.rb#77
  def patch_redis_info; end

  # source://ddtrace//lib/datadog/tracing/contrib/sidekiq/patcher.rb#51
  def patch_server_heartbeat; end

  # source://ddtrace//lib/datadog/tracing/contrib/sidekiq/patcher.rb#44
  def patch_server_internals; end

  # source://ddtrace//lib/datadog/tracing/contrib/sidekiq/patcher.rb#65
  def patch_server_job_fetch; end

  # source://ddtrace//lib/datadog/tracing/contrib/sidekiq/patcher.rb#71
  def patch_server_scheduled_push; end

  # source://ddtrace//lib/datadog/tracing/contrib/sidekiq/patcher.rb#15
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/sidekiq/patcher.rb#77
    def patch_redis_info; end

    # source://ddtrace//lib/datadog/tracing/contrib/sidekiq/patcher.rb#51
    def patch_server_heartbeat; end

    # source://ddtrace//lib/datadog/tracing/contrib/sidekiq/patcher.rb#44
    def patch_server_internals; end

    # source://ddtrace//lib/datadog/tracing/contrib/sidekiq/patcher.rb#65
    def patch_server_job_fetch; end

    # source://ddtrace//lib/datadog/tracing/contrib/sidekiq/patcher.rb#71
    def patch_server_scheduled_push; end

    # source://ddtrace//lib/datadog/tracing/contrib/sidekiq/patcher.rb#15
    def target_version; end
  end
end

# Instrument Sinatra.
#
# source://ddtrace//lib/datadog/tracing/contrib/sinatra/ext.rb#6
module Datadog::Tracing::Contrib::Sinatra; end

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/configuration/settings.rb#8
module Datadog::Tracing::Contrib::Sinatra::Configuration; end

# Custom settings for the Sinatra integration
#
# source://ddtrace//lib/datadog/tracing/contrib/sinatra/configuration/settings.rb#11
class Datadog::Tracing::Contrib::Sinatra::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def distributed_tracing; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def distributed_tracing=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def headers; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def headers=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def resource_script_names; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def resource_script_names=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/configuration/settings.rb#12
Datadog::Tracing::Contrib::Sinatra::Configuration::Settings::DEFAULT_HEADERS = T.let(T.unsafe(nil), Hash)

# Hook into builder before the middleware list gets frozen
#
# source://ddtrace//lib/datadog/tracing/contrib/sinatra/patcher.rb#26
module Datadog::Tracing::Contrib::Sinatra::DefaultMiddlewarePatch
  # source://ddtrace//lib/datadog/tracing/contrib/sinatra/patcher.rb#29
  def setup_middleware(*args, &block); end
end

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/patcher.rb#27
Datadog::Tracing::Contrib::Sinatra::DefaultMiddlewarePatch::ONLY_ONCE_PER_APP = T.let(T.unsafe(nil), Hash)

# Sinatra integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/sinatra/ext.rb#9
module Datadog::Tracing::Contrib::Sinatra::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/ext.rb#11
Datadog::Tracing::Contrib::Sinatra::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/ext.rb#12
Datadog::Tracing::Contrib::Sinatra::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/ext.rb#10
Datadog::Tracing::Contrib::Sinatra::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/ext.rb#29
Datadog::Tracing::Contrib::Sinatra::Ext::RACK_ENV_MIDDLEWARE_START_TIME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/ext.rb#30
Datadog::Tracing::Contrib::Sinatra::Ext::RACK_ENV_MIDDLEWARE_TRACED = T.let(T.unsafe(nil), String)

# === Deprecated: To be removed ===
#
# source://ddtrace//lib/datadog/tracing/contrib/sinatra/ext.rb#28
Datadog::Tracing::Contrib::Sinatra::Ext::RACK_ENV_REQUEST_SPAN = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/ext.rb#13
Datadog::Tracing::Contrib::Sinatra::Ext::RACK_ENV_SINATRA_REQUEST_SPAN = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/ext.rb#14
Datadog::Tracing::Contrib::Sinatra::Ext::SPAN_RENDER_TEMPLATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/ext.rb#15
Datadog::Tracing::Contrib::Sinatra::Ext::SPAN_REQUEST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/ext.rb#16
Datadog::Tracing::Contrib::Sinatra::Ext::SPAN_ROUTE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/ext.rb#17
Datadog::Tracing::Contrib::Sinatra::Ext::TAG_APP_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/ext.rb#18
Datadog::Tracing::Contrib::Sinatra::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/ext.rb#19
Datadog::Tracing::Contrib::Sinatra::Ext::TAG_OPERATION_RENDER_TEMPLATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/ext.rb#20
Datadog::Tracing::Contrib::Sinatra::Ext::TAG_OPERATION_REQUEST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/ext.rb#21
Datadog::Tracing::Contrib::Sinatra::Ext::TAG_OPERATION_ROUTE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/ext.rb#22
Datadog::Tracing::Contrib::Sinatra::Ext::TAG_ROUTE_PATH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/ext.rb#23
Datadog::Tracing::Contrib::Sinatra::Ext::TAG_SCRIPT_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/ext.rb#24
Datadog::Tracing::Contrib::Sinatra::Ext::TAG_TEMPLATE_ENGINE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/ext.rb#25
Datadog::Tracing::Contrib::Sinatra::Ext::TAG_TEMPLATE_NAME = T.let(T.unsafe(nil), String)

# Sinatra framework code, used to essentially:
# - handle configuration entries which are specific to Datadog tracing
# - instrument parts of the framework when needed
#
# source://ddtrace//lib/datadog/tracing/contrib/sinatra/framework.rb#9
module Datadog::Tracing::Contrib::Sinatra::Framework
  class << self
    # Apply relevant configuration from Sinatra to Rack
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sinatra/framework.rb#23
    def activate_rack!(datadog_config, sinatra_config); end

    # Add Rack middleware at the top of the stack
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sinatra/framework.rb#32
    def add_middleware(middleware, builder, *args, &block); end

    # Add Rack middleware after another in the the stack
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sinatra/framework.rb#61
    def add_middleware_after(after, middleware, builder, *args, &block); end

    # Add Rack middleware before another in the stack
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sinatra/framework.rb#50
    def add_middleware_before(before, middleware, builder, *args, &block); end

    # Add Rack middleware at the top of the stack
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sinatra/framework.rb#43
    def append_middleware(middleware, builder, *args, &block); end

    # source://ddtrace//lib/datadog/tracing/contrib/sinatra/framework.rb#18
    def config_with_defaults(datadog_config); end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sinatra/framework.rb#94
    def include_middleware?(middleware, builder); end

    # Insert a middleware class in the builder as it expects it internally.
    # The block gets passed prepared arguments for the caller to decide
    # how to insert.
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sinatra/framework.rb#81
    def insert_middleware(builder, middleware, args, block); end

    # source://ddtrace//lib/datadog/tracing/contrib/sinatra/framework.rb#107
    def inspect_middlewares(builder); end

    # Introspect middlewares from a builder
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sinatra/framework.rb#99
    def middlewares(builder); end

    # Configure Rack from Sinatra, but only if Rack has not been configured manually beforehand
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sinatra/framework.rb#11
    def setup; end

    # Add Rack middleware at the top of the stack
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sinatra/framework.rb#32
    def unshift_middleare(middleware, builder, *args, &block); end

    # Wrap the middleware class instantiation in a proc, like Sinatra does internally
    # The `middleware` local variable name in the proc is important for introspection
    # (see Framework#middlewares)
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sinatra/framework.rb#74
    def wrap_middleware(middleware, *args, &block); end
  end
end

# Description of Sinatra integration
#
# source://ddtrace//lib/datadog/tracing/contrib/sinatra/integration.rb#10
class Datadog::Tracing::Contrib::Sinatra::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/sinatra/integration.rb#30
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/sinatra/integration.rb#34
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sinatra/integration.rb#26
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sinatra/integration.rb#22
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/sinatra/integration.rb#18
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/integration.rb#13
Datadog::Tracing::Contrib::Sinatra::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'sinatra' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/sinatra/patcher.rb#42
module Datadog::Tracing::Contrib::Sinatra::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/sinatra/patcher.rb#51
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/sinatra/patcher.rb#68
  def patch_default_middlewares; end

  # source://ddtrace//lib/datadog/tracing/contrib/sinatra/patcher.rb#59
  def register_tracer; end

  # source://ddtrace//lib/datadog/tracing/contrib/sinatra/patcher.rb#64
  def setup_tracer; end

  # source://ddtrace//lib/datadog/tracing/contrib/sinatra/patcher.rb#47
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/sinatra/patcher.rb#68
    def patch_default_middlewares; end

    # source://ddtrace//lib/datadog/tracing/contrib/sinatra/patcher.rb#59
    def register_tracer; end

    # source://ddtrace//lib/datadog/tracing/contrib/sinatra/patcher.rb#64
    def setup_tracer; end

    # source://ddtrace//lib/datadog/tracing/contrib/sinatra/patcher.rb#47
    def target_version; end
  end
end

# Set tracer configuration at a late enough time
#
# source://ddtrace//lib/datadog/tracing/contrib/sinatra/patcher.rb#13
module Datadog::Tracing::Contrib::Sinatra::TracerSetupPatch
  # source://ddtrace//lib/datadog/tracing/contrib/sinatra/patcher.rb#16
  def setup_middleware(*args, &block); end
end

# source://ddtrace//lib/datadog/tracing/contrib/sinatra/patcher.rb#14
Datadog::Tracing::Contrib::Sinatra::TracerSetupPatch::ONLY_ONCE_PER_APP = T.let(T.unsafe(nil), Hash)

# source://ddtrace//lib/datadog/tracing/contrib/sneakers/ext.rb#6
module Datadog::Tracing::Contrib::Sneakers; end

# source://ddtrace//lib/datadog/tracing/contrib/sneakers/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Sneakers::Configuration; end

# Default settings for the Shoryuken integration
#
# source://ddtrace//lib/datadog/tracing/contrib/sneakers/configuration/settings.rb#12
class Datadog::Tracing::Contrib::Sneakers::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def error_handler; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def error_handler=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def tag_body; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def tag_body=(value); end
end

# Sneakers integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/sneakers/ext.rb#9
module Datadog::Tracing::Contrib::Sneakers::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/sneakers/ext.rb#11
Datadog::Tracing::Contrib::Sneakers::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sneakers/ext.rb#12
Datadog::Tracing::Contrib::Sneakers::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sneakers/ext.rb#10
Datadog::Tracing::Contrib::Sneakers::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sneakers/ext.rb#13
Datadog::Tracing::Contrib::Sneakers::Ext::SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sneakers/ext.rb#14
Datadog::Tracing::Contrib::Sneakers::Ext::SPAN_JOB = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sneakers/ext.rb#18
Datadog::Tracing::Contrib::Sneakers::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sneakers/ext.rb#17
Datadog::Tracing::Contrib::Sneakers::Ext::TAG_JOB_BODY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sneakers/ext.rb#16
Datadog::Tracing::Contrib::Sneakers::Ext::TAG_JOB_QUEUE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sneakers/ext.rb#15
Datadog::Tracing::Contrib::Sneakers::Ext::TAG_JOB_ROUTING_KEY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sneakers/ext.rb#20
Datadog::Tracing::Contrib::Sneakers::Ext::TAG_MESSAGING_SYSTEM = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sneakers/ext.rb#19
Datadog::Tracing::Contrib::Sneakers::Ext::TAG_OPERATION_JOB = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sneakers/ext.rb#21
Datadog::Tracing::Contrib::Sneakers::Ext::TAG_RABBITMQ_ROUTING_KEY = T.let(T.unsafe(nil), String)

# Description of Sneakers integration
#
# source://ddtrace//lib/datadog/tracing/contrib/sneakers/integration.rb#13
class Datadog::Tracing::Contrib::Sneakers::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/sneakers/integration.rb#33
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/sneakers/integration.rb#37
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sneakers/integration.rb#29
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sneakers/integration.rb#25
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/sneakers/integration.rb#21
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/sneakers/integration.rb#16
Datadog::Tracing::Contrib::Sneakers::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'sneakers' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/sneakers/patcher.rb#11
module Datadog::Tracing::Contrib::Sneakers::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/sneakers/patcher.rb#20
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/sneakers/patcher.rb#16
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/sneakers/patcher.rb#16
    def target_version; end
  end
end

# Tracer is a Sneakers server-side middleware which traces executed jobs
#
# source://ddtrace//lib/datadog/tracing/contrib/sneakers/tracer.rb#11
class Datadog::Tracing::Contrib::Sneakers::Tracer
  # @return [Tracer] a new instance of Tracer
  #
  # source://ddtrace//lib/datadog/tracing/contrib/sneakers/tracer.rb#12
  def initialize(app, *args); end

  # source://ddtrace//lib/datadog/tracing/contrib/sneakers/tracer.rb#17
  def call(deserialized_msg, delivery_info, metadata, handler); end

  private

  # source://ddtrace//lib/datadog/tracing/contrib/sneakers/tracer.rb#53
  def configuration; end
end

# Contains methods for fetching values according to span attributes schema
#
# source://ddtrace//lib/datadog/tracing/contrib/span_attribute_schema.rb#9
module Datadog::Tracing::Contrib::SpanAttributeSchema
  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/span_attribute_schema.rb#13
    def fetch_service_name(env, default); end

    # source://ddtrace//lib/datadog/tracing/contrib/span_attribute_schema.rb#23
    def set_peer_service!(span, sources); end

    private

    # filter_peer_service_sources: returns filtered sources based on existence of peer.service tag
    # If peer.service exists, we do not read from any other source rather use peer.service as source
    # This is to prevent overwriting of pre-existing peer.service tags
    #
    # source://ddtrace//lib/datadog/tracing/contrib/span_attribute_schema.rb#68
    def filter_peer_service_sources(span, sources); end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/span_attribute_schema.rb#84
    def not_empty_tag?(tag); end

    # set_peer_service_from_source: Implements the extraction logic to determine the peer.service value
    # based on the list of source tags passed as a parameter.
    #
    # If no values are found, it checks the default list for all spans before returning false for no result
    # Sets the source of where the information for peer.service was extracted from
    # Returns a peer.service value if successfully set or not
    #
    # source://ddtrace//lib/datadog/tracing/contrib/span_attribute_schema.rb#49
    def set_peer_service_from_source(span, sources = T.unsafe(nil)); end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/span_attribute_schema.rb#11
Datadog::Tracing::Contrib::SpanAttributeSchema::NO_SOURCE = T.let(T.unsafe(nil), Array)

# source://ddtrace//lib/datadog/tracing/contrib/span_attribute_schema.rb#10
Datadog::Tracing::Contrib::SpanAttributeSchema::REFLEXIVE_SOURCES = T.let(T.unsafe(nil), Array)

# Contains methods helpful for tracing/annotating HTTP request libraries
#
# source://ddtrace//lib/datadog/tracing/contrib/status_code_matcher.rb#9
class Datadog::Tracing::Contrib::StatusCodeMatcher
  # @return [StatusCodeMatcher] a new instance of StatusCodeMatcher
  #
  # source://ddtrace//lib/datadog/tracing/contrib/status_code_matcher.rb#12
  def initialize(range); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/contrib/status_code_matcher.rb#17
  def include?(exception_status); end

  # source://ddtrace//lib/datadog/tracing/contrib/status_code_matcher.rb#21
  def to_s; end

  private

  # source://ddtrace//lib/datadog/tracing/contrib/status_code_matcher.rb#47
  def error_responses; end

  # source://ddtrace//lib/datadog/tracing/contrib/status_code_matcher.rb#53
  def handle_statuses; end

  # source://ddtrace//lib/datadog/tracing/contrib/status_code_matcher.rb#27
  def set_range; end
end

# source://ddtrace//lib/datadog/tracing/contrib/status_code_matcher.rb#10
Datadog::Tracing::Contrib::StatusCodeMatcher::REGEX_PARSER = T.let(T.unsafe(nil), Regexp)

# source://ddtrace//lib/datadog/tracing/contrib/stripe/ext.rb#6
module Datadog::Tracing::Contrib::Stripe; end

# source://ddtrace//lib/datadog/tracing/contrib/stripe/configuration/settings.rb#10
module Datadog::Tracing::Contrib::Stripe::Configuration; end

# Custom settings for the Stripe integration
#
# source://ddtrace//lib/datadog/tracing/contrib/stripe/configuration/settings.rb#13
class Datadog::Tracing::Contrib::Stripe::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end
end

# Stripe integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/stripe/ext.rb#9
module Datadog::Tracing::Contrib::Stripe::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/stripe/ext.rb#11
Datadog::Tracing::Contrib::Stripe::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/stripe/ext.rb#12
Datadog::Tracing::Contrib::Stripe::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/stripe/ext.rb#10
Datadog::Tracing::Contrib::Stripe::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/stripe/ext.rb#13
Datadog::Tracing::Contrib::Stripe::Ext::SPAN_REQUEST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/stripe/ext.rb#14
Datadog::Tracing::Contrib::Stripe::Ext::SPAN_TYPE_REQUEST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/stripe/ext.rb#15
Datadog::Tracing::Contrib::Stripe::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/stripe/ext.rb#16
Datadog::Tracing::Contrib::Stripe::Ext::TAG_OPERATION_REQUEST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/stripe/ext.rb#17
Datadog::Tracing::Contrib::Stripe::Ext::TAG_REQUEST_HTTP_STATUS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/stripe/ext.rb#18
Datadog::Tracing::Contrib::Stripe::Ext::TAG_REQUEST_ID = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/stripe/ext.rb#19
Datadog::Tracing::Contrib::Stripe::Ext::TAG_REQUEST_METHOD = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/stripe/ext.rb#20
Datadog::Tracing::Contrib::Stripe::Ext::TAG_REQUEST_NUM_RETRIES = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/stripe/ext.rb#21
Datadog::Tracing::Contrib::Stripe::Ext::TAG_REQUEST_PATH = T.let(T.unsafe(nil), String)

# Description of Stripe integration
#
# source://ddtrace//lib/datadog/tracing/contrib/stripe/integration.rb#12
class Datadog::Tracing::Contrib::Stripe::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/stripe/integration.rb#32
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/stripe/integration.rb#36
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/stripe/integration.rb#28
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/stripe/integration.rb#24
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/stripe/integration.rb#20
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/stripe/integration.rb#15
Datadog::Tracing::Contrib::Stripe::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Provides instrumentation for `stripe` through the Stripe instrumentation framework
#
# source://ddtrace//lib/datadog/tracing/contrib/stripe/patcher.rb#11
module Datadog::Tracing::Contrib::Stripe::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/stripe/patcher.rb#20
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/stripe/patcher.rb#16
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/stripe/patcher.rb#16
    def target_version; end
  end
end

# Defines instrumentation for Stripe requests
#
# source://ddtrace//lib/datadog/tracing/contrib/stripe/request.rb#12
module Datadog::Tracing::Contrib::Stripe::Request
  private

  # source://ddtrace//lib/datadog/tracing/contrib/stripe/request.rb#60
  def configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/stripe/request.rb#22
  def finish_span(event); end

  # source://ddtrace//lib/datadog/tracing/contrib/stripe/request.rb#15
  def start_span(event); end

  # source://ddtrace//lib/datadog/tracing/contrib/stripe/request.rb#35
  def tag_span(span, event); end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/stripe/request.rb#60
    def configuration; end

    # source://ddtrace//lib/datadog/tracing/contrib/stripe/request.rb#22
    def finish_span(event); end

    # source://ddtrace//lib/datadog/tracing/contrib/stripe/request.rb#15
    def start_span(event); end

    # source://ddtrace//lib/datadog/tracing/contrib/stripe/request.rb#35
    def tag_span(span, event); end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/ext.rb#6
module Datadog::Tracing::Contrib::SuckerPunch; end

# source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/configuration/settings.rb#10
module Datadog::Tracing::Contrib::SuckerPunch::Configuration; end

# Custom settings for the SuckerPunch integration
#
# source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/configuration/settings.rb#13
class Datadog::Tracing::Contrib::SuckerPunch::Configuration::Settings < ::Datadog::Tracing::Contrib::Configuration::Settings
  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def analytics_sample_rate; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def analytics_sample_rate=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def enabled; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def enabled=(value); end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#45
  def service_name; end

  # source://ddtrace//lib/datadog/core/configuration/options.rb#48
  def service_name=(value); end
end

# SuckerPunch integration constants
#
# source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/ext.rb#9
module Datadog::Tracing::Contrib::SuckerPunch::Ext; end

# source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/ext.rb#11
Datadog::Tracing::Contrib::SuckerPunch::Ext::ENV_ANALYTICS_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/ext.rb#12
Datadog::Tracing::Contrib::SuckerPunch::Ext::ENV_ANALYTICS_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/ext.rb#10
Datadog::Tracing::Contrib::SuckerPunch::Ext::ENV_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/ext.rb#13
Datadog::Tracing::Contrib::SuckerPunch::Ext::SERVICE_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/ext.rb#14
Datadog::Tracing::Contrib::SuckerPunch::Ext::SPAN_PERFORM = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/ext.rb#15
Datadog::Tracing::Contrib::SuckerPunch::Ext::SPAN_PERFORM_ASYNC = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/ext.rb#16
Datadog::Tracing::Contrib::SuckerPunch::Ext::SPAN_PERFORM_IN = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/ext.rb#19
Datadog::Tracing::Contrib::SuckerPunch::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/ext.rb#20
Datadog::Tracing::Contrib::SuckerPunch::Ext::TAG_OPERATION_PERFORM = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/ext.rb#21
Datadog::Tracing::Contrib::SuckerPunch::Ext::TAG_OPERATION_PERFORM_ASYNC = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/ext.rb#22
Datadog::Tracing::Contrib::SuckerPunch::Ext::TAG_OPERATION_PERFORM_IN = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/ext.rb#17
Datadog::Tracing::Contrib::SuckerPunch::Ext::TAG_PERFORM_IN = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/ext.rb#18
Datadog::Tracing::Contrib::SuckerPunch::Ext::TAG_QUEUE = T.let(T.unsafe(nil), String)

# Description of SuckerPunch integration
#
# source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/integration.rb#10
class Datadog::Tracing::Contrib::SuckerPunch::Integration
  include ::Datadog::Tracing::Contrib::Integration
  include ::Datadog::Tracing::Contrib::Configurable
  include ::Datadog::Tracing::Contrib::Configurable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Patchable
  include ::Datadog::Tracing::Contrib::Patchable::InstanceMethods
  include ::Datadog::Tracing::Contrib::Registerable
  include ::Datadog::Tracing::Contrib::Registerable::InstanceMethods
  extend ::Datadog::Tracing::Contrib::Patchable::ClassMethods
  extend ::Datadog::Tracing::Contrib::Registerable::ClassMethods

  # source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/integration.rb#30
  def new_configuration; end

  # source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/integration.rb#34
  def patcher; end

  class << self
    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/integration.rb#26
    def compatible?; end

    # @return [Boolean]
    #
    # source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/integration.rb#22
    def loaded?; end

    # source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/integration.rb#18
    def version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/integration.rb#13
Datadog::Tracing::Contrib::SuckerPunch::Integration::MINIMUM_VERSION = T.let(T.unsafe(nil), Gem::Version)

# Patcher enables patching of 'sucker_punch' module.
#
# source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/patcher.rb#11
module Datadog::Tracing::Contrib::SuckerPunch::Patcher
  include ::Datadog::Tracing::Contrib::Patcher
  extend ::Datadog::Tracing::Contrib::Patcher::CommonMethods

  private

  # source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/patcher.rb#28
  def get_option(option); end

  # source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/patcher.rb#20
  def patch; end

  # source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/patcher.rb#16
  def target_version; end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/patcher.rb#28
    def get_option(option); end

    # source://ddtrace//lib/datadog/tracing/contrib/patcher.rb#31
    def patch; end

    # source://ddtrace//lib/datadog/tracing/contrib/sucker_punch/patcher.rb#16
    def target_version; end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/http.rb#7
module Datadog::Tracing::Contrib::Utils; end

# Common database-related utility functions.
#
# source://ddtrace//lib/datadog/tracing/contrib/utils/database.rb#8
module Datadog::Tracing::Contrib::Utils::Database
  private

  # source://ddtrace//lib/datadog/tracing/contrib/utils/database.rb#15
  def normalize_vendor(vendor); end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/utils/database.rb#15
    def normalize_vendor(vendor); end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/utils/database.rb#9
Datadog::Tracing::Contrib::Utils::Database::VENDOR_DEFAULT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/utils/database.rb#10
Datadog::Tracing::Contrib::Utils::Database::VENDOR_POSTGRES = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/utils/database.rb#11
Datadog::Tracing::Contrib::Utils::Database::VENDOR_SQLITE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/http.rb#8
module Datadog::Tracing::Contrib::Utils::Quantization; end

# Quantization for HTTP resources
#
# source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/http.rb#10
module Datadog::Tracing::Contrib::Utils::Quantization::HTTP
  private

  # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/http.rb#29
  def base_url(url, options = T.unsafe(nil)); end

  # Iterate over each key value pair, yielding to the block given.
  # Accepts :uniq option, which keeps uniq copies of keys without values.
  # e.g. Reduces "foo&bar=bar&bar=bar&foo" to "foo&bar=bar&bar=bar"
  #
  # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/http.rb#91
  def collect_query(query, options = T.unsafe(nil)); end

  # Scans over the query string and obfuscates sensitive data by
  # replacing matches with an opaque value
  #
  # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/http.rb#119
  def obfuscate_query(query, options = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/http.rb#58
  def query(query, options = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/http.rb#64
  def query!(query, options = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/http.rb#21
  def url(url, options = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/http.rb#37
  def url!(url, options = T.unsafe(nil)); end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/http.rb#29
    def base_url(url, options = T.unsafe(nil)); end

    # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/http.rb#58
    def query(query, options = T.unsafe(nil)); end

    # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/http.rb#64
    def query!(query, options = T.unsafe(nil)); end

    # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/http.rb#21
    def url(url, options = T.unsafe(nil)); end

    # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/http.rb#37
    def url!(url, options = T.unsafe(nil)); end

    private

    # Iterate over each key value pair, yielding to the block given.
    # Accepts :uniq option, which keeps uniq copies of keys without values.
    # e.g. Reduces "foo&bar=bar&bar=bar&foo" to "foo&bar=bar&bar=bar"
    #
    # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/http.rb#91
    def collect_query(query, options = T.unsafe(nil)); end

    # Scans over the query string and obfuscates sensitive data by
    # replacing matches with an opaque value
    #
    # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/http.rb#119
    def obfuscate_query(query, options = T.unsafe(nil)); end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/http.rb#132
Datadog::Tracing::Contrib::Utils::Quantization::HTTP::OBFUSCATOR_REGEX = T.let(T.unsafe(nil), Regexp)

# source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/http.rb#129
Datadog::Tracing::Contrib::Utils::Quantization::HTTP::OBFUSCATOR_WITH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/http.rb#11
Datadog::Tracing::Contrib::Utils::Quantization::HTTP::PLACEHOLDER = T.let(T.unsafe(nil), String)

# taken from Ruby https://github.com/ruby/uri/blob/eaf89cc31619d49e67c64d0b58ea9dc38892d175/lib/uri/rfc3986_parser.rb
# but adjusted to parse only <scheme>://<host>:<port>/ components
# and stop there, since we don't care about the path, query string,
# and fragment components
#
# source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/http.rb#17
Datadog::Tracing::Contrib::Utils::Quantization::HTTP::RFC3986_URL_BASE = T.let(T.unsafe(nil), Regexp)

# Quantization for Hash
#
# source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/hash.rb#7
module Datadog::Tracing::Contrib::Utils::Quantization::Hash
  private

  # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/hash.rb#101
  def convert_value(value); end

  # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/hash.rb#19
  def format(hash_obj, options = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/hash.rb#26
  def format!(hash_obj, options = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/hash.rb#64
  def format_array(value, options); end

  # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/hash.rb#32
  def format_hash(hash_obj, options = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/hash.rb#50
  def format_value(value, options = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/hash.rb#96
  def indifferent_equals(value); end

  # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/hash.rb#74
  def merge_options(original, additional); end

  class << self
    # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/hash.rb#101
    def convert_value(value); end

    # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/hash.rb#19
    def format(hash_obj, options = T.unsafe(nil)); end

    # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/hash.rb#26
    def format!(hash_obj, options = T.unsafe(nil)); end

    # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/hash.rb#64
    def format_array(value, options); end

    # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/hash.rb#32
    def format_hash(hash_obj, options = T.unsafe(nil)); end

    # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/hash.rb#50
    def format_value(value, options = T.unsafe(nil)); end

    # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/hash.rb#96
    def indifferent_equals(value); end

    # source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/hash.rb#74
    def merge_options(original, additional); end
  end
end

# source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/hash.rb#11
Datadog::Tracing::Contrib::Utils::Quantization::Hash::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/hash.rb#9
Datadog::Tracing::Contrib::Utils::Quantization::Hash::EXCLUDE_KEYS = T.let(T.unsafe(nil), Array)

# source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/hash.rb#8
Datadog::Tracing::Contrib::Utils::Quantization::Hash::PLACEHOLDER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/contrib/utils/quantization/hash.rb#10
Datadog::Tracing::Contrib::Utils::Quantization::Hash::SHOW_KEYS = T.let(T.unsafe(nil), Array)

# Contains behavior for managing correlations with tracing
# e.g. Retrieve a correlation to the current trace for logging, etc.
#
# source://ddtrace//lib/datadog/tracing/correlation.rb#8
module Datadog::Tracing::Correlation
  private

  # Produces a CorrelationIdentifier from the TraceDigest provided
  #
  # DEV: can we memoize this object, give it can be common to
  # use a correlation multiple times, specially in the context of logging?
  #
  # source://ddtrace//lib/datadog/tracing/correlation.rb#91
  def identifier_from_digest(digest); end

  class << self
    # Produces a CorrelationIdentifier from the TraceDigest provided
    #
    # DEV: can we memoize this object, give it can be common to
    # use a correlation multiple times, specially in the context of logging?
    #
    # source://ddtrace//lib/datadog/tracing/correlation.rb#91
    def identifier_from_digest(digest); end
  end
end

# Represents current trace state with key identifiers
#
# source://ddtrace//lib/datadog/tracing/correlation.rb#11
class Datadog::Tracing::Correlation::Identifier
  # @return [Identifier] a new instance of Identifier
  #
  # source://ddtrace//lib/datadog/tracing/correlation.rb#32
  def initialize(env: T.unsafe(nil), service: T.unsafe(nil), span_id: T.unsafe(nil), span_name: T.unsafe(nil), span_resource: T.unsafe(nil), span_service: T.unsafe(nil), span_type: T.unsafe(nil), trace_id: T.unsafe(nil), trace_name: T.unsafe(nil), trace_resource: T.unsafe(nil), trace_service: T.unsafe(nil), version: T.unsafe(nil)); end

  # Returns the value of attribute env.
  #
  # source://ddtrace//lib/datadog/tracing/correlation.rb#18
  def env; end

  # Returns the value of attribute service.
  #
  # source://ddtrace//lib/datadog/tracing/correlation.rb#18
  def service; end

  # Returns the value of attribute span_id.
  #
  # source://ddtrace//lib/datadog/tracing/correlation.rb#18
  def span_id; end

  # Returns the value of attribute span_name.
  #
  # source://ddtrace//lib/datadog/tracing/correlation.rb#18
  def span_name; end

  # Returns the value of attribute span_resource.
  #
  # source://ddtrace//lib/datadog/tracing/correlation.rb#18
  def span_resource; end

  # Returns the value of attribute span_service.
  #
  # source://ddtrace//lib/datadog/tracing/correlation.rb#18
  def span_service; end

  # Returns the value of attribute span_type.
  #
  # source://ddtrace//lib/datadog/tracing/correlation.rb#18
  def span_type; end

  # source://ddtrace//lib/datadog/tracing/correlation.rb#61
  def to_log_format; end

  # DEV-2.0: This public method was returning an Integer, but with 128 bit trace id it would return a String.
  #
  # source://ddtrace//lib/datadog/tracing/correlation.rb#74
  def trace_id; end

  # Returns the value of attribute trace_name.
  #
  # source://ddtrace//lib/datadog/tracing/correlation.rb#18
  def trace_name; end

  # Returns the value of attribute trace_resource.
  #
  # source://ddtrace//lib/datadog/tracing/correlation.rb#18
  def trace_resource; end

  # Returns the value of attribute trace_service.
  #
  # source://ddtrace//lib/datadog/tracing/correlation.rb#18
  def trace_service; end

  # Returns the value of attribute version.
  #
  # source://ddtrace//lib/datadog/tracing/correlation.rb#18
  def version; end
end

# source://ddtrace//lib/datadog/tracing/correlation.rb#12
Datadog::Tracing::Correlation::Identifier::LOG_ATTR_ENV = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/correlation.rb#13
Datadog::Tracing::Correlation::Identifier::LOG_ATTR_SERVICE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/correlation.rb#14
Datadog::Tracing::Correlation::Identifier::LOG_ATTR_SPAN_ID = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/correlation.rb#15
Datadog::Tracing::Correlation::Identifier::LOG_ATTR_TRACE_ID = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/correlation.rb#16
Datadog::Tracing::Correlation::Identifier::LOG_ATTR_VERSION = T.let(T.unsafe(nil), String)

# DefaultContextProvider is a default context provider that retrieves
# all contexts from the current fiber-local storage. It is suitable for
# synchronous programming.
#
# @see https://ruby-doc.org/core-3.1.2/Thread.html#method-i-5B-5D Thread attributes are fiber-local
#
# source://ddtrace//lib/datadog/tracing/context_provider.rb#11
class Datadog::Tracing::DefaultContextProvider
  # Initializes the default context provider with a fiber-bound context.
  #
  # @return [DefaultContextProvider] a new instance of DefaultContextProvider
  #
  # source://ddtrace//lib/datadog/tracing/context_provider.rb#13
  def initialize; end

  # Return the local context.
  #
  # source://ddtrace//lib/datadog/tracing/context_provider.rb#23
  def context(key = T.unsafe(nil)); end

  # Sets the current context.
  #
  # source://ddtrace//lib/datadog/tracing/context_provider.rb#18
  def context=(ctx); end
end

# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#5
module Datadog::Tracing::Diagnostics; end

# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#7
module Datadog::Tracing::Diagnostics::Ext; end

# Health
#
# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#9
module Datadog::Tracing::Diagnostics::Ext::Health; end

# Metrics
#
# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#11
module Datadog::Tracing::Diagnostics::Ext::Health::Metrics; end

# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#12
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_API_ERRORS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#13
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_API_REQUESTS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#14
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_API_RESPONSES = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#15
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_ERROR_CONTEXT_OVERFLOW = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#16
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_ERROR_INSTRUMENTATION_PATCH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#17
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_ERROR_SPAN_FINISH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#18
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_ERROR_UNFINISHED_SPANS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#19
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_INSTRUMENTATION_PATCHED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#20
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_QUEUE_ACCEPTED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#21
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_QUEUE_ACCEPTED_LENGTHS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#22
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_QUEUE_DROPPED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#23
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_QUEUE_LENGTH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#24
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_QUEUE_MAX_LENGTH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#25
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_QUEUE_SPANS = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#26
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_SAMPLING_SERVICE_CACHE_LENGTH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#27
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_TRACES_FILTERED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#28
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_TRANSPORT_CHUNKED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#29
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_TRANSPORT_TRACE_TOO_LARGE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/diagnostics/ext.rb#30
Datadog::Tracing::Diagnostics::Ext::Health::Metrics::METRIC_WRITER_CPU_TIME = T.let(T.unsafe(nil), String)

# Health-related diagnostics
#
# source://ddtrace//lib/datadog/tracing/diagnostics/health.rb#9
module Datadog::Tracing::Diagnostics::Health; end

# Health metrics for diagnostics
#
# source://ddtrace//lib/datadog/tracing/diagnostics/health.rb#11
module Datadog::Tracing::Diagnostics::Health::Metrics
  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/diagnostics/health.rb#12
    def extended(base); end
  end
end

# source://ddtrace//lib/datadog/tracing/distributed/helpers.rb#8
module Datadog::Tracing::Distributed; end

# B3 multi header-style trace propagation.
#
# @see https://github.com/openzipkin/b3-propagation#multiple-headers
#
# source://ddtrace//lib/datadog/tracing/distributed/b3_multi.rb#12
class Datadog::Tracing::Distributed::B3Multi
  # @return [B3Multi] a new instance of B3Multi
  #
  # source://ddtrace//lib/datadog/tracing/distributed/b3_multi.rb#17
  def initialize(fetcher:, trace_id_key: T.unsafe(nil), span_id_key: T.unsafe(nil), sampled_key: T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/distributed/b3_multi.rb#46
  def extract(data); end

  # source://ddtrace//lib/datadog/tracing/distributed/b3_multi.rb#29
  def inject!(digest, data = T.unsafe(nil)); end
end

# source://ddtrace//lib/datadog/tracing/distributed/b3_multi.rb#15
Datadog::Tracing::Distributed::B3Multi::B3_SAMPLED_KEY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/distributed/b3_multi.rb#14
Datadog::Tracing::Distributed::B3Multi::B3_SPAN_ID_KEY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/distributed/b3_multi.rb#13
Datadog::Tracing::Distributed::B3Multi::B3_TRACE_ID_KEY = T.let(T.unsafe(nil), String)

# B3 single header-style trace propagation.
#
# DEV: Format:
# DEV:   b3: {TraceId}-{SpanId}-{SamplingState}-{ParentSpanId}
# DEV: https://github.com/apache/incubator-zipkin-b3-propagation/tree/7c6e9f14d6627832bd80baa87ac7dabee7be23cf#single-header
# DEV: `{SamplingState}` and `{ParentSpanId}` are optional
#
# @see https://github.com/openzipkin/b3-propagation#single-header
#
# source://ddtrace//lib/datadog/tracing/distributed/b3_single.rb#17
class Datadog::Tracing::Distributed::B3Single
  # @return [B3Single] a new instance of B3Single
  #
  # source://ddtrace//lib/datadog/tracing/distributed/b3_single.rb#20
  def initialize(fetcher:, key: T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/distributed/b3_single.rb#42
  def extract(env); end

  # source://ddtrace//lib/datadog/tracing/distributed/b3_single.rb#25
  def inject!(digest, env); end
end

# source://ddtrace//lib/datadog/tracing/distributed/b3_single.rb#18
Datadog::Tracing::Distributed::B3Single::B3_SINGLE_HEADER_KEY = T.let(T.unsafe(nil), String)

# Datadog-style trace propagation.
#
# source://ddtrace//lib/datadog/tracing/distributed/datadog.rb#13
class Datadog::Tracing::Distributed::Datadog
  # @return [Datadog] a new instance of Datadog
  #
  # source://ddtrace//lib/datadog/tracing/distributed/datadog.rb#24
  def initialize(fetcher:, trace_id_key: T.unsafe(nil), parent_id_key: T.unsafe(nil), sampling_priority_key: T.unsafe(nil), origin_key: T.unsafe(nil), tags_key: T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/distributed/datadog.rb#56
  def extract(data); end

  # source://ddtrace//lib/datadog/tracing/distributed/datadog.rb#40
  def inject!(digest, data); end

  private

  # source://ddtrace//lib/datadog/tracing/distributed/datadog.rb#106
  def build_tags(digest); end

  # Import `x-datadog-tags` tags as trace distributed tags.
  # Only tags that have the `_dd.p.` prefix are processed.
  #
  # DEV: This method accesses global state (the active trace) to record its error state as a trace tag.
  # DEV: This means errors cannot be reported if there's not active span.
  # DEV: Ideally, we'd have a dedicated error reporting stream for all of ddtrace.
  #
  # source://ddtrace//lib/datadog/tracing/distributed/datadog.rb#152
  def extract_tags(fetcher); end

  # Side effect: Remove high order 64 bit hex-encoded `tid` tag from distributed tags
  #
  # source://ddtrace//lib/datadog/tracing/distributed/datadog.rb#116
  def extract_trace_id!(trace_id, tags); end

  # Export trace distributed tags through the `x-datadog-tags` key.
  #
  # DEV: This method accesses global state (the active trace) to record its error state as a trace tag.
  # DEV: This means errors cannot be reported if there's not active span.
  # DEV: Ideally, we'd have a dedicated error reporting stream for all of ddtrace.
  #
  # source://ddtrace//lib/datadog/tracing/distributed/datadog.rb#128
  def inject_tags!(tags, data); end

  # source://ddtrace//lib/datadog/tracing/distributed/datadog.rb#97
  def parse_parent_id(fetcher_object); end

  # source://ddtrace//lib/datadog/tracing/distributed/datadog.rb#88
  def parse_trace_id(fetcher_object); end

  # source://ddtrace//lib/datadog/tracing/distributed/datadog.rb#172
  def set_tags_propagation_error(reason:); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/distributed/datadog.rb#178
  def tags_disabled?; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/distributed/datadog.rb#182
  def tags_too_large?(size, scenario:); end
end

# We want to exclude tags that we don't want to propagate downstream.
#
# source://ddtrace//lib/datadog/tracing/distributed/datadog.rb#195
Datadog::Tracing::Distributed::Datadog::EXCLUDED_TAG = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/distributed/datadog.rb#17
Datadog::Tracing::Distributed::Datadog::ORIGIN_KEY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/distributed/datadog.rb#15
Datadog::Tracing::Distributed::Datadog::PARENT_ID_KEY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/distributed/datadog.rb#16
Datadog::Tracing::Distributed::Datadog::SAMPLING_PRIORITY_KEY = T.let(T.unsafe(nil), String)

# Distributed trace-level tags
#
# source://ddtrace//lib/datadog/tracing/distributed/datadog.rb#19
Datadog::Tracing::Distributed::Datadog::TAGS_KEY = T.let(T.unsafe(nil), String)

# Prefix used by all Datadog-specific distributed tags
#
# source://ddtrace//lib/datadog/tracing/distributed/datadog.rb#22
Datadog::Tracing::Distributed::Datadog::TAGS_PREFIX = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/distributed/datadog.rb#14
Datadog::Tracing::Distributed::Datadog::TRACE_ID_KEY = T.let(T.unsafe(nil), String)

# Encodes and decodes distributed 'x-datadog-tags' tags for transport
# to and from external processes.
#
# source://ddtrace//lib/datadog/tracing/distributed/datadog_tags_codec.rb#8
module Datadog::Tracing::Distributed::DatadogTagsCodec
  class << self
    # Deserializes a `x-datadog-tags`-formatted String into a {Hash<String,String>}.
    #
    # @param string [String] tags as serialized by {#encode}
    # @raise [DecodingError] if string does not conform to the `x-datadog-tags` format
    # @return [Hash<String,String>] decoded input as a hash of strings
    #
    # source://ddtrace//lib/datadog/tracing/distributed/datadog_tags_codec.rb#54
    def decode(string); end

    # Serializes a {Hash<String,String>} into a `x-datadog-tags`-compatible
    # String.
    #
    # @param tags [Hash<String,String>] trace tag hash
    # @raise [EncodingError] if tags cannot be serialized to the `x-datadog-tags` format
    # @return [String] serialized tags hash
    #
    # source://ddtrace//lib/datadog/tracing/distributed/datadog_tags_codec.rb#33
    def encode(tags); end
  end
end

# An error occurred during distributed tags decoding.
# See {#message} for more information.
#
# source://ddtrace//lib/datadog/tracing/distributed/datadog_tags_codec.rb#79
class Datadog::Tracing::Distributed::DatadogTagsCodec::DecodingError < ::StandardError; end

# An error occurred during distributed tags encoding.
# See {#message} for more information.
#
# source://ddtrace//lib/datadog/tracing/distributed/datadog_tags_codec.rb#74
class Datadog::Tracing::Distributed::DatadogTagsCodec::EncodingError < ::StandardError; end

# Backport `Regexp::match?` because it is measurably the most performant
# way to check if a string matches a regular expression.
#
# source://ddtrace//lib/datadog/tracing/distributed/datadog_tags_codec.rb#11
module Datadog::Tracing::Distributed::DatadogTagsCodec::RefineRegexp; end

# ASCII characters 32-126, except `,`, `=`, and ` `. At least one character.
#
# source://ddtrace//lib/datadog/tracing/distributed/datadog_tags_codec.rb#23
Datadog::Tracing::Distributed::DatadogTagsCodec::VALID_KEY_CHARS = T.let(T.unsafe(nil), Regexp)

# ASCII characters 32-126, except `,`. At least one character.
#
# source://ddtrace//lib/datadog/tracing/distributed/datadog_tags_codec.rb#25
Datadog::Tracing::Distributed::DatadogTagsCodec::VALID_VALUE_CHARS = T.let(T.unsafe(nil), Regexp)

# Common fetcher that retrieves fields from a Hash data input
#
# source://ddtrace//lib/datadog/tracing/distributed/fetcher.rb#9
class Datadog::Tracing::Distributed::Fetcher
  # @param data [Hash]
  # @return [Fetcher] a new instance of Fetcher
  #
  # source://ddtrace//lib/datadog/tracing/distributed/fetcher.rb#11
  def initialize(data); end

  # source://ddtrace//lib/datadog/tracing/distributed/fetcher.rb#15
  def [](key); end
end

# Helpers module provides common helper functions for distributed tracing data
#
# source://ddtrace//lib/datadog/tracing/distributed/helpers.rb#10
module Datadog::Tracing::Distributed::Helpers
  class << self
    # Base provides common methods for distributed helper classes
    #
    # source://ddtrace//lib/datadog/tracing/distributed/helpers.rb#12
    def clamp_sampling_priority(sampling_priority); end

    # source://ddtrace//lib/datadog/tracing/distributed/helpers.rb#23
    def parse_decimal_id(value); end

    # source://ddtrace//lib/datadog/tracing/distributed/helpers.rb#37
    def parse_hex_id(value); end
  end
end

# Propagator that does not inject nor extract data. It performs no operation.
# Supported for feature parity with OpenTelemetry.
#
# @see https://github.com/open-telemetry/opentelemetry-specification/blob/255a6c52b8914a2ed7e26bb5585abecab276aafc/specification/sdk-environment-variables.md?plain=1#L88
#
# source://ddtrace//lib/datadog/tracing/distributed/none.rb#9
class Datadog::Tracing::Distributed::None
  # No-op
  #
  # source://ddtrace//lib/datadog/tracing/distributed/none.rb#14
  def extract(_data); end

  # No-op
  #
  # source://ddtrace//lib/datadog/tracing/distributed/none.rb#11
  def inject!(_digest, _data); end
end

# Provides extraction and injection of distributed trace data.
#
# source://ddtrace//lib/datadog/tracing/distributed/propagation.rb#11
class Datadog::Tracing::Distributed::Propagation
  # DEV: This class should receive the value for
  # DEV: `Datadog.configuration.tracing.distributed_tracing.propagation_inject_style`
  # DEV: at initialization time, instead of constantly reading global values.
  # DEV: This means this class should be reconfigured on `Datadog.configure` calls, thus
  # DEV: singleton instances should not used as they will become stale.
  #
  # @param propagation_styles [Hash<String,Object>]
  # @return [Propagation] a new instance of Propagation
  #
  # source://ddtrace//lib/datadog/tracing/distributed/propagation.rb#19
  def initialize(propagation_styles:); end

  # extract returns {TraceDigest} containing the distributed trace information.
  # sampling priority defined in data.
  #
  # This method will never raise errors, but instead log them to `Datadog.logger`.
  #
  # @param data [Hash]
  #
  # source://ddtrace//lib/datadog/tracing/distributed/propagation.rb#74
  def extract(data); end

  # inject! populates the env with span ID, trace ID and sampling priority
  #
  # This method will never raise errors, but instead log them to `Datadog.logger`.
  #
  # DEV-2.0: inject! should work without arguments, injecting the active_trace's digest
  # DEV-2.0: and returning a new Hash with the injected data.
  # DEV-2.0: inject! should also accept either a `trace` or a `digest`, as a `trace`
  # DEV-2.0: argument is the common use case, but also allows us to set error tags in the `trace`
  # DEV-2.0: if needed.
  # DEV-2.0: Ideally, we'd have a separate stream to report tracer errors and never
  # DEV-2.0: touch the active span.
  #
  # @param digest [TraceDigest]
  # @param data [Hash]
  # @return [Boolean] `true` if injected successfully, `false` if no propagation style is configured
  # @return [nil] in case of error, see `Datadog.logger` output for details.
  #
  # source://ddtrace//lib/datadog/tracing/distributed/propagation.rb#39
  def inject!(digest, data); end
end

# W3C Trace Context propagator implementation, version 00.
# The trace is propagated through two fields: `traceparent` and `tracestate`.
#
# @see https://www.w3.org/TR/trace-context/
#
# source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#9
class Datadog::Tracing::Distributed::TraceContext
  # @return [TraceContext] a new instance of TraceContext
  #
  # source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#14
  def initialize(fetcher:, traceparent_key: T.unsafe(nil), tracestate_key: T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#38
  def extract(data); end

  # source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#24
  def inject!(digest, data); end

  private

  # Sets the trace flag to an existing `trace_flags`.
  #
  # source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#128
  def build_trace_flags(digest); end

  # @see https://www.w3.org/TR/trace-context/#traceparent-header
  #
  # source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#100
  def build_traceparent(digest); end

  # For the current version (00), the traceparent has the following format:
  #
  # `"#{version}-#{trace_id}-#{parent_id}-#{trace_flags}"`
  #
  # Where:
  #   * `version`: 2 hex-encoded digits, zero padded.
  #   * `trace_id`: 32 hex-encoded digits, zero padded.
  #   * `parent_id`: 16 hex-encoded digits, zero padded.
  #   * `trace_flags`: 2 hex-encoded digits, zero padded.
  #
  # All hex values should be lowercase.
  #
  # @param trace_id [Integer] 128-bit
  # @param parent_id [Integer] 64-bit
  # @param trace_flags [Integer] 8-bit
  #
  # source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#123
  def build_traceparent_string(trace_id, parent_id, trace_flags); end

  # @see https://www.w3.org/TR/trace-context/#tracestate-header
  #
  # source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#143
  def build_tracestate(digest); end

  # Restore `~` back to `=`.
  #
  # source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#340
  def deserialize_tag_value(value); end

  # source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#304
  def extract_datadog_fields(dd_tracestate); end

  # source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#250
  def extract_traceparent(traceparent); end

  # @return [Array<String,Integer,String,Hash>] returns 4 values: tracestate, sampling_priority, origin, tags.
  #
  # source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#286
  def extract_tracestate(tracestate); end

  # If `sampled` and `sampling_priority` disagree, `sampled` overrides the decision.
  #
  # @return [Integer] one of the {Datadog::Tracing::Sampling::Ext::Priority} values
  # @yieldparam the new decision maker (either :drop or a new decision maker String value).
  #
  # source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#348
  def parse_priority_sampling(sampled, sampling_priority); end

  # source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#281
  def parse_sampled_flag(trace_flags); end

  # source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#261
  def parse_traceparent_string(traceparent); end

  # If any characters in <origin_value> are invalid, replace each invalid character with 0x5F (underscore).
  # Invalid characters are: characters outside the ASCII range 0x20 to 0x7E,
  # 0x2C (comma), 0x3B (semi-colon), and 0x7E (tilde).
  # Then, remap 0x3D (equals) to 0x7E (tilde)
  #
  # source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#195
  def serialize_origin(value); end

  # Serialize `_dd.p.{key}` by first removing the `_dd.p.` prefix.
  # Then replacing invalid characters with `_`.
  #
  # The argument `name` is always frozen.
  # Returns a new String object for the serialized key.
  #
  # source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#217
  def serialize_tag_key(name); end

  # Replaces invalid characters with `_`, then replaces `=` with `~`.
  #
  # The argument `value` belongs to {TraceDigest}, thus should not be directly modified.
  # Returns a new String object for the serialized value.
  #
  # source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#232
  def serialize_tag_value(value); end

  # source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#370
  def split_tracestate(tracestate); end
end

# Empty 8-bit `trace-flags`.
#
# @see https://www.w3.org/TR/trace-context/#trace-flags
#
# source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#381
Datadog::Tracing::Distributed::TraceContext::DEFAULT_TRACE_FLAGS = T.let(T.unsafe(nil), Integer)

# Replace all characters with `_`, except ASCII characters 0x20-0x7E.
# Additionally, `,`, ';', and `~` must also be replaced by `_`.
#
# source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#396
Datadog::Tracing::Distributed::TraceContext::INVALID_ORIGIN_CHARS = T.let(T.unsafe(nil), Regexp)

# Replace all characters with `_`, except ASCII characters 0x21-0x7E.
# Additionally, `,` and `=` must also be replaced by `_`.
#
# source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#405
Datadog::Tracing::Distributed::TraceContext::INVALID_TAG_KEY_CHARS = T.let(T.unsafe(nil), Regexp)

# Replace all characters with `_`, except ASCII characters 0x20-0x7D.
# Additionally, `,` and `;` must also be replaced by `_`.
#
# source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#410
Datadog::Tracing::Distributed::TraceContext::INVALID_TAG_VALUE_CHARS = T.let(T.unsafe(nil), Regexp)

# Version 0xFF is invalid as per spec
#
# @see https://www.w3.org/TR/trace-context/#version
#
# source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#376
Datadog::Tracing::Distributed::TraceContext::INVALID_VERSION = T.let(T.unsafe(nil), String)

# Additionally, remap `=` to `~`
#
# source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#400
Datadog::Tracing::Distributed::TraceContext::REMAP_ORIGIN_CHARS = T.let(T.unsafe(nil), Regexp)

# Refinements to ensure newer rubies do not suffer performance impact
# by needing to use older APIs.
#
# source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#73
module Datadog::Tracing::Distributed::TraceContext::Refine; end

# source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#12
Datadog::Tracing::Distributed::TraceContext::SPEC_VERSION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#10
Datadog::Tracing::Distributed::TraceContext::TRACEPARENT_KEY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#11
Datadog::Tracing::Distributed::TraceContext::TRACESTATE_KEY = T.let(T.unsafe(nil), String)

# The limit is inclusive: sizes *greater* than 256 are disallowed.
#
# @see https://www.w3.org/TR/trace-context/#value
#
# source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#391
Datadog::Tracing::Distributed::TraceContext::TRACESTATE_VALUE_SIZE_LIMIT = T.let(T.unsafe(nil), Integer)

# Bit-mask for `trace-flags` that represents a sampled span (sampled==true).
#
# @see https://www.w3.org/TR/trace-context/#trace-flags
#
# source://ddtrace//lib/datadog/tracing/distributed/trace_context.rb#386
Datadog::Tracing::Distributed::TraceContext::TRACE_FLAGS_SAMPLED = T.let(T.unsafe(nil), Integer)

# A simple pub-sub event model for components to exchange messages through.
#
# source://ddtrace//lib/datadog/tracing/event.rb#36
class Datadog::Tracing::Event
  # @return [Event] a new instance of Event
  #
  # source://ddtrace//lib/datadog/tracing/event.rb#41
  def initialize(name); end

  # Returns the value of attribute name.
  #
  # source://ddtrace//lib/datadog/tracing/event.rb#37
  def name; end

  # source://ddtrace//lib/datadog/tracing/event.rb#58
  def publish(*args); end

  # @raise [ArgumentError]
  #
  # source://ddtrace//lib/datadog/tracing/event.rb#46
  def subscribe(&block); end

  # Returns the value of attribute subscriptions.
  #
  # source://ddtrace//lib/datadog/tracing/event.rb#37
  def subscriptions; end

  # source://ddtrace//lib/datadog/tracing/event.rb#52
  def unsubscribe_all!; end
end

# Event behavior and DSL
#
# source://ddtrace//lib/datadog/tracing/event.rb#4
module Datadog::Tracing::Events
  include ::Datadog::Tracing::Events::InstanceMethods

  mixes_in_class_methods ::Datadog::Tracing::Events::ClassMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/event.rb#5
    def included(base); end
  end
end

# Class methods
#
# source://ddtrace//lib/datadog/tracing/event.rb#11
module Datadog::Tracing::Events::ClassMethods
  # source://ddtrace//lib/datadog/tracing/event.rb#12
  def build(**event_handlers); end
end

# Instance methods
#
# source://ddtrace//lib/datadog/tracing/event.rb#20
module Datadog::Tracing::Events::InstanceMethods
  # source://ddtrace//lib/datadog/tracing/event.rb#21
  def subscribe(**event_handlers); end
end

# FiberLocalContext can be used as a tracer global reference to create
# a different {Datadog::Tracing::Context} for each fiber. This allows for the tracer
# to create a serial execution graph regardless of any concurrent execution: each
# concurrent execution path creates a new trace graph.
#
# @see https://ruby-doc.org/core-3.1.2/Thread.html#method-i-5B-5D Thread attributes are fiber-local
#
# source://ddtrace//lib/datadog/tracing/context_provider.rb#46
class Datadog::Tracing::FiberLocalContext
  # To support multiple tracers simultaneously, each {Datadog::Tracing::FiberLocalContext}
  # instance has its own fiber-local variable.
  #
  # @return [FiberLocalContext] a new instance of FiberLocalContext
  #
  # source://ddtrace//lib/datadog/tracing/context_provider.rb#49
  def initialize; end

  # Return the fiber-local context.
  #
  # source://ddtrace//lib/datadog/tracing/context_provider.rb#61
  def local(storage = T.unsafe(nil)); end

  # Override the fiber-local context with a new context.
  #
  # source://ddtrace//lib/datadog/tracing/context_provider.rb#56
  def local=(ctx); end

  class << self
    # source://ddtrace//lib/datadog/tracing/context_provider.rb#75
    def next_instance_id; end
  end
end

# source://ddtrace//lib/datadog/tracing/context_provider.rb#71
Datadog::Tracing::FiberLocalContext::UNIQUE_INSTANCE_GENERATOR = T.let(T.unsafe(nil), Datadog::Core::Utils::Sequence)

# Ensure two instances of {FiberLocalContext} do not conflict.
# We previously used {FiberLocalContext#object_id} to ensure uniqueness
# but the VM is allowed to reuse `object_id`, allow for the possibility that
# a new FiberLocalContext would be able to read an old FiberLocalContext's
# value.
#
# source://ddtrace//lib/datadog/tracing/context_provider.rb#70
Datadog::Tracing::FiberLocalContext::UNIQUE_INSTANCE_MUTEX = T.let(T.unsafe(nil), Thread::Mutex)

# source://ddtrace//lib/datadog/tracing/flush.rb#5
module Datadog::Tracing::Flush; end

# Consumes and returns a {TraceSegment} to be flushed, from
# the provided {TraceSegment}.
#
# Only finished spans are consumed. Any spans consumed are
# removed from +trace_op+ as a side effect. Unfinished spans are
# unaffected.
#
# @abstract
#
# source://ddtrace//lib/datadog/tracing/flush.rb#14
class Datadog::Tracing::Flush::Base
  # Consumes and returns a {TraceSegment} to be flushed, from
  # the provided {TraceSegment}.
  #
  # Only finished spans are consumed. Any spans consumed are
  # removed from +trace_op+ as a side effect. Unfinished spans are
  # unaffected.
  #
  # @param trace_op [TraceOperation]
  # @return [TraceSegment] trace to be flushed, or +nil+ if the trace is not finished
  #
  # source://ddtrace//lib/datadog/tracing/flush.rb#24
  def consume!(trace_op); end

  # Should we consume spans from the +trace_op+?
  #
  # @abstract
  # @raise [NotImplementedError]
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/flush.rb#32
  def flush?(trace_op); end

  protected

  # Consumes all finished spans from trace.
  #
  # @return [TraceSegment]
  #
  # source://ddtrace//lib/datadog/tracing/flush.rb#40
  def get_trace(trace_op); end

  # Single Span Sampling has chosen to keep this span
  # regardless of the trace-level sampling decision
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/flush.rb#50
  def single_sampled?(span); end
end

# Consumes and returns completed traces (where all spans have finished),
# if any, from the provided +trace_op+.
#
# Spans consumed are removed from +trace_op+ as a side effect.
#
# source://ddtrace//lib/datadog/tracing/flush.rb#59
class Datadog::Tracing::Flush::Finished < ::Datadog::Tracing::Flush::Base
  # Are all spans finished?
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/flush.rb#61
  def flush?(trace_op); end
end

# Consumes and returns completed or partially completed
# traces from the provided +trace_op+, if any.
#
# Partial trace flushing avoids large traces residing in memory for too long.
#
# Partially completed traces, where not all spans have finished,
# will only be returned if there are at least
# +@min_spans_for_partial+ finished spans.
#
# Spans consumed are removed from +trace_op+ as a side effect.
#
# source://ddtrace//lib/datadog/tracing/flush.rb#76
class Datadog::Tracing::Flush::Partial < ::Datadog::Tracing::Flush::Base
  # @return [Partial] a new instance of Partial
  #
  # source://ddtrace//lib/datadog/tracing/flush.rb#82
  def initialize(options = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/flush.rb#87
  def flush?(trace_op); end

  # Returns the value of attribute min_spans_for_partial.
  #
  # source://ddtrace//lib/datadog/tracing/flush.rb#80
  def min_spans_for_partial; end
end

# Start flushing partial trace after this many active spans in one trace
#
# source://ddtrace//lib/datadog/tracing/flush.rb#78
Datadog::Tracing::Flush::Partial::DEFAULT_MIN_SPANS_FOR_PARTIAL_FLUSH = T.let(T.unsafe(nil), Integer)

# Health metrics for trace buffers.
#
# source://ddtrace//lib/datadog/tracing/buffer.rb#9
module Datadog::Tracing::MeasuredBuffer
  # source://ddtrace//lib/datadog/tracing/buffer.rb#10
  def initialize(*_); end

  # source://ddtrace//lib/datadog/tracing/buffer.rb#19
  def add!(trace); end

  # source://ddtrace//lib/datadog/tracing/buffer.rb#26
  def add_all!(traces); end

  # Stored traces are returned and the local buffer is reset.
  #
  # source://ddtrace//lib/datadog/tracing/buffer.rb#44
  def drain!; end

  # source://ddtrace//lib/datadog/tracing/buffer.rb#50
  def measure_accept(trace); end

  # source://ddtrace//lib/datadog/tracing/buffer.rb#61
  def measure_drop(trace); end

  # source://ddtrace//lib/datadog/tracing/buffer.rb#71
  def measure_pop(traces); end

  # source://ddtrace//lib/datadog/tracing/buffer.rb#33
  def replace!(trace); end
end

# Adds common tagging behavior
#
# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#5
module Datadog::Tracing::Metadata
  include ::Datadog::Tracing::Metadata::Tagging
  include ::Datadog::Tracing::Metadata::Errors

  class << self
    # @private
    #
    # source://ddtrace//lib/datadog/tracing/metadata.rb#11
    def included(base); end
  end
end

# Defines analytics tagging behavior
#
# source://ddtrace//lib/datadog/tracing/metadata/analytics.rb#10
module Datadog::Tracing::Metadata::Analytics
  # source://ddtrace//lib/datadog/tracing/metadata/analytics.rb#11
  def set_tag(key, value); end
end

# Adds error tagging behavior
#
# source://ddtrace//lib/datadog/tracing/metadata/errors.rb#12
module Datadog::Tracing::Metadata::Errors
  # Mark the span with the given error.
  #
  # source://ddtrace//lib/datadog/tracing/metadata/errors.rb#14
  def set_error(e); end
end

# Trace and span tags that represent meta information
# regarding the trace. These fields are normally only used
# internally, and can have special meaning to downstream
# trace processing.
#
# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#11
module Datadog::Tracing::Metadata::Ext; end

# Defines constants for trace analytics
#
# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#32
module Datadog::Tracing::Metadata::Ext::Analytics; end

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#33
Datadog::Tracing::Metadata::Ext::Analytics::DEFAULT_SAMPLE_RATE = T.let(T.unsafe(nil), Float)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#34
Datadog::Tracing::Metadata::Ext::Analytics::TAG_ENABLED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#35
Datadog::Tracing::Metadata::Ext::Analytics::TAG_MEASURED = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#36
Datadog::Tracing::Metadata::Ext::Analytics::TAG_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#39
module Datadog::Tracing::Metadata::Ext::AppTypes; end

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#42
Datadog::Tracing::Metadata::Ext::AppTypes::TYPE_CACHE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#44
Datadog::Tracing::Metadata::Ext::AppTypes::TYPE_CUSTOM = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#41
Datadog::Tracing::Metadata::Ext::AppTypes::TYPE_DB = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#40
Datadog::Tracing::Metadata::Ext::AppTypes::TYPE_WEB = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#43
Datadog::Tracing::Metadata::Ext::AppTypes::TYPE_WORKER = T.let(T.unsafe(nil), String)

# Tags related to distributed tracing
#
# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#49
module Datadog::Tracing::Metadata::Ext::Distributed; end

# Trace tags with this prefix will propagate from a trace through distributed tracing.
# Distributed headers tags with this prefix will be injected into the active trace.
#
# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#59
Datadog::Tracing::Metadata::Ext::Distributed::TAGS_PREFIX = T.let(T.unsafe(nil), String)

# What mechanism was used to make this trace's sampling decision.
#
# @see Datadog::Tracing::Sampling::Ext::Mechanism
#
# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#52
Datadog::Tracing::Metadata::Ext::Distributed::TAG_DECISION_MAKER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#54
Datadog::Tracing::Metadata::Ext::Distributed::TAG_ORIGIN = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#55
Datadog::Tracing::Metadata::Ext::Distributed::TAG_SAMPLING_PRIORITY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#64
Datadog::Tracing::Metadata::Ext::Distributed::TAG_TID = T.let(T.unsafe(nil), String)

# The distributed tag to carry hex encoded high order 64 bits of 127 bits trace id during
# the context restricted with 64 bits. Such as, Datadog propagation and messagepack encoding
#
# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#63
Datadog::Tracing::Metadata::Ext::Distributed::TID = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#68
module Datadog::Tracing::Metadata::Ext::Errors; end

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#69
Datadog::Tracing::Metadata::Ext::Errors::STATUS = T.let(T.unsafe(nil), Integer)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#70
Datadog::Tracing::Metadata::Ext::Errors::TAG_MSG = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#71
Datadog::Tracing::Metadata::Ext::Errors::TAG_STACK = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#72
Datadog::Tracing::Metadata::Ext::Errors::TAG_TYPE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#76
module Datadog::Tracing::Metadata::Ext::HTTP; end

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#77
Datadog::Tracing::Metadata::Ext::HTTP::ERROR_RANGE = T.let(T.unsafe(nil), Range)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#88
Datadog::Tracing::Metadata::Ext::HTTP::HEADER_USER_AGENT = T.let(T.unsafe(nil), String)

# General header functionality
#
# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#91
module Datadog::Tracing::Metadata::Ext::HTTP::Headers
  private

  # Normalizes an HTTP header string into a valid tag string.
  #
  # By default, tags cannot create nested span tag levels:
  # `allow_nested` allows you to override this behavior.
  #
  # source://ddtrace//lib/datadog/tracing/metadata/ext.rb#100
  def to_tag(name, allow_nested: T.unsafe(nil)); end

  class << self
    # Normalizes an HTTP header string into a valid tag string.
    #
    # By default, tags cannot create nested span tag levels:
    # `allow_nested` allows you to override this behavior.
    #
    # source://ddtrace//lib/datadog/tracing/metadata/ext.rb#100
    def to_tag(name, allow_nested: T.unsafe(nil)); end
  end
end

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#94
Datadog::Tracing::Metadata::Ext::HTTP::Headers::INVALID_TAG_CHARACTERS = T.let(T.unsafe(nil), Regexp)

# Request headers
#
# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#125
module Datadog::Tracing::Metadata::Ext::HTTP::RequestHeaders
  private

  # source://ddtrace//lib/datadog/tracing/metadata/ext.rb#130
  def to_tag(name); end

  class << self
    # source://ddtrace//lib/datadog/tracing/metadata/ext.rb#130
    def to_tag(name); end
  end
end

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#126
Datadog::Tracing::Metadata::Ext::HTTP::RequestHeaders::PREFIX = T.let(T.unsafe(nil), String)

# Response headers
#
# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#136
module Datadog::Tracing::Metadata::Ext::HTTP::ResponseHeaders
  private

  # source://ddtrace//lib/datadog/tracing/metadata/ext.rb#141
  def to_tag(name); end

  class << self
    # source://ddtrace//lib/datadog/tracing/metadata/ext.rb#141
    def to_tag(name); end
  end
end

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#137
Datadog::Tracing::Metadata::Ext::HTTP::ResponseHeaders::PREFIX = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#78
Datadog::Tracing::Metadata::Ext::HTTP::TAG_BASE_URL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#87
Datadog::Tracing::Metadata::Ext::HTTP::TAG_CLIENT_IP = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#79
Datadog::Tracing::Metadata::Ext::HTTP::TAG_METHOD = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#80
Datadog::Tracing::Metadata::Ext::HTTP::TAG_STATUS_CODE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#82
Datadog::Tracing::Metadata::Ext::HTTP::TAG_URL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#81
Datadog::Tracing::Metadata::Ext::HTTP::TAG_USER_AGENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#83
Datadog::Tracing::Metadata::Ext::HTTP::TYPE_INBOUND = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#84
Datadog::Tracing::Metadata::Ext::HTTP::TYPE_OUTBOUND = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#85
Datadog::Tracing::Metadata::Ext::HTTP::TYPE_PROXY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#86
Datadog::Tracing::Metadata::Ext::HTTP::TYPE_TEMPLATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#148
module Datadog::Tracing::Metadata::Ext::NET; end

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#152
Datadog::Tracing::Metadata::Ext::NET::TAG_DESTINATION_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#153
Datadog::Tracing::Metadata::Ext::NET::TAG_DESTINATION_PORT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#149
Datadog::Tracing::Metadata::Ext::NET::TAG_HOSTNAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#150
Datadog::Tracing::Metadata::Ext::NET::TAG_TARGET_HOST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#151
Datadog::Tracing::Metadata::Ext::NET::TAG_TARGET_PORT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#172
module Datadog::Tracing::Metadata::Ext::SQL; end

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#174
Datadog::Tracing::Metadata::Ext::SQL::TAG_QUERY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#173
Datadog::Tracing::Metadata::Ext::SQL::TYPE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#157
module Datadog::Tracing::Metadata::Ext::Sampling; end

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#158
Datadog::Tracing::Metadata::Ext::Sampling::TAG_AGENT_RATE = T.let(T.unsafe(nil), String)

# If rate limiting is checked on a span, set this metric the effective rate limiting rate applied.
# This should be done regardless of rate limiting outcome.
#
# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#166
Datadog::Tracing::Metadata::Ext::Sampling::TAG_RATE_LIMITER_RATE = T.let(T.unsafe(nil), String)

# If rule sampling is applied to a span, set this metric the sample rate configured for that rule.
# This should be done regardless of sampling outcome.
#
# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#162
Datadog::Tracing::Metadata::Ext::Sampling::TAG_RULE_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#168
Datadog::Tracing::Metadata::Ext::Sampling::TAG_SAMPLE_RATE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#178
module Datadog::Tracing::Metadata::Ext::SpanKind; end

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#181
Datadog::Tracing::Metadata::Ext::SpanKind::TAG_CLIENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#183
Datadog::Tracing::Metadata::Ext::SpanKind::TAG_CONSUMER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#184
Datadog::Tracing::Metadata::Ext::SpanKind::TAG_INTERNAL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#182
Datadog::Tracing::Metadata::Ext::SpanKind::TAG_PRODUCER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#179
Datadog::Tracing::Metadata::Ext::SpanKind::TAG_PROXY = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#180
Datadog::Tracing::Metadata::Ext::SpanKind::TAG_SERVER = T.let(T.unsafe(nil), String)

# Name of package that was instrumented
#
# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#13
Datadog::Tracing::Metadata::Ext::TAG_COMPONENT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#21
Datadog::Tracing::Metadata::Ext::TAG_KIND = T.let(T.unsafe(nil), String)

# Type of operation being performed (e.g. )
#
# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#15
Datadog::Tracing::Metadata::Ext::TAG_OPERATION = T.let(T.unsafe(nil), String)

# Hostname of external service interacted with
#
# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#17
Datadog::Tracing::Metadata::Ext::TAG_PEER_HOSTNAME = T.let(T.unsafe(nil), String)

# Name of external service that performed the work
#
# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#19
Datadog::Tracing::Metadata::Ext::TAG_PEER_SERVICE = T.let(T.unsafe(nil), String)

# Set to `1.0` if profiling is enabled together with tracing, and `0.0` otherwise
# See Datadog-internal "RFC: Identifying which spans have profiling enabled " for details
#
# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#28
Datadog::Tracing::Metadata::Ext::TAG_PROFILING_ENABLED = T.let(T.unsafe(nil), String)

# Set this tag to `1.0` if the span is a Service Entry span.
#
# source://ddtrace//lib/datadog/tracing/metadata/ext.rb#24
Datadog::Tracing::Metadata::Ext::TAG_TOP_LEVEL = T.let(T.unsafe(nil), String)

# Adds metadata & metric tag behavior
#
# source://ddtrace//lib/datadog/tracing/metadata/tagging.rb#10
module Datadog::Tracing::Metadata::Tagging
  # Return the tag with the given key, nil if it doesn't exist.
  # Convenient interface for getting a single tag.
  #
  # source://ddtrace//lib/datadog/tracing/metadata/tagging.rb#26
  def [](key); end

  # Set the given key / value tag pair on the span. Keys and values
  # must be strings. A valid example is:
  #
  #   span.set_tag('http.method', request.method)
  # Convenient interface for setting a single tag.
  #
  # source://ddtrace//lib/datadog/tracing/metadata/tagging.rb#34
  def []=(key, value = T.unsafe(nil)); end

  # This method removes a metric for the given key. It acts like {#clear_tag}.
  #
  # source://ddtrace//lib/datadog/tracing/metadata/tagging.rb#107
  def clear_metric(key); end

  # This method removes a tag for the given key.
  #
  # source://ddtrace//lib/datadog/tracing/metadata/tagging.rb#76
  def clear_tag(key); end

  # Return the metric with the given key, nil if it doesn't exist.
  #
  # source://ddtrace//lib/datadog/tracing/metadata/tagging.rb#87
  def get_metric(key); end

  # Return the tag with the given key, nil if it doesn't exist.
  #
  # source://ddtrace//lib/datadog/tracing/metadata/tagging.rb#26
  def get_tag(key); end

  # Returns true if the provided `tag` was set to a non-nil value.
  # False otherwise.
  #
  # @param tag [String] the tag or metric to check for presence
  # @return [Boolean] if the tag is present and not nil
  #
  # source://ddtrace//lib/datadog/tracing/metadata/tagging.rb#71
  def has_tag?(tag); end

  # This method sets a tag with a floating point value for the given key. It acts
  # like `set_tag()` and it simply add a tag without further processing.
  #
  # source://ddtrace//lib/datadog/tracing/metadata/tagging.rb#93
  def set_metric(key, value); end

  # Set the given key / value tag pair on the span. Keys and values
  # must be strings. A valid example is:
  #
  #   span.set_tag('http.method', request.method)
  #
  # source://ddtrace//lib/datadog/tracing/metadata/tagging.rb#34
  def set_tag(key, value = T.unsafe(nil)); end

  # Sets tags from given hash, for each key in hash it sets the tag with that key
  # and associated value from the hash. It is shortcut for `set_tag`. Keys and values
  # of the hash must be strings. Note that nested hashes are not supported.
  # A valid example is:
  #
  #   span.set_tags({ "http.method" => "GET", "user.id" => "234" })
  #
  # source://ddtrace//lib/datadog/tracing/metadata/tagging.rb#62
  def set_tags(tags); end

  # Returns a copy of all metadata.
  # Keys for `@meta` and `@metrics` don't collide, by construction.
  #
  # source://ddtrace//lib/datadog/tracing/metadata/tagging.rb#113
  def tags; end

  protected

  # source://ddtrace//lib/datadog/tracing/metadata/tagging.rb#119
  def meta; end

  # source://ddtrace//lib/datadog/tracing/metadata/tagging.rb#123
  def metrics; end
end

# Some associated values should always be sent as Tags, never as Metrics, regardless
# if their value is numeric or not.
# The Datadog agent will look for these values only as Tags, not Metrics.
#
# @see https://github.com/DataDog/datadog-agent/blob/2ae2cdd315bcda53166dd8fa0dedcfc448087b9d/pkg/trace/stats/aggregation.go#L13-L17
#
# source://ddtrace//lib/datadog/tracing/metadata/tagging.rb#18
Datadog::Tracing::Metadata::Tagging::ENSURE_AGENT_TAGS = T.let(T.unsafe(nil), Hash)

# This limit is for numeric tags because uint64 could end up rounded.
#
# source://ddtrace//lib/datadog/tracing/metadata/tagging.rb#12
Datadog::Tracing::Metadata::Tagging::NUMERIC_TAG_SIZE_RANGE = T.let(T.unsafe(nil), Range)

# Modifies traces through a set of filters and processors
#
# source://ddtrace//lib/datadog/tracing/pipeline/span_processor.rb#5
module Datadog::Tracing::Pipeline
  class << self
    # @overload before_flush
    # @overload before_flush
    # @see file:docs/GettingStarted.md#configuring-the-transport-layer Configuring the transport layer
    #
    # source://ddtrace//lib/datadog/tracing/pipeline.rb#23
    def before_flush(*processors, &processor_block); end

    # source://ddtrace//lib/datadog/tracing/pipeline.rb#31
    def process!(traces); end

    # source://ddtrace//lib/datadog/tracing/pipeline.rb#39
    def processors=(value); end

    private

    # source://ddtrace//lib/datadog/tracing/pipeline.rb#43
    def apply_processors!(trace); end
  end
end

# SpanFilter implements a processor that filters entire span subtrees
# This processor executes the configured `operation` for each {Datadog::Tracing::Span}
# in a {Datadog::Tracing::TraceSegment}.
#
# If `operation` returns a truthy value for a span, that span is kept,
# otherwise the span is removed from the trace.
#
# source://ddtrace//lib/datadog/tracing/pipeline/span_filter.rb#17
class Datadog::Tracing::Pipeline::SpanFilter < ::Datadog::Tracing::Pipeline::SpanProcessor
  # NOTE: This SpanFilter implementation only handles traces in which child spans appear
  # before parent spans in the trace array. If in the future child spans can be after
  # parent spans, then the code below will need to be updated.
  #
  # source://ddtrace//lib/datadog/tracing/pipeline/span_filter.rb#22
  def call(trace); end

  private

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/pipeline/span_filter.rb#40
  def drop_it?(span); end
end

# This processor executes the configured `operation` for each {Datadog::Tracing::Span}
# in a {Datadog::Tracing::TraceSegment}.
#
# source://ddtrace//lib/datadog/tracing/pipeline/span_processor.rb#10
class Datadog::Tracing::Pipeline::SpanProcessor
  # You can either provide an `operation` object or a block to this method.
  #
  # Both have the same semantics as `operation`.
  # `operation` is used if both `operation` and a block are present.
  #
  # @param operation [#call(Datadog::Tracing::Span)] a callable that can modify the span.
  # @raise [ArgumentError]
  # @return [SpanProcessor] a new instance of SpanProcessor
  #
  # source://ddtrace//lib/datadog/tracing/pipeline/span_processor.rb#17
  def initialize(operation = T.unsafe(nil), &block); end

  # Invokes `operation#call` for each spans in the `trace` argument.
  #
  # @param trace [Datadog::Tracing::TraceSegment] a trace segment.
  # @return [Datadog::Tracing::TraceSegment] the `trace` provided as an argument.
  #
  # source://ddtrace//lib/datadog/tracing/pipeline/span_processor.rb#29
  def call(trace); end
end

# source://ddtrace//lib/datadog/tracing/propagation/http.rb#7
module Datadog::Tracing::Propagation; end

# Propagation::HTTP helps extracting and injecting HTTP headers.
# DEV-2.0: This file has been moved to Contrib. Should be deleted in the next release.
#
# source://ddtrace//lib/datadog/tracing/propagation/http.rb#11
Datadog::Tracing::Propagation::HTTP = T.let(T.unsafe(nil), Datadog::Tracing::Contrib::HTTP::Distributed::Propagation)

# Remote configuration declaration
#
# source://ddtrace//lib/datadog/tracing/remote.rb#9
module Datadog::Tracing::Remote
  class << self
    # source://ddtrace//lib/datadog/tracing/remote.rb#19
    def capabilities; end

    # source://ddtrace//lib/datadog/tracing/remote.rb#23
    def process_config(config, content); end

    # source://ddtrace//lib/datadog/tracing/remote.rb#15
    def products; end

    # source://ddtrace//lib/datadog/tracing/remote.rb#59
    def receiver(products = T.unsafe(nil), &block); end

    # source://ddtrace//lib/datadog/tracing/remote.rb#44
    def receivers; end

    private

    # @raise [ReadError]
    #
    # source://ddtrace//lib/datadog/tracing/remote.rb#66
    def parse_content(content); end
  end
end

# source://ddtrace//lib/datadog/tracing/remote.rb#10
class Datadog::Tracing::Remote::ReadError < ::StandardError; end

# source://ddtrace//lib/datadog/tracing/runtime/metrics.rb#5
module Datadog::Tracing::Runtime; end

# Decorates runtime metrics feature
#
# source://ddtrace//lib/datadog/tracing/runtime/metrics.rb#7
module Datadog::Tracing::Runtime::Metrics
  class << self
    # source://ddtrace//lib/datadog/tracing/runtime/metrics.rb#8
    def associate_trace(trace); end
  end
end

# source://ddtrace//lib/datadog/tracing/sampling/sampler.rb#3
module Datadog::Tracing::Sampling; end

# {Datadog::Tracing::Sampling::AllSampler} samples all the traces.
#
# source://ddtrace//lib/datadog/tracing/sampling/all_sampler.rb#10
class Datadog::Tracing::Sampling::AllSampler < ::Datadog::Tracing::Sampling::Sampler
  # source://ddtrace//lib/datadog/tracing/sampling/all_sampler.rb#15
  def sample!(trace); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/sampling/all_sampler.rb#11
  def sample?(_trace); end

  # source://ddtrace//lib/datadog/tracing/sampling/all_sampler.rb#19
  def sample_rate(*_); end
end

# source://ddtrace//lib/datadog/tracing/sampling/ext.rb#6
module Datadog::Tracing::Sampling::Ext; end

# List of how the decision was made for the trace-level sampling.
#
# These values used to populate the {Datadog::Tracing::Metadata::Ext::Distributed::TAG_DECISION_MAKER} tag.
#
# The decision has two parts, separated by a `-`:
# `part1-sampling_mechanism`. `part1` is currently not populated, thus
# this tag is currently formatted as `"-sampling_mechanism"`.
#
# source://ddtrace//lib/datadog/tracing/sampling/ext.rb#38
module Datadog::Tracing::Sampling::Ext::Decision; end

# The sampling rate received in the agent's http response.
#
# source://ddtrace//lib/datadog/tracing/sampling/ext.rb#42
Datadog::Tracing::Sampling::Ext::Decision::AGENT_RATE = T.let(T.unsafe(nil), String)

# Formerly AppSec.
#
# source://ddtrace//lib/datadog/tracing/sampling/ext.rb#49
Datadog::Tracing::Sampling::Ext::Decision::ASM = T.let(T.unsafe(nil), String)

# Used before the tracer receives any rates from agent and there are no rules configured.
#
# source://ddtrace//lib/datadog/tracing/sampling/ext.rb#40
Datadog::Tracing::Sampling::Ext::Decision::DEFAULT = T.let(T.unsafe(nil), String)

# User directly sets sampling priority via {Tracing.reject!} or {Tracing.keep!},
# or by a custom sampler implementation.
#
# source://ddtrace//lib/datadog/tracing/sampling/ext.rb#47
Datadog::Tracing::Sampling::Ext::Decision::MANUAL = T.let(T.unsafe(nil), String)

# Single Span Sampled.
#
# source://ddtrace//lib/datadog/tracing/sampling/ext.rb#51
Datadog::Tracing::Sampling::Ext::Decision::SPAN_SAMPLING_RATE = T.let(T.unsafe(nil), String)

# Sampling rule or sampling rate based on tracer config.
#
# source://ddtrace//lib/datadog/tracing/sampling/ext.rb#44
Datadog::Tracing::Sampling::Ext::Decision::TRACE_SAMPLING_RULE = T.let(T.unsafe(nil), String)

# List of what mechanism was used to make the trace-level sampling decision.
#
# source://ddtrace//lib/datadog/tracing/sampling/ext.rb#26
module Datadog::Tracing::Sampling::Ext::Mechanism; end

# Single Span Sampled.
#
# source://ddtrace//lib/datadog/tracing/sampling/ext.rb#28
Datadog::Tracing::Sampling::Ext::Mechanism::SPAN_SAMPLING_RATE = T.let(T.unsafe(nil), Integer)

# Priority is a hint given to the backend so that it knows which traces to reject or kept.
# In a distributed context, it should be set before any context propagation (fork, RPC calls) to be effective.
#
# source://ddtrace//lib/datadog/tracing/sampling/ext.rb#10
module Datadog::Tracing::Sampling::Ext::Priority; end

# Used by the {PrioritySampler} to inform the backend that a trace should be kept and stored.
#
# source://ddtrace//lib/datadog/tracing/sampling/ext.rb#18
Datadog::Tracing::Sampling::Ext::Priority::AUTO_KEEP = T.let(T.unsafe(nil), Integer)

# Used by the {PrioritySampler} to inform the backend that a trace should be rejected and not stored.
#
# source://ddtrace//lib/datadog/tracing/sampling/ext.rb#16
Datadog::Tracing::Sampling::Ext::Priority::AUTO_REJECT = T.let(T.unsafe(nil), Integer)

# Use this to explicitly inform the backend that a trace MUST be kept and stored.
# This includes rules and rate limits configured by the user
# through the {Datadog::Tracing::Sampling::RuleSampler}.
#
# source://ddtrace//lib/datadog/tracing/sampling/ext.rb#22
Datadog::Tracing::Sampling::Ext::Priority::USER_KEEP = T.let(T.unsafe(nil), Integer)

# Use this to explicitly inform the backend that a trace MUST be rejected and not stored.
# This includes rules and rate limits configured by the user
# through the {Datadog::Tracing::Sampling::RuleSampler}.
#
# source://ddtrace//lib/datadog/tracing/sampling/ext.rb#14
Datadog::Tracing::Sampling::Ext::Priority::USER_REJECT = T.let(T.unsafe(nil), Integer)

# Checks if a trace conforms to a matching criteria.
#
# @abstract
#
# source://ddtrace//lib/datadog/tracing/sampling/matcher.rb#9
class Datadog::Tracing::Sampling::Matcher
  # Returns `true` if the trace should conforms to this rule, `false` otherwise
  #
  # @param trace [TraceOperation]
  # @raise [NotImplementedError]
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/sampling/matcher.rb#14
  def match?(trace); end
end

# {Datadog::Tracing::Sampling::PrioritySampler}
#
# source://ddtrace//lib/datadog/tracing/sampling/priority_sampler.rb#13
class Datadog::Tracing::Sampling::PrioritySampler
  # @return [PrioritySampler] a new instance of PrioritySampler
  #
  # source://ddtrace//lib/datadog/tracing/sampling/priority_sampler.rb#22
  def initialize(opts = T.unsafe(nil)); end

  # NOTE: We do not advise using a pre-sampler. It can save resources,
  # but pre-sampling at rates < 100% may result in partial traces, unless
  # the pre-sampler knows exactly how to drop a span without dropping its ancestors.
  #
  # Additionally, as service metrics are calculated in the Datadog Agent,
  # the service's throughput will be underestimated.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/priority_sampler.rb#20
  def pre_sampler; end

  # NOTE: We do not advise using a pre-sampler. It can save resources,
  # but pre-sampling at rates < 100% may result in partial traces, unless
  # the pre-sampler knows exactly how to drop a span without dropping its ancestors.
  #
  # Additionally, as service metrics are calculated in the Datadog Agent,
  # the service's throughput will be underestimated.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/priority_sampler.rb#20
  def priority_sampler; end

  # DEV-2.0:We should get rid of this complicated interaction between @pre_sampler and @priority_sampler.
  # DEV-2.0:If the user wants to configure a custom sampler, we should only allow them to provide a complete
  # DEV-2.0:sampling suite, not having this convoluted support for mixing arbitrary provided samplers in
  # DEV-2.0:the PrioritySampler. Ideally, the PrioritySampler is only used by Datadog.
  # DEV-2.0:There are too many edge cases and combinations to work around currently in this class.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/priority_sampler.rb#36
  def sample!(trace); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/sampling/priority_sampler.rb#27
  def sample?(trace); end

  # source://ddtrace//lib/datadog/tracing/sampling/priority_sampler.rb#84
  def update(rate_by_service, decision: T.unsafe(nil)); end

  private

  # source://ddtrace//lib/datadog/tracing/sampling/priority_sampler.rb#159
  def assign_priority!(trace, priority); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/sampling/priority_sampler.rb#101
  def pre_sample?(trace); end

  # Ensures the trace's priority sampling decision is not changed by the @pre_sampler.
  # The @pre_sampler should only change `trace.sampled`.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/priority_sampler.rb#124
  def preserving_priority_sampling(trace); end

  # Ensures the trace is always propagated to the writer and that
  # the sample rate metric represents the true client-side sampling.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/priority_sampler.rb#141
  def preserving_sampling(trace); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/sampling/priority_sampler.rb#112
  def priority_assigned?(trace); end

  # source://ddtrace//lib/datadog/tracing/sampling/priority_sampler.rb#116
  def priority_sample!(trace); end

  class << self
    # Check if the Priority Sampling decision is to keep or drop the trace.
    # Other factors can influence the sampling decision; this method is only
    # responsible for interpreting the Sampling Priority decision.
    #
    # @param priority_sampling [Integer] priority sampling number
    # @return [Boolean] true if trace is "kept" by priority sampling
    # @return [Boolean] false if trace is "dropped" by priority sampling
    #
    # source://ddtrace//lib/datadog/tracing/sampling/priority_sampler.rb#95
    def sampled?(priority_sampling); end
  end
end

# A {Datadog::Tracing::Sampling::Matcher} that allows for arbitrary trace matching
# based on the return value of a provided block.
#
# source://ddtrace//lib/datadog/tracing/sampling/matcher.rb#52
class Datadog::Tracing::Sampling::ProcMatcher < ::Datadog::Tracing::Sampling::Matcher
  # @return [ProcMatcher] a new instance of ProcMatcher
  # @yield [name, service] Provides trace name and service to the block
  # @yieldreturn [Boolean] Whether the trace conforms to this matcher
  #
  # source://ddtrace//lib/datadog/tracing/sampling/matcher.rb#57
  def initialize(&block); end

  # Returns the value of attribute block.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/matcher.rb#53
  def block; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/sampling/matcher.rb#62
  def match?(trace); end
end

# Samples at different rates by key.
#
# source://ddtrace//lib/datadog/tracing/sampling/rate_by_key_sampler.rb#9
class Datadog::Tracing::Sampling::RateByKeySampler < ::Datadog::Tracing::Sampling::Sampler
  # @raise [ArgumentError]
  # @return [RateByKeySampler] a new instance of RateByKeySampler
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rate_by_key_sampler.rb#13
  def initialize(default_key, default_rate = T.unsafe(nil), decision: T.unsafe(nil), &block); end

  # Returns the value of attribute default_key.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rate_by_key_sampler.rb#10
  def default_key; end

  # source://ddtrace//lib/datadog/tracing/sampling/rate_by_key_sampler.rb#30
  def default_sampler; end

  # source://ddtrace//lib/datadog/tracing/sampling/rate_by_key_sampler.rb#70
  def delete(key); end

  # source://ddtrace//lib/datadog/tracing/sampling/rate_by_key_sampler.rb#76
  def delete_if(&block); end

  # source://ddtrace//lib/datadog/tracing/sampling/rate_by_key_sampler.rb#82
  def length; end

  # source://ddtrace//lib/datadog/tracing/sampling/rate_by_key_sampler.rb#26
  def resolve(trace); end

  # source://ddtrace//lib/datadog/tracing/sampling/rate_by_key_sampler.rb#42
  def sample!(trace); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rate_by_key_sampler.rb#34
  def sample?(trace); end

  # source://ddtrace//lib/datadog/tracing/sampling/rate_by_key_sampler.rb#50
  def sample_rate(trace); end

  # source://ddtrace//lib/datadog/tracing/sampling/rate_by_key_sampler.rb#58
  def update(key, rate, decision: T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/sampling/rate_by_key_sampler.rb#64
  def update_all(rate_by_key, decision: T.unsafe(nil)); end

  private

  # source://ddtrace//lib/datadog/tracing/sampling/rate_by_key_sampler.rb#88
  def set_rate(key, rate, decision); end
end

# {Datadog::Tracing::Sampling::RateByServiceSampler} samples different services at different rates
#
# source://ddtrace//lib/datadog/tracing/sampling/rate_by_service_sampler.rb#8
class Datadog::Tracing::Sampling::RateByServiceSampler < ::Datadog::Tracing::Sampling::RateByKeySampler
  # @return [RateByServiceSampler] a new instance of RateByServiceSampler
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rate_by_service_sampler.rb#11
  def initialize(default_rate = T.unsafe(nil), env: T.unsafe(nil), decision: T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/sampling/rate_by_service_sampler.rb#22
  def update(rate_by_service, decision: T.unsafe(nil)); end

  private

  # DEV: Creating a string on every trace to perform a single Hash lookup is expensive.
  #
  # Using 2 nested hashes: 1 for env and 1 for service is the fastest option.
  # This approach requires large API changes to `RateByKeySampler`.
  #
  # Reducing the interpolated string size, by using a 1 character separator,
  # is also measurably faster than the current method. This approach does not
  # require changes to `RateByKeySampler`.
  #
  # Keep in mind that these changes also require changes to `#update`.
  #
  # Comparison:
  #  2 nested hashes: `service_hash.fetch(service, {}).fetch(env, default_rate)`
  #                   7730045 i/s
  # 1 char separator: `hash.fetch("#{service}\0#{env}", default_rate)`
  #                   4302801 i/s - 1.80x slower
  #          current: `hash.fetch("service:#{service},env:#{env}", default_rate)`
  #                   2720459 i/s - 2.84x slower
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rate_by_service_sampler.rb#53
  def key_for(trace); end
end

# source://ddtrace//lib/datadog/tracing/sampling/rate_by_service_sampler.rb#9
Datadog::Tracing::Sampling::RateByServiceSampler::DEFAULT_KEY = T.let(T.unsafe(nil), String)

# Checks for rate limiting on a resource.
#
# source://ddtrace//lib/datadog/tracing/sampling/rate_limiter.rb#8
class Datadog::Tracing::Sampling::RateLimiter
  # Checks if resource of specified size can be
  # conforms with the current limit.
  #
  # Implementations of this method are not guaranteed
  # to be side-effect free.
  #
  # @return [Boolean] whether a resource conforms with the current limit
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rate_limiter.rb#16
  def allow?(size); end

  # The effective rate limiting ratio based on
  # recent calls to `allow?`.
  #
  # @return [Float] recent allowance ratio
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rate_limiter.rb#22
  def effective_rate; end
end

# {Datadog::Tracing::Sampling::RateSampler} is based on a sample rate.
#
# source://ddtrace//lib/datadog/tracing/sampling/rate_sampler.rb#9
class Datadog::Tracing::Sampling::RateSampler < ::Datadog::Tracing::Sampling::Sampler
  # Initialize a {Datadog::Tracing::Sampling::RateSampler}.
  # This sampler keeps a random subset of the traces. Its main purpose is to
  # reduce the instrumentation footprint.
  #
  # * +sample_rate+: the sample rate as a {Float} between 0.0 and 1.0. 0.0
  #   means that no trace will be sampled; 1.0 means that all traces will be
  #   sampled.
  #
  # DEV-2.0: Allow for `sample_rate` zero (drop all) to be allowed. This eases
  # DEV-2.0: usage for all internal users of the {RateSampler} class: both
  # DEV-2.0: RuleSampler and Single Span Sampling leverage the RateSampler, but want
  # DEV-2.0: `sample_rate` zero to mean "drop all". They work around this by hard-
  # DEV-2.0: setting the `sample_rate` to zero like so:
  # DEV-2.0: ```
  # DEV-2.0: sampler = RateSampler.new
  # DEV-2.0: sampler.sample_rate = sample_rate
  # DEV-2.0: ```
  #
  # @return [RateSampler] a new instance of RateSampler
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rate_sampler.rb#29
  def initialize(sample_rate = T.unsafe(nil), decision: T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/sampling/rate_sampler.rb#55
  def sample!(trace); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rate_sampler.rb#51
  def sample?(trace); end

  # source://ddtrace//lib/datadog/tracing/sampling/rate_sampler.rb#42
  def sample_rate(*_); end

  # source://ddtrace//lib/datadog/tracing/sampling/rate_sampler.rb#46
  def sample_rate=(sample_rate); end
end

# source://ddtrace//lib/datadog/tracing/sampling/rate_sampler.rb#10
Datadog::Tracing::Sampling::RateSampler::KNUTH_FACTOR = T.let(T.unsafe(nil), Integer)

# Sampling rule that dictates if a trace matches
# a specific criteria and what sampling strategy to
# apply in case of a positive match.
#
# source://ddtrace//lib/datadog/tracing/sampling/rule.rb#11
class Datadog::Tracing::Sampling::Rule
  # @param matcher [Matcher] A matcher to verify trace conformity against
  # @param sampler [Sampler] A sampler to be consulted on a positive match
  # @return [Rule] a new instance of Rule
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rule.rb#16
  def initialize(matcher, sampler); end

  # Evaluates if the provided `trace` conforms to the `matcher`.
  #
  # @param trace [TraceOperation]
  # @return [Boolean] whether this rules applies to the trace
  # @return [NilClass] if the matcher fails errs during evaluation
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rule.rb#26
  def match?(trace); end

  # Returns the value of attribute matcher.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rule.rb#12
  def matcher; end

  # Returns `true` if the provided trace should be kept.
  # Otherwise, `false`.
  #
  # This method *must not* modify the `trace`.
  #
  # @param trace [Datadog::Tracing::TraceOperation]
  # @return [Boolean] should this trace be kept?
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rule.rb#36
  def sample?(trace); end

  # The sampling rate, if this sampler has such concept.
  # Otherwise, `nil`.
  #
  # @param trace [Datadog::Tracing::TraceOperation]
  # @return [Float, nil] sampling ratio between 0.0 and 1.0 (inclusive), or `nil` if not applicable
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rule.rb#41
  def sample_rate(trace); end

  # Returns the value of attribute sampler.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rule.rb#12
  def sampler; end
end

# Span {Sampler} that applies a set of {Rule}s to decide
# on sampling outcome. Then, a rate limiter is applied.
#
# If a trace does not conform to any rules, a default
# sampling strategy is applied.
#
# source://ddtrace//lib/datadog/tracing/sampling/rule_sampler.rb#14
class Datadog::Tracing::Sampling::RuleSampler
  # @param rules [Array<Rule>] ordered list of rules to be applied to a trace
  # @param rate_limit [Float] number of traces per second, defaults to +100+
  # @param rate_limiter [RateLimiter] limiter applied after rule matching
  # @param default_sample_rate [Float] fallback sample rate when no rules apply to a trace,
  #   between +[0,1]+, defaults to +1+
  # @param default_sampler [Sample] fallback strategy when no rules apply to a trace
  # @return [RuleSampler] a new instance of RuleSampler
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rule_sampler.rb#23
  def initialize(rules = T.unsafe(nil), rate_limit: T.unsafe(nil), rate_limiter: T.unsafe(nil), default_sample_rate: T.unsafe(nil), default_sampler: T.unsafe(nil)); end

  # Returns the value of attribute default_sampler.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rule_sampler.rb#15
  def default_sampler; end

  # Returns the value of attribute rate_limiter.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rule_sampler.rb#15
  def rate_limiter; end

  # Returns the value of attribute rules.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rule_sampler.rb#15
  def rules; end

  # source://ddtrace//lib/datadog/tracing/sampling/rule_sampler.rb#90
  def sample!(trace); end

  # /RuleSampler's components (it's rate limiter, for example) are
  # not be guaranteed to be size-effect free.
  # It is not possible to guarantee that a call to {#sample?} will
  # return the same result as a successive call to {#sample!} with the same trace.
  #
  # Use {#sample!} instead
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rule_sampler.rb#86
  def sample?(_trace); end

  # source://ddtrace//lib/datadog/tracing/sampling/rule_sampler.rb#104
  def update(*args, **kwargs); end

  private

  # source://ddtrace//lib/datadog/tracing/sampling/rule_sampler.rb#112
  def sample_trace(trace); end

  # source://ddtrace//lib/datadog/tracing/sampling/rule_sampler.rb#151
  def set_limiter_metrics(trace, limiter_rate); end

  # Span priority should only be set when the {RuleSampler}
  # was responsible for the sampling decision.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rule_sampler.rb#139
  def set_priority(trace, sampled); end

  # source://ddtrace//lib/datadog/tracing/sampling/rule_sampler.rb#147
  def set_rule_metrics(trace, sample_rate); end

  class << self
    # source://ddtrace//lib/datadog/tracing/sampling/rule_sampler.rb#51
    def parse(rules, rate_limit, default_sample_rate); end
  end
end

# Interface for client-side trace sampling.
#
# @abstract
#
# source://ddtrace//lib/datadog/tracing/sampling/sampler.rb#7
class Datadog::Tracing::Sampling::Sampler
  # Returns `true` if the provided trace should be kept.
  # Otherwise, `false`.
  #
  # This method *may* modify the `trace`, in case changes are necessary based on the
  # sampling decision.
  #
  # @param trace [Datadog::Tracing::TraceOperation]
  # @raise [NotImplementedError]
  # @return [Boolean] should this trace be kept?
  #
  # source://ddtrace//lib/datadog/tracing/sampling/sampler.rb#27
  def sample!(trace); end

  # Returns `true` if the provided trace should be kept.
  # Otherwise, `false`.
  #
  # This method *must not* modify the `trace`.
  #
  # @param trace [Datadog::Tracing::TraceOperation]
  # @raise [NotImplementedError]
  # @return [Boolean] should this trace be kept?
  #
  # source://ddtrace//lib/datadog/tracing/sampling/sampler.rb#15
  def sample?(trace); end

  # The sampling rate, if this sampler has such concept.
  # Otherwise, `nil`.
  #
  # @param trace [Datadog::Tracing::TraceOperation]
  # @raise [NotImplementedError]
  # @return [Float, nil] sampling ratio between 0.0 and 1.0 (inclusive), or `nil` if not applicable
  #
  # source://ddtrace//lib/datadog/tracing/sampling/sampler.rb#36
  def sample_rate(trace); end
end

# A {Datadog::Sampling::Matcher} that supports matching a trace by
# trace name and/or service name.
#
# source://ddtrace//lib/datadog/tracing/sampling/matcher.rb#22
class Datadog::Tracing::Sampling::SimpleMatcher < ::Datadog::Tracing::Sampling::Matcher
  # @param name [String, Regexp, Proc] Matcher for case equality (===) with the trace name,
  #   defaults to always match
  # @param service [String, Regexp, Proc] Matcher for case equality (===) with the service name,
  #   defaults to always match
  # @return [SimpleMatcher] a new instance of SimpleMatcher
  #
  # source://ddtrace//lib/datadog/tracing/sampling/matcher.rb#38
  def initialize(name: T.unsafe(nil), service: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/sampling/matcher.rb#44
  def match?(trace); end

  # Returns the value of attribute name.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/matcher.rb#32
  def name; end

  # Returns the value of attribute service.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/matcher.rb#32
  def service; end
end

# Returns `true` for case equality (===) with any object
#
# source://ddtrace//lib/datadog/tracing/sampling/matcher.rb#24
Datadog::Tracing::Sampling::SimpleMatcher::MATCH_ALL = T.let(T.unsafe(nil), T.untyped)

# A {Datadog::Tracing::Sampling::Rule} that matches a trace based on
# trace name and/or service name and
# applies a fixed sampling to matching spans.
#
# source://ddtrace//lib/datadog/tracing/sampling/rule.rb#50
class Datadog::Tracing::Sampling::SimpleRule < ::Datadog::Tracing::Sampling::Rule
  # @param name [String, Regexp, Proc] Matcher for case equality (===) with the trace name, defaults to always match
  # @param service [String, Regexp, Proc] Matcher for case equality (===) with the service name,
  #   defaults to always match
  # @param sample_rate [Float] Sampling rate between +[0,1]+
  # @return [SimpleRule] a new instance of SimpleRule
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rule.rb#55
  def initialize(name: T.unsafe(nil), service: T.unsafe(nil), sample_rate: T.unsafe(nil)); end
end

# source://ddtrace//lib/datadog/tracing/sampling/span/sampler.rb#6
module Datadog::Tracing::Sampling::Span; end

# Single Span Sampling constants.
#
# source://ddtrace//lib/datadog/tracing/sampling/span/ext.rb#8
module Datadog::Tracing::Sampling::Span::Ext; end

# Unlimited.
#
# @see Datadog::Tracing::Sampling::TokenBucket
#
# source://ddtrace//lib/datadog/tracing/sampling/span/ext.rb#13
Datadog::Tracing::Sampling::Span::Ext::DEFAULT_MAX_PER_SECOND = T.let(T.unsafe(nil), Integer)

# Accept all spans (100% retention).
#
# source://ddtrace//lib/datadog/tracing/sampling/span/ext.rb#10
Datadog::Tracing::Sampling::Span::Ext::DEFAULT_SAMPLE_RATE = T.let(T.unsafe(nil), Float)

# Rate limit configured for this span, if a rule applies
#
# source://ddtrace//lib/datadog/tracing/sampling/span/ext.rb#20
Datadog::Tracing::Sampling::Span::Ext::TAG_MAX_PER_SECOND = T.let(T.unsafe(nil), String)

# Sampling decision method used to come to the sampling decision for this span
#
# source://ddtrace//lib/datadog/tracing/sampling/span/ext.rb#16
Datadog::Tracing::Sampling::Span::Ext::TAG_MECHANISM = T.let(T.unsafe(nil), String)

# Sampling rate applied to this span, if a rule applies
#
# source://ddtrace//lib/datadog/tracing/sampling/span/ext.rb#18
Datadog::Tracing::Sampling::Span::Ext::TAG_RULE_RATE = T.let(T.unsafe(nil), String)

# Checks if a span conforms to a matching criteria.
#
# source://ddtrace//lib/datadog/tracing/sampling/span/matcher.rb#8
class Datadog::Tracing::Sampling::Span::Matcher
  # Matches span name and service to their respective patterns provided.
  #
  # The patterns are {String}s with two special characters available:
  # 1. `?`: matches exactly one of any character.
  # 2. `*`: matches a substring of any size, including zero.
  # These patterns can occur any point of the string, any number of times.
  #
  # Both {SpanOperation#name} and {SpanOperation#service} must match the provided patterns.
  #
  # The whole String has to match the provided patterns: providing a pattern that
  # matches a portion of the provided String is not considered a match.
  #
  # @example web-*
  #   `'web-*'` will match any string starting with `web-`.
  # @example cache-?
  #   `'cache-?'` will match any string starting with `database-` followed by exactly one character.
  # @param name_pattern [String] a pattern to be matched against {SpanOperation#name}
  # @param service_pattern [String] a pattern to be matched against {SpanOperation#service}
  # @return [Matcher] a new instance of Matcher
  #
  # source://ddtrace//lib/datadog/tracing/sampling/span/matcher.rb#33
  def initialize(name_pattern: T.unsafe(nil), service_pattern: T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/sampling/span/matcher.rb#59
  def ==(other); end

  # DEV: Remove when support for Ruby 2.3 and older is removed.
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/sampling/span/matcher.rb#47
  def match?(span); end

  # Returns the value of attribute name.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/span/matcher.rb#9
  def name; end

  # Returns the value of attribute service.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/span/matcher.rb#9
  def service; end

  private

  # @param pattern [String]
  # @return [Regexp]
  #
  # source://ddtrace//lib/datadog/tracing/sampling/span/matcher.rb#70
  def pattern_to_regex(pattern); end
end

# Pattern that matches any string
#
# source://ddtrace//lib/datadog/tracing/sampling/span/matcher.rb#12
Datadog::Tracing::Sampling::Span::Matcher::MATCH_ALL_PATTERN = T.let(T.unsafe(nil), String)

# Span sampling rule that applies a sampling rate if the span
# matches the provided {Matcher}.
# Additionally, a rate limiter is also applied.
#
# If a span does not conform to the matcher, no changes are made.
#
# source://ddtrace//lib/datadog/tracing/sampling/span/rule.rb#14
class Datadog::Tracing::Sampling::Span::Rule
  # Creates a new span sampling rule.
  #
  # @param matcher [Sampling::Span::Matcher] whether this rule applies to a specific span
  # @param sample_rate [Float] span sampling ratio, between 0.0 (0%) and 1.0 (100%).
  # @param rate_limit [Numeric] maximum number of spans sampled per second. Negative numbers mean unlimited spans.
  # @return [Rule] a new instance of Rule
  #
  # source://ddtrace//lib/datadog/tracing/sampling/span/rule.rb#22
  def initialize(matcher, sample_rate: T.unsafe(nil), rate_limit: T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/sampling/span/rule.rb#71
  def ==(other); end

  # Returns the value of attribute matcher.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/span/rule.rb#15
  def matcher; end

  # Returns the value of attribute rate_limit.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/span/rule.rb#15
  def rate_limit; end

  # This method should only be invoked for spans that are part
  # of a trace that has been dropped by trace-level sampling.
  # Invoking it for other spans will cause incorrect sampling
  # metrics to be reported by the Datadog App.
  #
  # Returns `true` if the provided span is sampled.
  # If the span is dropped due to sampling rate or rate limiting,
  # it returns `false`.
  #
  # Returns `nil` if the span did not meet the matching criteria by the
  # provided matcher.
  #
  # This method modifies the `span` if it matches the provided matcher.
  #
  # @param span_op [Datadog::Tracing::SpanOperation] span to be sampled
  # @return [:kept, :rejected] should this span be sampled?
  # @return [:not_matched] span did not satisfy the matcher, no changes are made to the span
  #
  # source://ddtrace//lib/datadog/tracing/sampling/span/rule.rb#58
  def sample!(span_op); end

  # Returns the value of attribute sample_rate.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/span/rule.rb#15
  def sample_rate; end
end

# Converts user configuration into {Datadog::Tracing::Sampling::Span::Rule} objects,
# handling any parsing errors.
#
# source://ddtrace//lib/datadog/tracing/sampling/span/rule_parser.rb#15
module Datadog::Tracing::Sampling::Span::RuleParser
  class << self
    # Parses the provided JSON string containing the Single Span
    # Sampling configuration list.
    # In case of parsing errors, `nil` is returned.
    #
    # @param rules [String] the JSON configuration rules to be parsed
    # @return [Array<Datadog::Tracing::Sampling::Span::Rule>] a list of parsed rules
    # @return [nil] if parsing failed
    #
    # source://ddtrace//lib/datadog/tracing/sampling/span/rule_parser.rb#24
    def parse_json(rules); end

    # Parses a list of Hashes containing the parsed JSON information
    # for Single Span Sampling configuration.
    # In case of parsing errors, `nil` is returned.
    #
    # @param rules [Array<String] the JSON configuration rules to be parsed] ules [Array<String] the JSON configuration rules to be parsed
    # @return [Array<Datadog::Tracing::Sampling::Span::Rule>] a list of parsed rules
    # @return [nil] if parsing failed
    #
    # source://ddtrace//lib/datadog/tracing/sampling/span/rule_parser.rb#47
    def parse_list(rules); end

    private

    # source://ddtrace//lib/datadog/tracing/sampling/span/rule_parser.rb#76
    def parse_rule(hash); end
  end
end

# Applies Single Span Sampling rules to spans.
# When matching the configured rules, a span is ensured to
# be processed Datadog App. In other words, a single sampled span
# will never be dropped by the tracer or Datadog agent.
#
# All spans in a trace are subject to the single sampling rules, if
# any rules are configured.
#
# Single Span Sampling is distinct from trace-level sampling:
# Single Span Sampling can ensure a span is kept, even if its
# enclosing trace is rejected by trace-level sampling.
#
# This class only applies operations to spans that are part
# of traces that was rejected by trace sampling.
# A trace is rejected if either of the following conditions is true:
# * The priority sampling for a trace is set to either {USER_REJECT} or {AUTO_REJECT}.
# * The trace was rejected by internal sampling, thus never flushed.
#
# Single-sampled spans are tagged and the tracer ensures they will
# reach the Datadog App, regardless of their enclosing trace sampling decision.
#
# Single Span Sampling does not inspect spans that are part of a trace
# that has been accepted by trace-level sampling rules: all spans from such
# trace are guaranteed to reach the Datadog App.
#
# source://ddtrace//lib/datadog/tracing/sampling/span/sampler.rb#31
class Datadog::Tracing::Sampling::Span::Sampler
  # Receives sampling rules to apply to individual spans.
  #
  # @param rules [Array<Datadog::Tracing::Sampling::Span::Rule>] list of rules to apply to spans
  # @return [Sampler] a new instance of Sampler
  #
  # source://ddtrace//lib/datadog/tracing/sampling/span/sampler.rb#37
  def initialize(rules = T.unsafe(nil)); end

  # Returns the value of attribute rules.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/span/sampler.rb#32
  def rules; end

  # Applies Single Span Sampling rules to the span if the trace has been rejected.
  #
  # The trace can be outright rejected, and never reach the transport,
  # or be set as rejected by priority sampling. In both cases, the trace
  # is considered rejected for Single Span Sampling purposes.
  #
  # If multiple rules match, only the first one is applied.
  #
  # @param trace_op [Datadog::Tracing::TraceOperation] trace for the provided span
  # @param span_op [Datadog::Tracing::SpanOperation] Span to apply sampling rules
  # @return [void]
  #
  # source://ddtrace//lib/datadog/tracing/sampling/span/sampler.rb#52
  def sample!(trace_op, span_op); end
end

# Implementation of the Token Bucket metering algorithm
# for rate limiting.
#
# @see https://en.wikipedia.org/wiki/Token_bucket Token bucket
#
# source://ddtrace//lib/datadog/tracing/sampling/rate_limiter.rb#30
class Datadog::Tracing::Sampling::TokenBucket < ::Datadog::Tracing::Sampling::RateLimiter
  # @param rate [Numeric] Allowance rate, in units per second
  #   if rate is negative, always allow
  #   if rate is zero, never allow
  # @param max_tokens [Numeric] Limit of available tokens
  # @raise [ArgumentError]
  # @return [TokenBucket] a new instance of TokenBucket
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rate_limiter.rb#37
  def initialize(rate, max_tokens = T.unsafe(nil)); end

  # Checks if a message of provided +size+
  # conforms with the current bucket limit.
  #
  # If it does, return +true+ and remove +size+
  # tokens from the bucket.
  # If it does not, return +false+ without affecting
  # the tokens from the bucket.
  #
  # @return [Boolean] +true+ if message conforms with current bucket limit
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rate_limiter.rb#65
  def allow?(size); end

  # @return [Numeric] number of tokens currently available
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rate_limiter.rb#99
  def available_tokens; end

  # Ratio of 'conformance' per 'total messages' checked
  # on this bucket
  #
  # Returns +1.0+ when no messages have been checked yet.
  #
  # @return [Float] Conformance ratio, between +[0,1]+
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rate_limiter.rb#92
  def current_window_rate; end

  # Ratio of 'conformance' per 'total messages' checked
  # averaged for the past 2 buckets
  #
  # Returns +1.0+ when no messages have been checked yet.
  #
  # @return [Float] Conformance ratio, between +[0,1]+
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rate_limiter.rb#77
  def effective_rate; end

  # Returns the value of attribute max_tokens.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rate_limiter.rb#31
  def max_tokens; end

  # Returns the value of attribute rate.
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rate_limiter.rb#31
  def rate; end

  private

  # source://ddtrace//lib/datadog/tracing/sampling/rate_limiter.rb#125
  def increment_conforming_count; end

  # source://ddtrace//lib/datadog/tracing/sampling/rate_limiter.rb#121
  def increment_total_count; end

  # source://ddtrace//lib/datadog/tracing/sampling/rate_limiter.rb#105
  def refill_since_last_message; end

  # source://ddtrace//lib/datadog/tracing/sampling/rate_limiter.rb#116
  def refill_tokens(size); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rate_limiter.rb#129
  def should_allow?(size); end

  # Sets and Updates the past two 1 second windows for which
  # the rate limiter must compute it's rate over and updates
  # the total count, and conforming message count if +allowed+
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rate_limiter.rb#149
  def update_rate_counts(allowed); end
end

# {Datadog::Tracing::Sampling::RateLimiter} that accepts all resources,
# with no limits.
#
# source://ddtrace//lib/datadog/tracing/sampling/rate_limiter.rb#173
class Datadog::Tracing::Sampling::UnlimitedLimiter < ::Datadog::Tracing::Sampling::RateLimiter
  # @return [Boolean] always +true+
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rate_limiter.rb#175
  def allow?(_); end

  # @return [Float] always 100%
  #
  # source://ddtrace//lib/datadog/tracing/sampling/rate_limiter.rb#180
  def effective_rate; end
end

# Represents a logical unit of work in the system. Each trace consists of one or more spans.
# Each span consists of a start time and a duration. For example, a span can describe the time
# spent on a distributed call on a separate machine, or the time spent in a small component
# within a larger operation. Spans can be nested within each other, and in those instances
# will have a parent-child relationship.
#
# source://ddtrace//lib/datadog/tracing/span.rb#17
class Datadog::Tracing::Span
  include ::Datadog::Tracing::Metadata::Analytics
  include ::Datadog::Tracing::Metadata
  include ::Datadog::Tracing::Metadata::Tagging
  include ::Datadog::Tracing::Metadata::Errors

  # Create a new span manually. Call the <tt>start()</tt> method to start the time
  # measurement and then <tt>stop()</tt> once the timing operation is over.
  #
  # * +service+: the service name for this span
  # * +resource+: the resource this span refers, or +name+ if it's missing.
  #     +nil+ can be used as a placeholder, when the resource value is not yet known at +#initialize+ time.
  # * +type+: the type of the span (such as +http+, +db+ and so on)
  # * +parent_id+: the identifier of the parent span
  # * +trace_id+: the identifier of the root span for this trace
  # * +service_entry+: whether it is a service entry span.
  # TODO: Remove span_type
  #
  # @return [Span] a new instance of Span
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#53
  def initialize(name, duration: T.unsafe(nil), end_time: T.unsafe(nil), id: T.unsafe(nil), meta: T.unsafe(nil), metrics: T.unsafe(nil), parent_id: T.unsafe(nil), resource: T.unsafe(nil), service: T.unsafe(nil), span_type: T.unsafe(nil), start_time: T.unsafe(nil), status: T.unsafe(nil), type: T.unsafe(nil), trace_id: T.unsafe(nil), service_entry: T.unsafe(nil)); end

  # Spans with the same ID are considered the same span
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#122
  def ==(other); end

  # source://ddtrace//lib/datadog/tracing/span.rb#111
  def duration; end

  # Sets the attribute duration
  #
  # @param value the value to set the attribute duration to.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#34
  def duration=(_arg0); end

  # Returns the value of attribute end_time.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#20
  def end_time; end

  # Sets the attribute end_time
  #
  # @param value the value to set the attribute end_time to.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#20
  def end_time=(_arg0); end

  # Return whether the duration is stopped or not.
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#106
  def finished?; end

  # Returns the value of attribute id.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#20
  def id; end

  # Sets the attribute id
  #
  # @param value the value to set the attribute id to.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#20
  def id=(_arg0); end

  # Returns the value of attribute meta.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#20
  def meta; end

  # Sets the attribute meta
  #
  # @param value the value to set the attribute meta to.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#20
  def meta=(_arg0); end

  # Returns the value of attribute metrics.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#20
  def metrics; end

  # Sets the attribute metrics
  #
  # @param value the value to set the attribute metrics to.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#20
  def metrics=(_arg0); end

  # Returns the value of attribute name.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#20
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#20
  def name=(_arg0); end

  # Returns the value of attribute parent_id.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#20
  def parent_id; end

  # Sets the attribute parent_id
  #
  # @param value the value to set the attribute parent_id to.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#20
  def parent_id=(_arg0); end

  # Return a human readable version of the span
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#158
  def pretty_print(q); end

  # Returns the value of attribute resource.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#20
  def resource; end

  # Sets the attribute resource
  #
  # @param value the value to set the attribute resource to.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#20
  def resource=(_arg0); end

  # Returns the value of attribute service.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#20
  def service; end

  # Sets the attribute service
  #
  # @param value the value to set the attribute service to.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#20
  def service=(_arg0); end

  # source://ddtrace//lib/datadog/tracing/span.rb#116
  def set_error(e); end

  # Returns the value of attribute id.
  # For backwards compatiblity
  # TODO: Deprecate and remove these.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#20
  def span_id; end

  # Returns the value of attribute type.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#20
  def span_type; end

  # Returns the value of attribute start_time.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#20
  def start_time; end

  # Sets the attribute start_time
  #
  # @param value the value to set the attribute start_time to.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#20
  def start_time=(_arg0); end

  # Return whether the duration is started or not
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#101
  def started?; end

  # Returns the value of attribute status.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#20
  def status; end

  # Sets the attribute status
  #
  # @param value the value to set the attribute status to.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#20
  def status=(_arg0); end

  # Return whether the duration is stopped or not.
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#106
  def stopped?; end

  # Return the hash representation of the current span.
  # TODO: Change this to reflect attributes when serialization
  # isn't handled by this method.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#135
  def to_hash; end

  # Return a string representation of the span.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#128
  def to_s; end

  # Returns the value of attribute trace_id.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#20
  def trace_id; end

  # Sets the attribute trace_id
  #
  # @param value the value to set the attribute trace_id to.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#20
  def trace_id=(_arg0); end

  # Returns the value of attribute type.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#20
  def type; end

  # Sets the attribute type
  #
  # @param value the value to set the attribute type to.
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#20
  def type=(_arg0); end

  private

  # Used for serialization
  #
  # @return [Integer] in nanoseconds since Epoch
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#199
  def duration_nano; end

  # https://docs.datadoghq.com/tracing/visualization/#service-entry-span
  # A span is a service entry span when it is the entrypoint method for a request to a service.
  # You can visualize this within Datadog APM when the color of the immediate parent on a flame graph is a different
  # color. Services are also listed on the right when viewing a flame graph.
  #
  # @return [Boolean] `true` if the span is a serivce entry span
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#209
  def service_entry?; end

  # Used for serialization
  #
  # @return [Integer] in nanoseconds since Epoch
  #
  # source://ddtrace//lib/datadog/tracing/span.rb#193
  def start_time_nano; end
end

# Represents the act of taking a span measurement.
# It gives a Span a context which can be used to
# build a Span. When completed, it yields the Span.
#
# source://ddtrace//lib/datadog/tracing/span_operation.rb#21
class Datadog::Tracing::SpanOperation
  include ::Datadog::Tracing::Metadata::Analytics
  include ::Datadog::Tracing::Metadata
  include ::Datadog::Tracing::Metadata::Tagging
  include ::Datadog::Tracing::Metadata::Errors

  # @return [SpanOperation] a new instance of SpanOperation
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#40
  def initialize(name, child_of: T.unsafe(nil), events: T.unsafe(nil), on_error: T.unsafe(nil), parent_id: T.unsafe(nil), resource: T.unsafe(nil), service: T.unsafe(nil), start_time: T.unsafe(nil), tags: T.unsafe(nil), trace_id: T.unsafe(nil), type: T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/span_operation.rb#264
  def duration; end

  # Span attributes
  # NOTE: In the future, we should drop the me
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#26
  def end_time; end

  # for backwards compatibility
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#239
  def end_time=(time); end

  # source://ddtrace//lib/datadog/tracing/span_operation.rb#243
  def finish(end_time = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#260
  def finished?; end

  # Span attributes
  # NOTE: In the future, we should drop the me
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#26
  def id; end

  # @raise [ArgumentError]
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#131
  def measure; end

  # Operation name.
  #
  # @return [String]
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#26
  def name; end

  # Operation name.
  #
  # @raise [ArgumentError]
  # @return [String]
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#104
  def name=(name); end

  # Span attributes
  # NOTE: In the future, we should drop the me
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#26
  def parent_id; end

  # Return a human readable version of the span
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#303
  def pretty_print(q); end

  # Span resource.
  #
  # @return [String] String
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#26
  def resource; end

  # Span resource.
  #
  # @return [String] String
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#127
  def resource=(resource); end

  # Service name.
  #
  # @return [String] String
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#26
  def service; end

  # Service name.
  #
  # @return [String] String
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#120
  def service=(service); end

  # source://ddtrace//lib/datadog/tracing/span_operation.rb#269
  def set_error(e); end

  # Span attributes
  # NOTE: In the future, we should drop the me
  # For backwards compatibility
  # TODO: Deprecate and remove these in 2.0.
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#26
  def span_id; end

  # Span type.
  #
  # @return [String] String
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#26
  def span_type; end

  # Span type.
  #
  # @return [String] String
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#113
  def span_type=(type); end

  # source://ddtrace//lib/datadog/tracing/span_operation.rb#185
  def start(start_time = T.unsafe(nil)); end

  # Span attributes
  # NOTE: In the future, we should drop the me
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#26
  def start_time; end

  # for backwards compatibility
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#234
  def start_time=(time); end

  # Return whether the duration is started or not
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#224
  def started?; end

  # Returns the value of attribute status.
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#37
  def status; end

  # Sets the attribute status
  #
  # @param value the value to set the attribute status to.
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#37
  def status=(_arg0); end

  # Mark the span stopped at the current time
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#200
  def stop(stop_time = T.unsafe(nil)); end

  # Return whether the duration is stopped or not.
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#229
  def stopped?; end

  # Return the hash representation of the current span.
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#280
  def to_hash; end

  # Return a string representation of the span.
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#275
  def to_s; end

  # Span attributes
  # NOTE: In the future, we should drop the me
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#26
  def trace_id; end

  # Span type.
  #
  # @return [String] String
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#26
  def type; end

  # Span type.
  #
  # @return [String] String
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#113
  def type=(type); end

  private

  # Create a Span from the operation which represents
  # the finalized measurement. We #dup here to prevent
  # mutation by reference; when this span is returned,
  # we don't want this SpanOperation to modify it further.
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#442
  def build_span; end

  # source://ddtrace//lib/datadog/tracing/span_operation.rb#482
  def duration_marker; end

  # Used for serialization
  #
  # @return [Integer] in nanoseconds since Epoch
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#494
  def duration_nano; end

  # Keep span reference private: we don't want users
  # modifying the finalized span from the operation after
  # it has been finished.
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#433
  def events; end

  # Keep span reference private: we don't want users
  # modifying the finalized span from the operation after
  # it has been finished.
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#433
  def parent; end

  # Set this span's parent, inheriting any properties not explicitly set.
  # If the parent is nil, set the span as the root span.
  #
  # DEV: This method creates a false expectation that
  # `self.parent.id == self.parent_id`, which is not the case
  # for distributed traces, as the parent Span object does not exist
  # in this application. `#parent_id` is the only reliable parent
  # identifier. We should remove the ability to set a parent Span
  # object in the future.
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#470
  def parent=(parent); end

  # Keep span reference private: we don't want users
  # modifying the finalized span from the operation after
  # it has been finished.
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#433
  def span; end

  # Used for serialization
  #
  # @return [Integer] in nanoseconds since Epoch
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#488
  def start_time_nano; end
end

# Error when the span attempts to start again after being started
#
# source://ddtrace//lib/datadog/tracing/span_operation.rb#422
class Datadog::Tracing::SpanOperation::AlreadyStartedError < ::StandardError
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#423
  def message; end
end

# Callback behavior
#
# source://ddtrace//lib/datadog/tracing/span_operation.rb#335
class Datadog::Tracing::SpanOperation::Events
  include ::Datadog::Tracing::Events
  include ::Datadog::Tracing::Events::InstanceMethods
  extend ::Datadog::Tracing::Events::ClassMethods

  # @return [Events] a new instance of Events
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#345
  def initialize(on_error: T.unsafe(nil)); end

  # Returns the value of attribute after_finish.
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#340
  def after_finish; end

  # Returns the value of attribute after_stop.
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#340
  def after_stop; end

  # Returns the value of attribute before_start.
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#340
  def before_start; end

  # This event is lazily initialized as error paths
  # are normally less common that non-error paths.
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#353
  def on_error; end
end

# Triggered when the span is finished, regardless of error.
#
# source://ddtrace//lib/datadog/tracing/span_operation.rb#358
class Datadog::Tracing::SpanOperation::Events::AfterFinish < ::Datadog::Tracing::Event
  # @return [AfterFinish] a new instance of AfterFinish
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#359
  def initialize; end
end

# Triggered when the span is stopped, regardless of error.
#
# source://ddtrace//lib/datadog/tracing/span_operation.rb#365
class Datadog::Tracing::SpanOperation::Events::AfterStop < ::Datadog::Tracing::Event
  # @return [AfterStop] a new instance of AfterStop
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#366
  def initialize; end
end

# Triggered just before the span is started.
#
# source://ddtrace//lib/datadog/tracing/span_operation.rb#372
class Datadog::Tracing::SpanOperation::Events::BeforeStart < ::Datadog::Tracing::Event
  # @return [BeforeStart] a new instance of BeforeStart
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#373
  def initialize; end
end

# source://ddtrace//lib/datadog/tracing/span_operation.rb#338
Datadog::Tracing::SpanOperation::Events::DEFAULT_ON_ERROR = T.let(T.unsafe(nil), Proc)

# Triggered when the span raises an error during measurement.
#
# source://ddtrace//lib/datadog/tracing/span_operation.rb#379
class Datadog::Tracing::SpanOperation::Events::OnError
  # @return [OnError] a new instance of OnError
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#380
  def initialize(default); end

  # source://ddtrace//lib/datadog/tracing/span_operation.rb#407
  def publish(*args); end

  # DEV: Revisit this before full 1.0 release.
  # It seems like OnError wants to behave like a middleware stack,
  # where each "subscriber"'s executed is chained to the previous one.
  # This is different from how {Tracing::Event} works, and might be incompatible.
  #
  # source://ddtrace//lib/datadog/tracing/span_operation.rb#390
  def wrap_default; end
end

# SyncWriter flushes both services and traces synchronously
# DEV: To be replaced by Datadog::Tracing::Workers::TraceWriter.
#
# Note: If you're wondering if this class is used at all, since there are no other references to it on the codebase,
# the separate `datadog-lambda` uses it as of February 2021:
# <https://github.com/DataDog/datadog-lambda-rb/blob/c15f0f0916c90123416dc44e7d6800ef4a7cfdbf/lib/datadog/lambda.rb#L38>
#
# source://ddtrace//lib/datadog/tracing/sync_writer.rb#18
class Datadog::Tracing::SyncWriter
  # @param transport [Datadog::Transport::Traces::Transport] a custom transport instance.
  #   If provided, overrides `transport_options` and `agent_settings`.
  # @param transport_options [Hash<Symbol,Object>] options for the default transport instance.
  # @param agent_settings [Datadog::Core::Configuration::AgentSettingsResolver::AgentSettings] agent options for
  #   the default transport instance.
  # @return [SyncWriter] a new instance of SyncWriter
  #
  # source://ddtrace//lib/datadog/tracing/sync_writer.rb#28
  def initialize(transport: T.unsafe(nil), transport_options: T.unsafe(nil), agent_settings: T.unsafe(nil)); end

  # Returns the value of attribute events.
  #
  # source://ddtrace//lib/datadog/tracing/sync_writer.rb#19
  def events; end

  # Does nothing.
  # The {SyncWriter} does not need to be stopped as it holds no state.
  #
  # source://ddtrace//lib/datadog/tracing/sync_writer.rb#48
  def stop; end

  # Returns the value of attribute transport.
  #
  # source://ddtrace//lib/datadog/tracing/sync_writer.rb#19
  def transport; end

  # Sends traces to the configured transport.
  #
  # Traces are flushed immediately.
  #
  # source://ddtrace//lib/datadog/tracing/sync_writer.rb#40
  def write(trace); end

  private

  # source://ddtrace//lib/datadog/tracing/sync_writer.rb#55
  def flush_trace(trace); end
end

# Trace buffer that stores application traces, has a maximum size, and
# can be safely used concurrently on any environment.
#
# @see Datadog::Core::Buffer::ThreadSafe
#
# source://ddtrace//lib/datadog/tracing/buffer.rb#101
class Datadog::Tracing::ThreadSafeTraceBuffer < ::Datadog::Core::Buffer::ThreadSafe
  include ::Datadog::Tracing::MeasuredBuffer
end

# Trace buffer that stores application traces. The buffer has a maximum size and when
# the buffer is full, a random trace is discarded. This class is thread-safe and is used
# automatically by the ``Tracer`` instance when a ``Span`` is finished.
#
# We choose the default TraceBuffer implementation for current platform dynamically here.
#
# TODO We should restructure this module, so that classes are not declared at top-level ::Datadog.
# TODO Making such a change is potentially breaking for users manually configuring the tracer.
#
# source://ddtrace//lib/datadog/tracing/buffer.rb#121
Datadog::Tracing::TraceBuffer = Datadog::Tracing::CRubyTraceBuffer

# Trace digest that represents the important parts of an active trace.
# Used to propagate context and continue traces across execution boundaries.
#
# source://ddtrace//lib/datadog/tracing/trace_digest.rb#8
class Datadog::Tracing::TraceDigest
  # @return [TraceDigest] a new instance of TraceDigest
  #
  # source://ddtrace//lib/datadog/tracing/trace_digest.rb#101
  def initialize(span_id: T.unsafe(nil), span_name: T.unsafe(nil), span_resource: T.unsafe(nil), span_service: T.unsafe(nil), span_type: T.unsafe(nil), trace_distributed_tags: T.unsafe(nil), trace_hostname: T.unsafe(nil), trace_id: T.unsafe(nil), trace_name: T.unsafe(nil), trace_origin: T.unsafe(nil), trace_process_id: T.unsafe(nil), trace_resource: T.unsafe(nil), trace_runtime_id: T.unsafe(nil), trace_sampling_priority: T.unsafe(nil), trace_service: T.unsafe(nil), trace_distributed_id: T.unsafe(nil), trace_flags: T.unsafe(nil), trace_state: T.unsafe(nil), trace_state_unknown_fields: T.unsafe(nil)); end

  # Datadog id for the currently active span.
  #
  # @return [Integer]
  #
  # source://ddtrace//lib/datadog/tracing/trace_digest.rb#80
  def span_id; end

  # The operation name of the currently active span.
  #
  # @return [String]
  #
  # source://ddtrace//lib/datadog/tracing/trace_digest.rb#80
  def span_name; end

  # The resource name of the currently active span.
  #
  # @return [String]
  #
  # source://ddtrace//lib/datadog/tracing/trace_digest.rb#80
  def span_resource; end

  # The service of the currently active span.
  #
  # @return [String]
  #
  # source://ddtrace//lib/datadog/tracing/trace_digest.rb#80
  def span_service; end

  # The type of the currently active span.
  #
  # @return [String]
  #
  # source://ddtrace//lib/datadog/tracing/trace_digest.rb#80
  def span_type; end

  # The trace id extracted from a distributed context, if different from `trace_id`.
  #
  # The current use case is when the distributed context has a trace id integer larger than 64-bit:
  # This attribute will preserve the original id, while `trace_id` will only contain the lower 64 bits.
  #
  # @return [Integer]
  # @see https://www.w3.org/TR/trace-context/#trace-id
  #
  # source://ddtrace//lib/datadog/tracing/trace_digest.rb#80
  def trace_distributed_id; end

  # Datadog-specific tags that support richer distributed tracing association.
  #
  # @return [Hash<String,String>]
  #
  # source://ddtrace//lib/datadog/tracing/trace_digest.rb#80
  def trace_distributed_tags; end

  # The W3C "trace-flags" extracted from a distributed context. This field is an 8-bit unsigned integer.
  #
  # @return [Integer]
  # @see https://www.w3.org/TR/trace-context/#trace-flags
  #
  # source://ddtrace//lib/datadog/tracing/trace_digest.rb#80
  def trace_flags; end

  # The hostname of the currently active trace. Use to attribute traces to hosts.
  #
  # @return [String]
  #
  # source://ddtrace//lib/datadog/tracing/trace_digest.rb#80
  def trace_hostname; end

  # Datadog id for the currently active trace.
  #
  # @return [Integer]
  #
  # source://ddtrace//lib/datadog/tracing/trace_digest.rb#80
  def trace_id; end

  # Operation name for the currently active trace.
  #
  # @return [Integer]
  #
  # source://ddtrace//lib/datadog/tracing/trace_digest.rb#80
  def trace_name; end

  # Datadog-specific attribution of this trace's creation.
  #
  # @return [String]
  #
  # source://ddtrace//lib/datadog/tracing/trace_digest.rb#80
  def trace_origin; end

  # The OS-specific process id.
  #
  # @return [Integer]
  #
  # source://ddtrace//lib/datadog/tracing/trace_digest.rb#80
  def trace_process_id; end

  # The resource name of the currently active trace.
  #
  # @return [String]
  #
  # source://ddtrace//lib/datadog/tracing/trace_digest.rb#80
  def trace_resource; end

  # Unique id to this Ruby process. Used to differentiate traces coming from
  # child processes forked from same parent process.
  #
  # @return [String]
  #
  # source://ddtrace//lib/datadog/tracing/trace_digest.rb#80
  def trace_runtime_id; end

  # Datadog-specific sampling decision for the currently active trace.
  #
  # @return [Integer]
  #
  # source://ddtrace//lib/datadog/tracing/trace_digest.rb#80
  def trace_sampling_priority; end

  # The service of the currently active trace.
  #
  # @return [String]
  #
  # source://ddtrace//lib/datadog/tracing/trace_digest.rb#80
  def trace_service; end

  # The W3C "tracestate" extracted from a distributed context.
  # This field is a string representing vendor-specific distribution data.
  # The `dd=` entry is removed from `trace_state` as its value is dynamically calculated
  # on every propagation injection.
  #
  # @return [String]
  # @see https://www.w3.org/TR/trace-context/#tracestate-header
  #
  # source://ddtrace//lib/datadog/tracing/trace_digest.rb#80
  def trace_state; end

  # TODO: The documentation for the last attribute above won't be rendered.
  # TODO: This might be a YARD bug as adding an attribute, making it now second-last attribute, renders correctly.
  #
  # source://ddtrace//lib/datadog/tracing/trace_digest.rb#80
  def trace_state_unknown_fields; end
end

# Represents the act of tracing a series of operations,
# by generating and collecting span measurements.
# When completed, it yields a trace.
#
# Supports synchronous code flow *only*. Usage across
# multiple threads will result in incorrect relationships.
# For async support, a {Datadog::Tracing::TraceOperation} should be employed
# per execution context (e.g. Thread, etc.)
#
# source://ddtrace//lib/datadog/tracing/trace_operation.rb#24
class Datadog::Tracing::TraceOperation
  include ::Datadog::Tracing::Metadata::Tagging

  # @return [TraceOperation] a new instance of TraceOperation
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#53
  def initialize(agent_sample_rate: T.unsafe(nil), events: T.unsafe(nil), hostname: T.unsafe(nil), id: T.unsafe(nil), max_length: T.unsafe(nil), name: T.unsafe(nil), origin: T.unsafe(nil), parent_span_id: T.unsafe(nil), rate_limiter_rate: T.unsafe(nil), resource: T.unsafe(nil), rule_sample_rate: T.unsafe(nil), sample_rate: T.unsafe(nil), sampled: T.unsafe(nil), sampling_priority: T.unsafe(nil), service: T.unsafe(nil), profiling_enabled: T.unsafe(nil), tags: T.unsafe(nil), metrics: T.unsafe(nil), trace_state: T.unsafe(nil), trace_state_unknown_fields: T.unsafe(nil)); end

  # Returns the value of attribute active_span.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#38
  def active_span; end

  # Returns the value of attribute active_span_count.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#38
  def active_span_count; end

  # Returns the value of attribute agent_sample_rate.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#29
  def agent_sample_rate; end

  # Sets the attribute agent_sample_rate
  #
  # @param value the value to set the attribute agent_sample_rate to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#29
  def agent_sample_rate=(_arg0); end

  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#202
  def build_span(op_name, events: T.unsafe(nil), on_error: T.unsafe(nil), resource: T.unsafe(nil), service: T.unsafe(nil), start_time: T.unsafe(nil), tags: T.unsafe(nil), type: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#117
  def finished?; end

  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#113
  def finished_span_count; end

  # Returns a {TraceSegment} with all finished spans that can be flushed
  # at invocation time. All other **finished** spans are discarded.
  #
  # @return [TraceSegment]
  # @yield [spans] spans that will be returned as part of the trace segment returned
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#262
  def flush!; end

  # Returns a copy of this trace suitable for forks (w/o spans.)
  # Used for continuation of traces across forks.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#306
  def fork_clone; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#109
  def full?; end

  # Returns the value of attribute hostname.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#29
  def hostname; end

  # Sets the attribute hostname
  #
  # @param value the value to set the attribute hostname to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#29
  def hostname=(_arg0); end

  # Returns the value of attribute id.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#38
  def id; end

  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#139
  def keep!; end

  # Returns the value of attribute max_length.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#38
  def max_length; end

  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#170
  def measure(op_name, events: T.unsafe(nil), on_error: T.unsafe(nil), resource: T.unsafe(nil), service: T.unsafe(nil), start_time: T.unsafe(nil), tags: T.unsafe(nil), type: T.unsafe(nil), &block); end

  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#151
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#47
  def name=(_arg0); end

  # Returns the value of attribute origin.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#29
  def origin; end

  # Sets the attribute origin
  #
  # @param value the value to set the attribute origin to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#29
  def origin=(_arg0); end

  # Returns the value of attribute parent_span_id.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#38
  def parent_span_id; end

  # Has the priority sampling chosen to keep this span?
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#135
  def priority_sampled?; end

  # Returns the value of attribute rate_limiter_rate.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#29
  def rate_limiter_rate; end

  # Sets the attribute rate_limiter_rate
  #
  # @param value the value to set the attribute rate_limiter_rate to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#29
  def rate_limiter_rate=(_arg0); end

  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#145
  def reject!; end

  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#155
  def resource; end

  # Sets the attribute resource
  #
  # @param value the value to set the attribute resource to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#47
  def resource=(_arg0); end

  # Returns true if the resource has been explicitly set
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#162
  def resource_override?; end

  # Returns the value of attribute rule_sample_rate.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#29
  def rule_sample_rate; end

  # Sets the attribute rule_sample_rate
  #
  # @param value the value to set the attribute rule_sample_rate to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#29
  def rule_sample_rate=(_arg0); end

  # Returns the value of attribute sample_rate.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#29
  def sample_rate; end

  # Sets the attribute sample_rate
  #
  # @param value the value to set the attribute sample_rate to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#29
  def sample_rate=(_arg0); end

  # Sets the attribute sampled
  #
  # @param value the value to set the attribute sampled to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#47
  def sampled=(_arg0); end

  # Will this trace be flushed by the tracer transport?
  # This includes cases where the span is kept solely due to priority sampling.
  #
  # This is not the ultimate Datadog App sampling decision. Downstream systems
  # can decide to reject this trace, especially for cases where priority
  # sampling is set to AUTO_KEEP.
  #
  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#129
  def sampled?; end

  # Returns the value of attribute sampling_priority.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#29
  def sampling_priority; end

  # Sets the attribute sampling_priority
  #
  # @param value the value to set the attribute sampling_priority to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#29
  def sampling_priority=(_arg0); end

  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#166
  def service; end

  # Sets the attribute service
  #
  # @param value the value to set the attribute service to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#47
  def service=(_arg0); end

  # Returns a set of trace headers used for continuing traces.
  # Used for propagation across execution contexts.
  # Data should reflect the active state of the trace.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#278
  def to_digest; end

  # Returns the value of attribute trace_state.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#38
  def trace_state; end

  # Returns the value of attribute trace_state_unknown_fields.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#38
  def trace_state_unknown_fields; end

  private

  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#383
  def activate_span!(span_op); end

  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#446
  def build_trace(spans, partial = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#393
  def deactivate_span!(span_op); end

  # Returns tracer tags that will be propagated if this span's context
  # is exported through {.to_digest}.
  #
  # @return [Hash] key value pairs of distributed tags
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#473
  def distributed_tags; end

  # Returns the value of attribute events.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#379
  def events; end

  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#415
  def finish_span(span, span_op, parent); end

  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#477
  def reset; end

  # Returns the value of attribute root_span.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#379
  def root_span; end

  # Track the root span
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#440
  def set_root_span!(span); end

  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#401
  def start_span(span_op); end
end

# source://ddtrace//lib/datadog/tracing/trace_operation.rb#27
Datadog::Tracing::TraceOperation::DEFAULT_MAX_LENGTH = T.let(T.unsafe(nil), Integer)

# Callback behavior
#
# source://ddtrace//lib/datadog/tracing/trace_operation.rb#331
class Datadog::Tracing::TraceOperation::Events
  include ::Datadog::Tracing::Events
  include ::Datadog::Tracing::Events::InstanceMethods
  extend ::Datadog::Tracing::Events::ClassMethods

  # @return [Events] a new instance of Events
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#339
  def initialize; end

  # Returns the value of attribute span_before_start.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#334
  def span_before_start; end

  # Returns the value of attribute span_finished.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#334
  def span_finished; end

  # Returns the value of attribute trace_finished.
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#334
  def trace_finished; end
end

# Triggered before a span starts.
#
# source://ddtrace//lib/datadog/tracing/trace_operation.rb#346
class Datadog::Tracing::TraceOperation::Events::SpanBeforeStart < ::Datadog::Tracing::Event
  # @return [SpanBeforeStart] a new instance of SpanBeforeStart
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#347
  def initialize; end
end

# Triggered when a span finishes, regardless of error.
#
# source://ddtrace//lib/datadog/tracing/trace_operation.rb#353
class Datadog::Tracing::TraceOperation::Events::SpanFinished < ::Datadog::Tracing::Event
  # @return [SpanFinished] a new instance of SpanFinished
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#354
  def initialize; end
end

# Triggered when the trace finishes, regardless of error.
#
# source://ddtrace//lib/datadog/tracing/trace_operation.rb#360
class Datadog::Tracing::TraceOperation::Events::TraceFinished < ::Datadog::Tracing::Event
  # @return [TraceFinished] a new instance of TraceFinished
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#361
  def initialize; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#366
  def deactivate_trace_subscribed?; end

  # source://ddtrace//lib/datadog/tracing/trace_operation.rb#370
  def subscribe_deactivate_trace(&block); end
end

# Serializable construct representing a trace
#
# source://ddtrace//lib/datadog/tracing/trace_segment.rb#13
class Datadog::Tracing::TraceSegment
  # @param spans [Array<Datadog::Span>]
  # @return [TraceSegment] a new instance of TraceSegment
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#40
  def initialize(spans, agent_sample_rate: T.unsafe(nil), hostname: T.unsafe(nil), id: T.unsafe(nil), lang: T.unsafe(nil), name: T.unsafe(nil), origin: T.unsafe(nil), process_id: T.unsafe(nil), rate_limiter_rate: T.unsafe(nil), resource: T.unsafe(nil), root_span_id: T.unsafe(nil), rule_sample_rate: T.unsafe(nil), runtime_id: T.unsafe(nil), sample_rate: T.unsafe(nil), sampling_priority: T.unsafe(nil), service: T.unsafe(nil), tags: T.unsafe(nil), metrics: T.unsafe(nil), profiling_enabled: T.unsafe(nil)); end

  # Returns the value of attribute agent_sample_rate.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#18
  def agent_sample_rate; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#90
  def any?; end

  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#94
  def count; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#98
  def empty?; end

  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#133
  def high_order_tid; end

  # Returns the value of attribute hostname.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#18
  def hostname; end

  # Returns the value of attribute id.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#18
  def id; end

  # If an active trace is present, forces it to be retained by the Datadog backend.
  #
  # Any sampling logic will not be able to change this decision.
  #
  # @return [void]
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#115
  def keep!; end

  # Returns the value of attribute lang.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#18
  def lang; end

  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#102
  def length; end

  # Returns the value of attribute name.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#18
  def name; end

  # Returns the value of attribute origin.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#18
  def origin; end

  # Returns the value of attribute process_id.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#18
  def process_id; end

  # Returns the value of attribute profiling_enabled.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#18
  def profiling_enabled; end

  # Returns the value of attribute rate_limiter_rate.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#18
  def rate_limiter_rate; end

  # If an active trace is present, forces it to be dropped and not stored by the Datadog backend.
  #
  # Any sampling logic will not be able to change this decision.
  #
  # @return [void]
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#124
  def reject!; end

  # Returns the value of attribute resource.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#18
  def resource; end

  # Returns the value of attribute rule_sample_rate.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#18
  def rule_sample_rate; end

  # Returns the value of attribute runtime_id.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#18
  def runtime_id; end

  # Returns the value of attribute sample_rate.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#18
  def sample_rate; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#128
  def sampled?; end

  # Returns the value of attribute sampling_decision_maker.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#18
  def sampling_decision_maker; end

  # Returns the value of attribute sampling_priority.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#18
  def sampling_priority; end

  # Returns the value of attribute service.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#18
  def service; end

  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#106
  def size; end

  # Returns the value of attribute spans.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#18
  def spans; end

  protected

  # Returns the value of attribute meta.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#141
  def meta; end

  # Returns the value of attribute metrics.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#141
  def metrics; end

  # Returns the value of attribute root_span_id.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#141
  def root_span_id; end

  private

  # Sets the attribute agent_sample_rate
  #
  # @param value the value to set the attribute agent_sample_rate to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#148
  def agent_sample_rate=(_arg0); end

  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#163
  def agent_sample_rate_tag; end

  # Sets the attribute hostname
  #
  # @param value the value to set the attribute hostname to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#148
  def hostname=(_arg0); end

  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#167
  def hostname_tag; end

  # Sets the attribute lang
  #
  # @param value the value to set the attribute lang to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#148
  def lang=(_arg0); end

  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#171
  def lang_tag; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#148
  def name=(_arg0); end

  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#175
  def name_tag; end

  # Sets the attribute origin
  #
  # @param value the value to set the attribute origin to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#148
  def origin=(_arg0); end

  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#179
  def origin_tag; end

  # Sets the attribute process_id
  #
  # @param value the value to set the attribute process_id to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#148
  def process_id=(_arg0); end

  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#183
  def process_id_tag; end

  # Sets the attribute rate_limiter_rate
  #
  # @param value the value to set the attribute rate_limiter_rate to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#148
  def rate_limiter_rate=(_arg0); end

  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#187
  def rate_limiter_rate_tag; end

  # Sets the attribute resource
  #
  # @param value the value to set the attribute resource to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#148
  def resource=(_arg0); end

  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#191
  def resource_tag; end

  # Sets the attribute rule_sample_rate
  #
  # @param value the value to set the attribute rule_sample_rate to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#148
  def rule_sample_rate=(_arg0); end

  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#195
  def rule_sample_rate_tag; end

  # Sets the attribute runtime_id
  #
  # @param value the value to set the attribute runtime_id to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#148
  def runtime_id=(_arg0); end

  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#199
  def runtime_id_tag; end

  # Sets the attribute sample_rate
  #
  # @param value the value to set the attribute sample_rate to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#148
  def sample_rate=(_arg0); end

  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#203
  def sample_rate_tag; end

  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#207
  def sampling_decision_maker_tag; end

  # Sets the attribute sampling_priority
  #
  # @param value the value to set the attribute sampling_priority to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#148
  def sampling_priority=(_arg0); end

  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#211
  def sampling_priority_tag; end

  # Sets the attribute service
  #
  # @param value the value to set the attribute service to.
  #
  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#148
  def service=(_arg0); end

  # source://ddtrace//lib/datadog/tracing/trace_segment.rb#215
  def service_tag; end
end

# source://ddtrace//lib/datadog/tracing/trace_segment.rb#14
Datadog::Tracing::TraceSegment::TAG_NAME = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/trace_segment.rb#15
Datadog::Tracing::TraceSegment::TAG_RESOURCE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/datadog/tracing/trace_segment.rb#16
Datadog::Tracing::TraceSegment::TAG_SERVICE = T.let(T.unsafe(nil), String)

# A {Datadog::Tracing::Tracer} keeps track of the time spent by an application processing a single operation. For
# example, a trace can be used to track the entire time spent processing a complicated web request.
# Even though the request may require multiple resources and machines to handle the request, all
# of these function calls and sub-requests would be encapsulated within a single trace.
#
# source://ddtrace//lib/datadog/tracing/tracer.rb#23
class Datadog::Tracing::Tracer
  # Initialize a new {Datadog::Tracing::Tracer} used to create, sample and submit spans that measure the
  # time of sections of code.
  #
  # @param trace_flush [Datadog::Tracing::TraceFlush] responsible for flushing spans from the execution context
  # @param context_provider [Datadog::Tracing::DefaultContextProvider] ensures different
  #   execution contexts have distinct traces
  # @param default_service [String] A fallback value for {Datadog::Tracing::Span#service}, as spans without
  #   service are rejected
  # @param enabled [Boolean] set if the tracer submits or not spans to the local agent
  # @param sampler [Datadog::Tracing::Sampler] a tracer sampler, responsible for filtering out spans when needed
  # @param tags [Hash] default tags added to all spans
  # @param writer [Datadog::Tracing::Writer] consumes traces returned by the provided +trace_flush+
  # @return [Tracer] a new instance of Tracer
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#48
  def initialize(trace_flush: T.unsafe(nil), context_provider: T.unsafe(nil), default_service: T.unsafe(nil), enabled: T.unsafe(nil), sampler: T.unsafe(nil), span_sampler: T.unsafe(nil), tags: T.unsafe(nil), writer: T.unsafe(nil)); end

  # Information about the currently active trace.
  #
  # The most common use cases are tagging log messages and metrics.
  #
  # @param key [Thread] Thread to retrieve trace from. Defaults to current thread. For internal use only.
  # @return [Datadog::Tracing::Correlation::Identifier] correlation object
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#229
  def active_correlation(key = T.unsafe(nil)); end

  # The active, unfinished span, representing the currently instrumented application section.
  #
  # The active span belongs to an {.active_trace}.
  #
  # @param key [Thread] Thread to retrieve trace from. Defaults to current thread. For internal use only.
  # @return [Datadog::Tracing::SpanOperation] the active span
  # @return [nil] if no trace is active, and thus no span is active
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#218
  def active_span(key = T.unsafe(nil)); end

  # The active, unfinished trace, representing the current instrumentation context.
  #
  # The active trace is fiber-local.
  #
  # @param key [Thread] Thread to retrieve trace from. Defaults to current thread. For internal use only.
  # @return [Datadog::Tracing::TraceSegment] the active trace
  # @return [nil] if no trace is active
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#207
  def active_trace(key = T.unsafe(nil)); end

  # Setup a new trace to continue from where another
  # trace left off.
  #
  # Used to continue distributed or async traces.
  #
  # @param digest [Datadog::Tracing::TraceDigest] continue from the {Datadog::Tracing::TraceDigest}.
  # @param key [Thread] Thread to retrieve trace from. Defaults to current thread. For internal use only.
  # @return [Object] If a block is provided, the result of the block execution.
  # @return [Datadog::Tracing::TraceOperation] If no block, the active {Datadog::Tracing::TraceOperation}.
  # @yield Optional block where this {#continue_trace!} `digest` scope is active.
  #   If no block, the `digest` remains active after {#continue_trace!} returns.
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#247
  def continue_trace!(digest, key = T.unsafe(nil), &block); end

  # Returns the value of attribute default_service.
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#31
  def default_service; end

  # Sets the attribute default_service
  #
  # @param value the value to set the attribute default_service to.
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#31
  def default_service=(_arg0); end

  # Returns the value of attribute enabled.
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#31
  def enabled; end

  # Sets the attribute enabled
  #
  # @param value the value to set the attribute enabled to.
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#31
  def enabled=(_arg0); end

  # Returns the value of attribute provider.
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#24
  def provider; end

  # Returns the value of attribute sampler.
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#24
  def sampler; end

  # Set the given key / value tag pair at the tracer level. These tags will be
  # appended to each span created by the tracer. Keys and values must be strings.
  #
  # @example
  #   tracer.set_tags('env' => 'prod', 'component' => 'core')
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#195
  def set_tags(tags); end

  # Shorthand that calls the `shutdown!` method of a registered worker.
  # It's useful to ensure that the Trace Buffer is properly flushed before
  # shutting down the application.
  #
  # @example
  #   tracer.trace('operation_name', service='rake_tasks') do |span_op|
  #   span_op.set_tag('task.name', 'script')
  #   end
  #
  #   tracer.shutdown!
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#295
  def shutdown!; end

  # Returns the value of attribute span_sampler.
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#24
  def span_sampler; end

  # Returns the value of attribute tags.
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#24
  def tags; end

  # Return a {Datadog::Tracing::SpanOperation span_op} and {Datadog::Tracing::TraceOperation trace_op}
  # that will trace an operation called `name`.
  #
  # You could trace your code using a <tt>do-block</tt> like:
  #
  # ```
  # tracer.trace('web.request') do |span_op, trace_op|
  #   span_op.service = 'my-web-site'
  #   span_op.resource = '/'
  #   span_op.set_tag('http.method', request.request_method)
  #   do_something()
  # end
  # ```
  #
  # The {#trace} method can also be used without a block in this way:
  # ```
  # span_op = tracer.trace('web.request', service: 'my-web-site')
  # do_something()
  # span_op.finish()
  # ```
  #
  # Remember that in this case, calling {Datadog::Tracing::SpanOperation#finish} is mandatory.
  #
  # When a Trace is started, {#trace} will store the created span; subsequent spans will
  # become its children and will inherit some properties:
  # ```
  # parent = tracer.trace('parent')   # has no parent span
  # child  = tracer.trace('child')    # is a child of 'parent'
  # child.finish()
  # parent.finish()
  # parent2 = tracer.trace('parent2') # has no parent span
  # parent2.finish()
  # ```
  #
  #
  # @param name [String] {Datadog::Tracing::Span} operation name.
  #   See {https://docs.datadoghq.com/tracing/guide/configuring-primary-operation/ Primary Operations in Services}.
  # @param continue_from [Datadog::Tracing::TraceDigest] continue a trace from a {Datadog::Tracing::TraceDigest}.
  #   Used for linking traces that are executed asynchronously.
  # @param on_error [Proc] a block that overrides error handling behavior for this operation.
  # @param resource [String] the resource this span refers, or `name` if it's missing
  # @param service [String] the service name for this span.
  # @param start_time [Time] time which the span should have started.
  # @param tags [Hash<String,String>] extra tags which should be added to the span.
  # @param type [String] the type of the span. See {Datadog::Tracing::Metadata::Ext::AppTypes}.
  # @return [Object] If a block is provided, returns the result of the block execution.
  # @return [Datadog::Tracing::SpanOperation] If no block is provided, returns the active,
  #   unfinished {Datadog::Tracing::SpanOperation}.
  # @yield Optional block where new newly created {Datadog::Tracing::SpanOperation} captures the execution.
  # @yieldparam span_op [Datadog::Tracing::SpanOperation] the newly created and active [Datadog::Tracing::SpanOperation]
  # @yieldparam trace_op [Datadog::Tracing::TraceOperation] the active [Datadog::Tracing::TraceOperation]
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#123
  def trace(name, continue_from: T.unsafe(nil), on_error: T.unsafe(nil), resource: T.unsafe(nil), service: T.unsafe(nil), start_time: T.unsafe(nil), tags: T.unsafe(nil), type: T.unsafe(nil), span_type: T.unsafe(nil), _context: T.unsafe(nil), &block); end

  # TODO: make this private
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#266
  def trace_completed; end

  # Returns the value of attribute trace_flush.
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#24
  def trace_flush; end

  # Returns the value of attribute writer.
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#31
  def writer; end

  # Sets the attribute writer
  #
  # @param value the value to set the attribute writer to.
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#31
  def writer=(_arg0); end

  private

  # source://ddtrace//lib/datadog/tracing/tracer.rb#341
  def bind_trace_events!(trace_op); end

  # source://ddtrace//lib/datadog/tracing/tracer.rb#412
  def build_span_events(events = T.unsafe(nil)); end

  # source://ddtrace//lib/datadog/tracing/tracer.rb#315
  def build_trace(digest = T.unsafe(nil)); end

  # Return the current active {Context} for this traced execution. This method is
  # automatically called when calling Tracer.trace or Tracer.start_span,
  # but it can be used in the application code during manual instrumentation.
  #
  # This method makes use of a {ContextProvider} that is automatically set during the tracer
  # initialization, or while using a library instrumentation.
  #
  # @param key [Thread] Thread to retrieve tracer from. Defaults to current thread.
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#311
  def call_context(key = T.unsafe(nil)); end

  # Flush finished spans from the trace buffer, send them to writer.
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#494
  def flush_trace(trace_op); end

  # Manually activate and deactivate the trace, when the span completes.
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#435
  def manual_trace_activation!(context, trace); end

  # source://ddtrace//lib/datadog/tracing/tracer.rb#533
  def profiling_enabled; end

  # source://ddtrace//lib/datadog/tracing/tracer.rb#423
  def resolve_tags(tags); end

  # source://ddtrace//lib/datadog/tracing/tracer.rb#480
  def sample_span(trace_op, span); end

  # Sample a span, tagging the trace as appropriate.
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#467
  def sample_trace(trace_op); end

  # TODO: Make these dummy objects singletons to preserve memory.
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#522
  def skip_trace(name); end

  # source://ddtrace//lib/datadog/tracing/tracer.rb#367
  def start_span(name, continue_from: T.unsafe(nil), on_error: T.unsafe(nil), resource: T.unsafe(nil), service: T.unsafe(nil), start_time: T.unsafe(nil), tags: T.unsafe(nil), type: T.unsafe(nil), _trace: T.unsafe(nil), &block); end

  # source://ddtrace//lib/datadog/tracing/tracer.rb#356
  def start_trace(continue_from: T.unsafe(nil)); end

  # Reactivate the original trace when trace completes
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#448
  def subscribe_trace_deactivation!(context, trace, original_trace); end

  # Send the trace to the writer to enqueue the spans list in the agent
  # sending queue.
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#510
  def write(trace); end
end

# source://ddtrace//lib/datadog/tracing/tracer.rb#505
Datadog::Tracing::Tracer::FLUSH_TRACE_LOG_ONLY_ONCE = T.let(T.unsafe(nil), Datadog::Core::Utils::OnlyOnce)

# source://ddtrace//lib/datadog/tracing/tracer.rb#490
Datadog::Tracing::Tracer::SAMPLE_SPAN_LOG_ONLY_ONCE = T.let(T.unsafe(nil), Datadog::Core::Utils::OnlyOnce)

# source://ddtrace//lib/datadog/tracing/tracer.rb#477
Datadog::Tracing::Tracer::SAMPLE_TRACE_LOG_ONLY_ONCE = T.let(T.unsafe(nil), Datadog::Core::Utils::OnlyOnce)

# Triggered whenever a trace is completed
#
# source://ddtrace//lib/datadog/tracing/tracer.rb#271
class Datadog::Tracing::Tracer::TraceCompleted < ::Datadog::Tracing::Event
  # @return [TraceCompleted] a new instance of TraceCompleted
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#272
  def initialize; end

  # NOTE: Ignore Rubocop rule. This definition allows for
  #       description of and constraints on arguments.
  #
  # source://ddtrace//lib/datadog/tracing/tracer.rb#279
  def publish(trace); end
end

# Utils contains low-level tracing utility functions.
#
# source://ddtrace//lib/datadog/tracing/utils.rb#10
module Datadog::Tracing::Utils
  extend ::Datadog::Core::Utils::Forking

  class << self
    # Return a randomly generated integer, valid as a Span ID or Trace ID.
    # This method is thread-safe and fork-safe.
    #
    # source://ddtrace//lib/datadog/tracing/utils.rb#35
    def next_id; end

    private

    # source://ddtrace//lib/datadog/tracing/utils.rb#40
    def id_rng; end

    # source://ddtrace//lib/datadog/tracing/utils.rb#44
    def reset!; end
  end
end

# While we only generate 63-bit integers due to limitations in other languages, we support
# parsing 64-bit integers for distributed tracing since an upstream system may generate one
#
# source://ddtrace//lib/datadog/tracing/utils.rb#27
Datadog::Tracing::Utils::EXTERNAL_MAX_ID = T.let(T.unsafe(nil), Integer)

# Excludes zero from possible values
#
# source://ddtrace//lib/datadog/tracing/utils.rb#23
Datadog::Tracing::Utils::RUBY_ID_RANGE = T.let(T.unsafe(nil), Range)

# The max value for a {Datadog::Tracing::Span} identifier.
# Span and trace identifiers should be strictly positive and strictly inferior to this limit.
#
# Limited to +2<<62-1+ positive integers, as Ruby is able to represent such numbers "inline",
# inside a +VALUE+ scalar, thus not requiring memory allocation.
#
# The range of IDs also has to consider portability across different languages and platforms.
#
# source://ddtrace//lib/datadog/tracing/utils.rb#20
Datadog::Tracing::Utils::RUBY_MAX_ID = T.let(T.unsafe(nil), Integer)

# The module handles bitwise operation for trace id
#
# source://ddtrace//lib/datadog/tracing/utils.rb#51
module Datadog::Tracing::Utils::TraceId
  private

  # source://ddtrace//lib/datadog/tracing/utils.rb#77
  def concatenate(high_order, low_order); end

  # Format for generating 128 bits trace id =>
  # - 32-bits : seconds since Epoch
  # - 32-bits : set to zero,
  # - 64 bits : random 64-bits
  #
  # source://ddtrace//lib/datadog/tracing/utils.rb#60
  def next_id; end

  # source://ddtrace//lib/datadog/tracing/utils.rb#69
  def to_high_order(trace_id); end

  # source://ddtrace//lib/datadog/tracing/utils.rb#73
  def to_low_order(trace_id); end

  class << self
    # source://ddtrace//lib/datadog/tracing/utils.rb#77
    def concatenate(high_order, low_order); end

    # Format for generating 128 bits trace id =>
    # - 32-bits : seconds since Epoch
    # - 32-bits : set to zero,
    # - 64 bits : random 64-bits
    #
    # source://ddtrace//lib/datadog/tracing/utils.rb#60
    def next_id; end

    # source://ddtrace//lib/datadog/tracing/utils.rb#69
    def to_high_order(trace_id); end

    # source://ddtrace//lib/datadog/tracing/utils.rb#73
    def to_low_order(trace_id); end
  end
end

# source://ddtrace//lib/datadog/tracing/utils.rb#52
Datadog::Tracing::Utils::TraceId::MAX = T.let(T.unsafe(nil), Integer)

# source://ddtrace//lib/datadog/tracing/workers.rb#6
module Datadog::Tracing::Workers; end

# Asynchronous worker that executes a +Send()+ operation after given
# seconds. Under the hood, it uses +Concurrent::TimerTask+ so that the thread
# will perform a task at regular intervals. The thread can be stopped
# with the +stop()+ method and can start with the +start()+ method.
#
# source://ddtrace//lib/datadog/tracing/workers.rb#11
class Datadog::Tracing::Workers::AsyncTransport
  # @return [AsyncTransport] a new instance of AsyncTransport
  #
  # source://ddtrace//lib/datadog/tracing/workers.rb#22
  def initialize(options = T.unsafe(nil)); end

  # Callback function that process traces and executes the +send_traces()+ method.
  #
  # source://ddtrace//lib/datadog/tracing/workers.rb#45
  def callback_traces; end

  # Enqueue an item in the trace internal buffer. This operation is thread-safe
  # because uses the +TraceBuffer+ data structure.
  #
  # source://ddtrace//lib/datadog/tracing/workers.rb#97
  def enqueue_trace(trace); end

  # Callback function that process traces and executes the +send_traces()+ method.
  #
  # source://ddtrace//lib/datadog/tracing/workers.rb#45
  def flush_data; end

  # Block until executor shutdown is complete or until timeout seconds have passed.
  #
  # source://ddtrace//lib/datadog/tracing/workers.rb#91
  def join; end

  # Start the timer execution.
  #
  # source://ddtrace//lib/datadog/tracing/workers.rb#63
  def start; end

  # Closes all available queues and waits for the trace buffer to flush
  #
  # source://ddtrace//lib/datadog/tracing/workers.rb#77
  def stop; end

  # Returns the value of attribute trace_buffer.
  #
  # source://ddtrace//lib/datadog/tracing/workers.rb#19
  def trace_buffer; end

  private

  # source://ddtrace//lib/datadog/tracing/workers.rb#107
  def perform; end
end

# source://ddtrace//lib/datadog/tracing/workers.rb#16
Datadog::Tracing::Workers::AsyncTransport::BACK_OFF_MAX = T.let(T.unsafe(nil), Integer)

# source://ddtrace//lib/datadog/tracing/workers.rb#15
Datadog::Tracing::Workers::AsyncTransport::BACK_OFF_RATIO = T.let(T.unsafe(nil), Float)

# source://ddtrace//lib/datadog/tracing/workers.rb#12
Datadog::Tracing::Workers::AsyncTransport::DEFAULT_BUFFER_MAX_SIZE = T.let(T.unsafe(nil), Integer)

# source://ddtrace//lib/datadog/tracing/workers.rb#13
Datadog::Tracing::Workers::AsyncTransport::DEFAULT_FLUSH_INTERVAL = T.let(T.unsafe(nil), Integer)

# source://ddtrace//lib/datadog/tracing/workers.rb#14
Datadog::Tracing::Workers::AsyncTransport::DEFAULT_TIMEOUT = T.let(T.unsafe(nil), Integer)

# source://ddtrace//lib/datadog/tracing/workers.rb#17
Datadog::Tracing::Workers::AsyncTransport::SHUTDOWN_TIMEOUT = T.let(T.unsafe(nil), Integer)

# Processor that sends traces and metadata to the agent
# DEV: Our goal is for {Datadog::Tracing::Workers::TraceWriter} to replace this class in the future
#
# source://ddtrace//lib/datadog/tracing/writer.rb#12
class Datadog::Tracing::Writer
  # @return [Writer] a new instance of Writer
  #
  # source://ddtrace//lib/datadog/tracing/writer.rb#18
  def initialize(options = T.unsafe(nil)); end

  # Returns the value of attribute events.
  #
  # source://ddtrace//lib/datadog/tracing/writer.rb#13
  def events; end

  # flush spans to the trace-agent, handles spans only
  #
  # source://ddtrace//lib/datadog/tracing/writer.rb#106
  def send_spans(traces, transport); end

  # Explicitly starts the {Writer}'s internal worker.
  #
  # The {Writer} is also automatically started when necessary during calls to {.write}.
  #
  # source://ddtrace//lib/datadog/tracing/writer.rb#53
  def start; end

  # stats returns a dictionary of stats about the writer.
  #
  # source://ddtrace//lib/datadog/tracing/writer.rb#150
  def stats; end

  # Gracefully shuts down this writer.
  #
  # Once stopped methods calls won't fail, but
  # no internal work will be performed.
  #
  # It is not possible to restart a stopped writer instance.
  #
  # source://ddtrace//lib/datadog/tracing/writer.rb#87
  def stop; end

  # Returns the value of attribute transport.
  #
  # source://ddtrace//lib/datadog/tracing/writer.rb#13
  def transport; end

  # Returns the value of attribute worker.
  #
  # source://ddtrace//lib/datadog/tracing/writer.rb#13
  def worker; end

  # enqueue the trace for submission to the API
  #
  # source://ddtrace//lib/datadog/tracing/writer.rb#124
  def write(trace); end

  private

  # source://ddtrace//lib/datadog/tracing/writer.rb#177
  def reset_stats!; end

  # spawns a worker for spans; they share the same transport which is thread-safe
  #
  # source://ddtrace//lib/datadog/tracing/writer.rb#69
  def start_worker; end

  # source://ddtrace//lib/datadog/tracing/writer.rb#91
  def stop_worker; end
end

# Callback behavior
#
# source://ddtrace//lib/datadog/tracing/writer.rb#158
class Datadog::Tracing::Writer::Events
  # @return [Events] a new instance of Events
  #
  # source://ddtrace//lib/datadog/tracing/writer.rb#162
  def initialize; end

  # Returns the value of attribute after_send.
  #
  # source://ddtrace//lib/datadog/tracing/writer.rb#159
  def after_send; end
end

# Triggered after the writer sends traces through the transport.
# Provides the Writer instance and transport response list to the callback.
#
# source://ddtrace//lib/datadog/tracing/writer.rb#168
class Datadog::Tracing::Writer::Events::AfterSend < ::Datadog::Tracing::Event
  # @return [AfterSend] a new instance of AfterSend
  #
  # source://ddtrace//lib/datadog/tracing/writer.rb#169
  def initialize; end
end

# source://ddtrace//lib/ddtrace/transport/ext.rb#4
module Datadog::Transport; end

# source://ddtrace//lib/ddtrace/transport/ext.rb#6
module Datadog::Transport::Ext; end

# source://ddtrace//lib/ddtrace/transport/ext.rb#8
module Datadog::Transport::Ext::HTTP; end

# DEV: Rename to simply `:http`, as Net::HTTP is an implementation detail.
#
# source://ddtrace//lib/ddtrace/transport/ext.rb#9
Datadog::Transport::Ext::HTTP::ADAPTER = T.let(T.unsafe(nil), Symbol)

# source://ddtrace//lib/ddtrace/transport/ext.rb#10
Datadog::Transport::Ext::HTTP::DEFAULT_HOST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/ddtrace/transport/ext.rb#11
Datadog::Transport::Ext::HTTP::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)

# Tells agent that `_dd.top_level` metrics have been set by the tracer.
# The agent will not calculate top-level spans but instead trust the tracer tagging.
#
# This prevents partially flushed traces being mistakenly marked as top-level.
#
# Setting this header to any non-empty value enables this feature.
#
# source://ddtrace//lib/ddtrace/transport/ext.rb#21
Datadog::Transport::Ext::HTTP::HEADER_CLIENT_COMPUTED_TOP_LEVEL = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/ddtrace/transport/ext.rb#13
Datadog::Transport::Ext::HTTP::HEADER_CONTAINER_ID = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/ddtrace/transport/ext.rb#14
Datadog::Transport::Ext::HTTP::HEADER_DD_API_KEY = T.let(T.unsafe(nil), String)

# Header that prevents the Net::HTTP integration from tracing internal trace requests.
# Set it to any value to skip tracing.
#
# source://ddtrace//lib/ddtrace/transport/ext.rb#29
Datadog::Transport::Ext::HTTP::HEADER_DD_INTERNAL_UNTRACED_REQUEST = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/ddtrace/transport/ext.rb#22
Datadog::Transport::Ext::HTTP::HEADER_META_LANG = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/ddtrace/transport/ext.rb#24
Datadog::Transport::Ext::HTTP::HEADER_META_LANG_INTERPRETER = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/ddtrace/transport/ext.rb#23
Datadog::Transport::Ext::HTTP::HEADER_META_LANG_VERSION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/ddtrace/transport/ext.rb#25
Datadog::Transport::Ext::HTTP::HEADER_META_TRACER_VERSION = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/ddtrace/transport/ext.rb#33
module Datadog::Transport::Ext::Test; end

# source://ddtrace//lib/ddtrace/transport/ext.rb#34
Datadog::Transport::Ext::Test::ADAPTER = T.let(T.unsafe(nil), Symbol)

# source://ddtrace//lib/ddtrace/transport/ext.rb#38
module Datadog::Transport::Ext::UnixSocket; end

# source://ddtrace//lib/ddtrace/transport/ext.rb#39
Datadog::Transport::Ext::UnixSocket::ADAPTER = T.let(T.unsafe(nil), Symbol)

# source://ddtrace//lib/ddtrace/transport/ext.rb#40
Datadog::Transport::Ext::UnixSocket::DEFAULT_PATH = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/ddtrace/transport/ext.rb#41
Datadog::Transport::Ext::UnixSocket::DEFAULT_TIMEOUT_SECONDS = T.let(T.unsafe(nil), Integer)

# Namespace for HTTP transport components
#
# source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#6
module Datadog::Transport::HTTP
  private

  # Builds a new Transport::HTTP::Client with default settings
  # Pass a block to override any settings.
  #
  # source://ddtrace//lib/ddtrace/transport/http.rb#38
  def default(agent_settings: T.unsafe(nil), **options); end

  # source://ddtrace//lib/ddtrace/transport/http.rb#80
  def default_adapter; end

  # source://ddtrace//lib/ddtrace/transport/http.rb#66
  def default_headers; end

  # source://ddtrace//lib/ddtrace/transport/http.rb#84
  def default_hostname(logger: T.unsafe(nil)); end

  # source://ddtrace//lib/ddtrace/transport/http.rb#93
  def default_port(logger: T.unsafe(nil)); end

  # source://ddtrace//lib/ddtrace/transport/http.rb#102
  def default_url(logger: T.unsafe(nil)); end

  # Builds a new Transport::HTTP::Client
  #
  # source://ddtrace//lib/ddtrace/transport/http.rb#32
  def new(&block); end

  class << self
    # Builds a new Transport::HTTP::Client with default settings
    # Pass a block to override any settings.
    #
    # source://ddtrace//lib/ddtrace/transport/http.rb#38
    def default(agent_settings: T.unsafe(nil), **options); end

    # source://ddtrace//lib/ddtrace/transport/http.rb#80
    def default_adapter; end

    # source://ddtrace//lib/ddtrace/transport/http.rb#66
    def default_headers; end

    # source://ddtrace//lib/ddtrace/transport/http.rb#84
    def default_hostname(logger: T.unsafe(nil)); end

    # source://ddtrace//lib/ddtrace/transport/http.rb#93
    def default_port(logger: T.unsafe(nil)); end

    # source://ddtrace//lib/ddtrace/transport/http.rb#102
    def default_url(logger: T.unsafe(nil)); end

    # Builds a new Transport::HTTP::Client
    #
    # source://ddtrace//lib/ddtrace/transport/http.rb#32
    def new(&block); end
  end
end

# Namespace for API components
#
# source://ddtrace//lib/ddtrace/transport/http/api/fallbacks.rb#6
module Datadog::Transport::HTTP::API
  private

  # source://ddtrace//lib/ddtrace/transport/http/api.rb#19
  def defaults; end

  class << self
    # source://ddtrace//lib/ddtrace/transport/http/api.rb#19
    def defaults; end
  end
end

# Endpoint
#
# source://ddtrace//lib/ddtrace/transport/http/api/endpoint.rb#10
class Datadog::Transport::HTTP::API::Endpoint
  # @return [Endpoint] a new instance of Endpoint
  #
  # source://ddtrace//lib/ddtrace/transport/http/api/endpoint.rb#15
  def initialize(verb, path); end

  # @yield [env]
  #
  # source://ddtrace//lib/ddtrace/transport/http/api/endpoint.rb#20
  def call(env); end

  # Returns the value of attribute path.
  #
  # source://ddtrace//lib/ddtrace/transport/http/api/endpoint.rb#11
  def path; end

  # Returns the value of attribute verb.
  #
  # source://ddtrace//lib/ddtrace/transport/http/api/endpoint.rb#11
  def verb; end
end

# Extension for Map with adds fallback versions.
#
# source://ddtrace//lib/ddtrace/transport/http/api/fallbacks.rb#8
module Datadog::Transport::HTTP::API::Fallbacks
  # source://ddtrace//lib/ddtrace/transport/http/api/fallbacks.rb#17
  def add_fallbacks!(fallbacks); end

  # source://ddtrace//lib/ddtrace/transport/http/api/fallbacks.rb#9
  def fallbacks; end

  # source://ddtrace//lib/ddtrace/transport/http/api/fallbacks.rb#13
  def with_fallbacks(fallbacks); end
end

# An API configured with adapter and routes
#
# source://ddtrace//lib/ddtrace/transport/http/api/instance.rb#8
class Datadog::Transport::HTTP::API::Instance
  include ::Datadog::Transport::HTTP::Traces::API::Instance

  # @return [Instance] a new instance of Instance
  #
  # source://ddtrace//lib/ddtrace/transport/http/api/instance.rb#14
  def initialize(spec, adapter, options = T.unsafe(nil)); end

  # Returns the value of attribute adapter.
  #
  # source://ddtrace//lib/ddtrace/transport/http/api/instance.rb#9
  def adapter; end

  # source://ddtrace//lib/ddtrace/transport/http/api/instance.rb#24
  def call(env); end

  # source://ddtrace//lib/ddtrace/transport/http/api/instance.rb#20
  def encoder; end

  # Returns the value of attribute headers.
  #
  # source://ddtrace//lib/ddtrace/transport/http/api/instance.rb#9
  def headers; end

  # Returns the value of attribute spec.
  #
  # source://ddtrace//lib/ddtrace/transport/http/api/instance.rb#9
  def spec; end
end

# A mapping of API version => API Routes/Instance
#
# source://ddtrace//lib/ddtrace/transport/http/api/map.rb#10
class Datadog::Transport::HTTP::API::Map < ::Hash
  include ::Datadog::Transport::HTTP::API::Fallbacks
end

# Specification for an HTTP API
# Defines behaviors without specific configuration details.
#
# source://ddtrace//lib/ddtrace/transport/http/api/spec.rb#9
class Datadog::Transport::HTTP::API::Spec
  include ::Datadog::Transport::HTTP::Traces::API::Spec

  # @return [Spec] a new instance of Spec
  # @yield [_self]
  # @yieldparam _self [Datadog::Transport::HTTP::API::Spec] the object that the method was called on
  #
  # source://ddtrace//lib/ddtrace/transport/http/api/spec.rb#10
  def initialize; end
end

# source://ddtrace//lib/ddtrace/transport/http/api.rb#15
Datadog::Transport::HTTP::API::V3 = T.let(T.unsafe(nil), String)

# Default API versions
#
# source://ddtrace//lib/ddtrace/transport/http/api.rb#14
Datadog::Transport::HTTP::API::V4 = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#7
module Datadog::Transport::HTTP::Adapters; end

# Adapter for Net::HTTP
#
# source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#9
class Datadog::Transport::HTTP::Adapters::Net
  # @deprecated Positional parameters are deprecated. Use named parameters instead.
  # @return [Net] a new instance of Net
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#20
  def initialize(hostname = T.unsafe(nil), port = T.unsafe(nil), **options); end

  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#48
  def call(env); end

  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#56
  def get(env); end

  # Returns the value of attribute hostname.
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#10
  def hostname; end

  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#36
  def open(&block); end

  # Returns the value of attribute port.
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#10
  def port; end

  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#68
  def post(env); end

  # Returns the value of attribute ssl.
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#10
  def ssl; end

  # Returns the value of attribute timeout.
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#10
  def timeout; end

  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#91
  def url; end

  class << self
    # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#27
    def build(agent_settings); end
  end
end

# in seconds
#
# source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#17
Datadog::Transport::HTTP::Adapters::Net::DEFAULT_TIMEOUT = T.let(T.unsafe(nil), Integer)

# A wrapped Net::HTTP response that implements the Transport::Response interface
#
# source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#109
class Datadog::Transport::HTTP::Adapters::Net::Response
  include ::Datadog::Transport::Response

  # @return [Response] a new instance of Response
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#114
  def initialize(http_response); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#148
  def client_error?; end

  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#124
  def code; end

  # Returns the value of attribute http_response.
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#112
  def http_response; end

  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#160
  def inspect; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#142
  def not_found?; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#130
  def ok?; end

  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#118
  def payload; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#154
  def server_error?; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#136
  def unsupported?; end
end

# Raised when called with an unknown HTTP method
#
# source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#96
class Datadog::Transport::HTTP::Adapters::Net::UnknownHTTPMethod < ::StandardError
  # @return [UnknownHTTPMethod] a new instance of UnknownHTTPMethod
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#99
  def initialize(verb); end

  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#103
  def message; end

  # Returns the value of attribute verb.
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/net.rb#97
  def verb; end
end

# List of available adapters
#
# source://ddtrace//lib/ddtrace/transport/http/adapters/registry.rb#8
class Datadog::Transport::HTTP::Adapters::Registry
  # @return [Registry] a new instance of Registry
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/registry.rb#9
  def initialize; end

  # source://ddtrace//lib/ddtrace/transport/http/adapters/registry.rb#13
  def get(name); end

  # source://ddtrace//lib/ddtrace/transport/http/adapters/registry.rb#17
  def set(klass, name = T.unsafe(nil)); end
end

# Adapter for testing
#
# source://ddtrace//lib/ddtrace/transport/http/adapters/test.rb#8
class Datadog::Transport::HTTP::Adapters::Test
  # @deprecated Positional parameters are deprecated. Use named parameters instead.
  # @param buffer [Array] an optional array that will capture all spans sent to this adapter, defaults to +nil+
  # @return [Test] a new instance of Test
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/test.rb#15
  def initialize(buffer = T.unsafe(nil), **options); end

  # source://ddtrace//lib/ddtrace/transport/http/adapters/test.rb#30
  def add_request(env); end

  # Returns the value of attribute buffer.
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/test.rb#9
  def buffer; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/test.rb#26
  def buffer?; end

  # source://ddtrace//lib/ddtrace/transport/http/adapters/test.rb#21
  def call(env); end

  # source://ddtrace//lib/ddtrace/transport/http/adapters/test.rb#34
  def set_status!(status); end

  # Returns the value of attribute status.
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/test.rb#9
  def status; end

  # source://ddtrace//lib/ddtrace/transport/http/adapters/test.rb#38
  def url; end
end

# Response for test adapter
#
# source://ddtrace//lib/ddtrace/transport/http/adapters/test.rb#41
class Datadog::Transport::HTTP::Adapters::Test::Response
  include ::Datadog::Transport::Response

  # @return [Response] a new instance of Response
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/test.rb#48
  def initialize(code, body = T.unsafe(nil)); end

  # Returns the value of attribute body.
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/test.rb#44
  def body; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/test.rb#69
  def client_error?; end

  # Returns the value of attribute code.
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/test.rb#44
  def code; end

  # source://ddtrace//lib/ddtrace/transport/http/adapters/test.rb#77
  def inspect; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/test.rb#65
  def not_found?; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/test.rb#57
  def ok?; end

  # source://ddtrace//lib/ddtrace/transport/http/adapters/test.rb#53
  def payload; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/test.rb#73
  def server_error?; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/test.rb#61
  def unsupported?; end
end

# Adapter for Unix sockets
#
# source://ddtrace//lib/ddtrace/transport/http/adapters/unix_socket.rb#10
class Datadog::Transport::HTTP::Adapters::UnixSocket < ::Datadog::Transport::HTTP::Adapters::Net
  # @deprecated Positional parameters are deprecated. Use named parameters instead.
  # @return [UnixSocket] a new instance of UnixSocket
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/unix_socket.rb#18
  def initialize(uds_path = T.unsafe(nil), **options); end

  # Returns the value of attribute filepath.
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/unix_socket.rb#11
  def filepath; end

  # source://ddtrace//lib/ddtrace/transport/http/adapters/unix_socket.rb#30
  def open(&block); end

  # Returns the value of attribute timeout.
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/unix_socket.rb#11
  def timeout; end

  # Returns the value of attribute filepath.
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/unix_socket.rb#11
  def uds_path; end

  # source://ddtrace//lib/ddtrace/transport/http/adapters/unix_socket.rb#41
  def url; end

  class << self
    # source://ddtrace//lib/ddtrace/transport/http/adapters/unix_socket.rb#23
    def build(agent_settings); end
  end
end

# Re-implements Net:HTTP with underlying Unix socket
#
# source://ddtrace//lib/ddtrace/transport/http/adapters/unix_socket.rb#46
class Datadog::Transport::HTTP::Adapters::UnixSocket::HTTP < ::Net::HTTP
  # @return [HTTP] a new instance of HTTP
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/unix_socket.rb#55
  def initialize(uds_path, options = T.unsafe(nil)); end

  # source://ddtrace//lib/ddtrace/transport/http/adapters/unix_socket.rb#63
  def connect; end

  # Returns the value of attribute filepath.
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/unix_socket.rb#49
  def filepath; end

  # Returns the value of attribute filepath.
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/unix_socket.rb#49
  def uds_path; end

  # Returns the value of attribute unix_socket.
  #
  # source://ddtrace//lib/ddtrace/transport/http/adapters/unix_socket.rb#49
  def unix_socket; end
end

# source://ddtrace//lib/ddtrace/transport/http/adapters/unix_socket.rb#47
Datadog::Transport::HTTP::Adapters::UnixSocket::HTTP::DEFAULT_TIMEOUT = T.let(T.unsafe(nil), Integer)

# Builds new instances of Transport::HTTP::Client
#
# source://ddtrace//lib/ddtrace/transport/http/builder.rb#11
class Datadog::Transport::HTTP::Builder
  # @return [Builder] a new instance of Builder
  # @yield [_self]
  # @yieldparam _self [Datadog::Transport::HTTP::Builder] the object that the method was called on
  #
  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#21
  def initialize; end

  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#36
  def adapter(config, *args, **kwargs); end

  # Adds a new API to the client
  # Valid options:
  #  - :adapter
  #  - :default
  #  - :fallback
  #  - :headers
  #
  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#63
  def api(key, spec, options = T.unsafe(nil)); end

  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#117
  def api_instance_class; end

  # Returns the value of attribute api_options.
  #
  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#14
  def api_options; end

  # Returns the value of attribute apis.
  #
  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#14
  def apis; end

  # Returns the value of attribute default_adapter.
  #
  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#14
  def default_adapter; end

  # Returns the value of attribute default_api.
  #
  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#14
  def default_api; end

  # @raise [UnknownApiError]
  #
  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#76
  def default_api=(key); end

  # Returns the value of attribute default_headers.
  #
  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#14
  def default_headers; end

  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#53
  def headers(values = T.unsafe(nil)); end

  # @raise [NoApisError]
  #
  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#89
  def to_api_instances; end

  # @raise [NoDefaultApiError]
  #
  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#82
  def to_transport; end
end

# Raised when an adapter cannot be resolved for an API instance.
#
# source://ddtrace//lib/ddtrace/transport/http/builder.rb#148
class Datadog::Transport::HTTP::Builder::NoAdapterForApiError < ::StandardError
  # @return [NoAdapterForApiError] a new instance of NoAdapterForApiError
  #
  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#151
  def initialize(key); end

  # Returns the value of attribute key.
  #
  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#149
  def key; end

  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#155
  def message; end
end

# Raised when built without defining APIs.
#
# source://ddtrace//lib/ddtrace/transport/http/builder.rb#161
class Datadog::Transport::HTTP::Builder::NoApisError < ::StandardError
  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#162
  def message; end
end

# Raised when client built without defining a default API.
#
# source://ddtrace//lib/ddtrace/transport/http/builder.rb#168
class Datadog::Transport::HTTP::Builder::NoDefaultApiError < ::StandardError
  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#169
  def message; end
end

# source://ddtrace//lib/ddtrace/transport/http/builder.rb#12
Datadog::Transport::HTTP::Builder::REGISTRY = T.let(T.unsafe(nil), Datadog::Transport::HTTP::Adapters::Registry)

# Raised when the identifier cannot be matched to an adapter.
#
# source://ddtrace//lib/ddtrace/transport/http/builder.rb#135
class Datadog::Transport::HTTP::Builder::UnknownAdapterError < ::StandardError
  # @return [UnknownAdapterError] a new instance of UnknownAdapterError
  #
  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#138
  def initialize(type); end

  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#142
  def message; end

  # Returns the value of attribute type.
  #
  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#136
  def type; end
end

# Raised when the API key does not match known APIs.
#
# source://ddtrace//lib/ddtrace/transport/http/builder.rb#122
class Datadog::Transport::HTTP::Builder::UnknownApiError < ::StandardError
  # @return [UnknownApiError] a new instance of UnknownApiError
  #
  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#125
  def initialize(key); end

  # Returns the value of attribute key.
  #
  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#123
  def key; end

  # source://ddtrace//lib/ddtrace/transport/http/builder.rb#129
  def message; end
end

# Routes, encodes, and sends tracer data to the trace agent via HTTP.
#
# source://ddtrace//lib/ddtrace/transport/http/client.rb#8
class Datadog::Transport::HTTP::Client
  include ::Datadog::Transport::HTTP::Statistics
  include ::Datadog::Transport::Statistics
  include ::Datadog::Transport::HTTP::Statistics::InstanceMethods
  include ::Datadog::Transport::HTTP::Traces::Client

  # @return [Client] a new instance of Client
  #
  # source://ddtrace//lib/ddtrace/transport/http/client.rb#13
  def initialize(api); end

  # Returns the value of attribute api.
  #
  # source://ddtrace//lib/ddtrace/transport/http/client.rb#11
  def api; end

  # source://ddtrace//lib/ddtrace/transport/http/client.rb#46
  def build_env(request); end

  # source://ddtrace//lib/ddtrace/transport/http/client.rb#17
  def send_request(request, &block); end
end

# NOTE: Due to... legacy reasons... This class likes having a default `AgentSettings` instance to fall back to.
# Because we generate this instance with an empty instance of `Settings`, the resulting `AgentSettings` below
# represents only settings specified via environment variables + the usual defaults.
#
# DO NOT USE THIS IN NEW CODE, as it ignores any settings specified by users via `Datadog.configure`.
#
# source://ddtrace//lib/ddtrace/transport/http.rb#24
Datadog::Transport::HTTP::DO_NOT_USE_ENVIRONMENT_AGENT_SETTINGS = T.let(T.unsafe(nil), Datadog::Core::Configuration::AgentSettingsResolver::AgentSettings)

# Data structure for an HTTP request
#
# source://ddtrace//lib/ddtrace/transport/http/env.rb#7
class Datadog::Transport::HTTP::Env < ::Hash
  # @return [Env] a new instance of Env
  #
  # source://ddtrace//lib/ddtrace/transport/http/env.rb#11
  def initialize(request, options = T.unsafe(nil)); end

  # source://ddtrace//lib/ddtrace/transport/http/env.rb#32
  def body; end

  # source://ddtrace//lib/ddtrace/transport/http/env.rb#36
  def body=(value); end

  # source://ddtrace//lib/ddtrace/transport/http/env.rb#48
  def form; end

  # source://ddtrace//lib/ddtrace/transport/http/env.rb#52
  def form=(value); end

  # source://ddtrace//lib/ddtrace/transport/http/env.rb#40
  def headers; end

  # source://ddtrace//lib/ddtrace/transport/http/env.rb#44
  def headers=(value); end

  # source://ddtrace//lib/ddtrace/transport/http/env.rb#24
  def path; end

  # source://ddtrace//lib/ddtrace/transport/http/env.rb#28
  def path=(value); end

  # Returns the value of attribute request.
  #
  # source://ddtrace//lib/ddtrace/transport/http/env.rb#8
  def request; end

  # source://ddtrace//lib/ddtrace/transport/http/env.rb#16
  def verb; end

  # source://ddtrace//lib/ddtrace/transport/http/env.rb#20
  def verb=(value); end
end

# Wraps an HTTP response from an adapter.
#
# Used by endpoints to wrap responses from adapters with
# fields or behavior that's specific to that endpoint.
#
# source://ddtrace//lib/ddtrace/transport/http/response.rb#12
module Datadog::Transport::HTTP::Response
  # source://ddtrace//lib/ddtrace/transport/http/response.rb#13
  def initialize(http_response); end

  # source://ddtrace//lib/ddtrace/transport/http/response.rb#43
  def client_error?; end

  # source://ddtrace//lib/ddtrace/transport/http/response.rb#52
  def code; end

  # source://ddtrace//lib/ddtrace/transport/http/response.rb#23
  def internal_error?; end

  # source://ddtrace//lib/ddtrace/transport/http/response.rb#38
  def not_found?; end

  # source://ddtrace//lib/ddtrace/transport/http/response.rb#33
  def ok?; end

  # source://ddtrace//lib/ddtrace/transport/http/response.rb#18
  def payload; end

  # source://ddtrace//lib/ddtrace/transport/http/response.rb#48
  def server_error?; end

  # source://ddtrace//lib/ddtrace/transport/http/response.rb#28
  def unsupported?; end
end

# Tracks statistics for HTTP transports
#
# source://ddtrace//lib/ddtrace/transport/http/statistics.rb#7
module Datadog::Transport::HTTP::Statistics
  include ::Datadog::Transport::Statistics
  include ::Datadog::Transport::HTTP::Statistics::InstanceMethods

  class << self
    # @private
    #
    # source://ddtrace//lib/ddtrace/transport/http/statistics.rb#8
    def included(base); end
  end
end

# Instance methods for HTTP statistics
#
# source://ddtrace//lib/ddtrace/transport/http/statistics.rb#14
module Datadog::Transport::HTTP::Statistics::InstanceMethods
  # Decorate metrics for HTTP responses
  #
  # source://ddtrace//lib/ddtrace/transport/http/statistics.rb#16
  def metrics_for_response(response); end

  private

  # source://ddtrace//lib/ddtrace/transport/http/statistics.rb#32
  def metrics_tag_value(status_code); end
end

# The most common status code on a healthy tracer
#
# source://ddtrace//lib/ddtrace/transport/http/statistics.rb#30
Datadog::Transport::HTTP::Statistics::InstanceMethods::STATUS_CODE_200 = T.let(T.unsafe(nil), String)

# HTTP transport behavior for traces
#
# source://ddtrace//lib/ddtrace/transport/http/traces.rb#13
module Datadog::Transport::HTTP::Traces; end

# source://ddtrace//lib/ddtrace/transport/http/traces.rb#35
module Datadog::Transport::HTTP::Traces::API; end

# Endpoint for submitting trace data
#
# source://ddtrace//lib/ddtrace/transport/http/traces.rb#93
class Datadog::Transport::HTTP::Traces::API::Endpoint < ::Datadog::Transport::HTTP::API::Endpoint
  # @return [Endpoint] a new instance of Endpoint
  #
  # source://ddtrace//lib/ddtrace/transport/http/traces.rb#101
  def initialize(path, encoder, options = T.unsafe(nil)); end

  # source://ddtrace//lib/ddtrace/transport/http/traces.rb#111
  def call(env, &block); end

  # Returns the value of attribute encoder.
  #
  # source://ddtrace//lib/ddtrace/transport/http/traces.rb#98
  def encoder; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/ddtrace/transport/http/traces.rb#107
  def service_rates?; end
end

# source://ddtrace//lib/ddtrace/transport/http/traces.rb#94
Datadog::Transport::HTTP::Traces::API::Endpoint::HEADER_CONTENT_TYPE = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/ddtrace/transport/http/traces.rb#95
Datadog::Transport::HTTP::Traces::API::Endpoint::HEADER_TRACE_COUNT = T.let(T.unsafe(nil), String)

# source://ddtrace//lib/ddtrace/transport/http/traces.rb#96
Datadog::Transport::HTTP::Traces::API::Endpoint::SERVICE_RATE_KEY = T.let(T.unsafe(nil), String)

# Extensions for HTTP API Instance
#
# source://ddtrace//lib/ddtrace/transport/http/traces.rb#69
module Datadog::Transport::HTTP::Traces::API::Instance
  # @raise [TracesNotSupportedError]
  #
  # source://ddtrace//lib/ddtrace/transport/http/traces.rb#70
  def send_traces(env); end
end

# Raised when traces sent to API that does not support traces
#
# source://ddtrace//lib/ddtrace/transport/http/traces.rb#79
class Datadog::Transport::HTTP::Traces::API::Instance::TracesNotSupportedError < ::StandardError
  # @return [TracesNotSupportedError] a new instance of TracesNotSupportedError
  #
  # source://ddtrace//lib/ddtrace/transport/http/traces.rb#82
  def initialize(spec); end

  # source://ddtrace//lib/ddtrace/transport/http/traces.rb#86
  def message; end

  # Returns the value of attribute spec.
  #
  # source://ddtrace//lib/ddtrace/transport/http/traces.rb#80
  def spec; end
end

# Extensions for HTTP API Spec
#
# source://ddtrace//lib/ddtrace/transport/http/traces.rb#37
module Datadog::Transport::HTTP::Traces::API::Spec
  # source://ddtrace//lib/ddtrace/transport/http/traces.rb#50
  def encoder; end

  # @raise [NoTraceEndpointDefinedError]
  #
  # source://ddtrace//lib/ddtrace/transport/http/traces.rb#44
  def send_traces(env, &block); end

  # Returns the value of attribute traces.
  #
  # source://ddtrace//lib/ddtrace/transport/http/traces.rb#38
  def traces; end

  # source://ddtrace//lib/ddtrace/transport/http/traces.rb#40
  def traces=(endpoint); end
end

# Raised when traces sent but no traces endpoint is defined
#
# source://ddtrace//lib/ddtrace/transport/http/traces.rb#55
class Datadog::Transport::HTTP::Traces::API::Spec::NoTraceEndpointDefinedError < ::StandardError
  # @return [NoTraceEndpointDefinedError] a new instance of NoTraceEndpointDefinedError
  #
  # source://ddtrace//lib/ddtrace/transport/http/traces.rb#58
  def initialize(spec); end

  # source://ddtrace//lib/ddtrace/transport/http/traces.rb#62
  def message; end

  # Returns the value of attribute spec.
  #
  # source://ddtrace//lib/ddtrace/transport/http/traces.rb#56
  def spec; end
end

# Extensions for HTTP client
#
# source://ddtrace//lib/ddtrace/transport/http/traces.rb#27
module Datadog::Transport::HTTP::Traces::Client
  # source://ddtrace//lib/ddtrace/transport/http/traces.rb#28
  def send_traces_payload(request); end
end

# Response from HTTP transport for traces
#
# source://ddtrace//lib/ddtrace/transport/http/traces.rb#15
class Datadog::Transport::HTTP::Traces::Response
  include ::Datadog::Transport::HTTP::Response
  include ::Datadog::Transport::Traces::Response

  # @return [Response] a new instance of Response
  #
  # source://ddtrace//lib/ddtrace/transport/http/traces.rb#19
  def initialize(http_response, options = T.unsafe(nil)); end
end

# A generic error response for internal errors
#
# source://ddtrace//lib/ddtrace/transport/response.rb#42
class Datadog::Transport::InternalErrorResponse
  include ::Datadog::Transport::Response

  # @return [InternalErrorResponse] a new instance of InternalErrorResponse
  #
  # source://ddtrace//lib/ddtrace/transport/response.rb#47
  def initialize(error); end

  # Returns the value of attribute error.
  #
  # source://ddtrace//lib/ddtrace/transport/response.rb#45
  def error; end

  # source://ddtrace//lib/ddtrace/transport/response.rb#55
  def inspect; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/ddtrace/transport/response.rb#51
  def internal_error?; end
end

# Data transfer object for generic data
#
# @abstract
#
# source://ddtrace//lib/ddtrace/transport/parcel.rb#7
module Datadog::Transport::Parcel
  # source://ddtrace//lib/ddtrace/transport/parcel.rb#11
  def initialize(data); end

  # Returns the value of attribute data.
  #
  # source://ddtrace//lib/ddtrace/transport/parcel.rb#8
  def data; end

  # @raise [NotImplementedError]
  #
  # source://ddtrace//lib/ddtrace/transport/parcel.rb#15
  def encode_with(encoder); end
end

# Defines request for transport operations
#
# source://ddtrace//lib/ddtrace/transport/request.rb#6
class Datadog::Transport::Request
  # @return [Request] a new instance of Request
  #
  # source://ddtrace//lib/ddtrace/transport/request.rb#10
  def initialize(parcel = T.unsafe(nil)); end

  # Returns the value of attribute parcel.
  #
  # source://ddtrace//lib/ddtrace/transport/request.rb#7
  def parcel; end
end

# Defines abstract response for transport operations
#
# source://ddtrace//lib/ddtrace/transport/response.rb#4
module Datadog::Transport::Response
  # @return [Boolean]
  #
  # source://ddtrace//lib/ddtrace/transport/response.rb#21
  def client_error?; end

  # source://ddtrace//lib/ddtrace/transport/response.rb#33
  def inspect; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/ddtrace/transport/response.rb#29
  def internal_error?; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/ddtrace/transport/response.rb#17
  def not_found?; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/ddtrace/transport/response.rb#9
  def ok?; end

  # source://ddtrace//lib/ddtrace/transport/response.rb#5
  def payload; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/ddtrace/transport/response.rb#25
  def server_error?; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/ddtrace/transport/response.rb#13
  def unsupported?; end
end

# Adds serialization functions to a {Datadog::Span}
#
# source://ddtrace//lib/ddtrace/transport/serializable_trace.rb#37
class Datadog::Transport::SerializableSpan
  # @return [SerializableSpan] a new instance of SerializableSpan
  #
  # source://ddtrace//lib/ddtrace/transport/serializable_trace.rb#41
  def initialize(span); end

  # Used for serialization
  #
  # @return [Integer] in nanoseconds since Epoch
  #
  # source://ddtrace//lib/ddtrace/transport/serializable_trace.rb#117
  def duration_nano(duration); end

  # Returns the value of attribute span.
  #
  # source://ddtrace//lib/ddtrace/transport/serializable_trace.rb#38
  def span; end

  # Used for serialization
  #
  # @return [Integer] in nanoseconds since Epoch
  #
  # source://ddtrace//lib/ddtrace/transport/serializable_trace.rb#107
  def time_nano(time); end

  # source://ddtrace//lib/ddtrace/transport/serializable_trace.rb#111
  def to_hash; end

  # JSON serializer interface.
  # Used by older version of the transport.
  #
  # source://ddtrace//lib/ddtrace/transport/serializable_trace.rb#101
  def to_json(*args); end

  # MessagePack serializer interface. Making this object
  # respond to `#to_msgpack` allows it to be automatically
  # serialized by MessagePack.
  #
  # This is more efficient than doing +MessagePack.pack(span.to_hash)+
  # as we don't have to create an intermediate Hash.
  #
  #
  # @param packer [MessagePack::Packer] serialization buffer, can be +nil+ with JRuby
  #
  # source://ddtrace//lib/ddtrace/transport/serializable_trace.rb#55
  def to_msgpack(packer = T.unsafe(nil)); end
end

# Adds serialization functions to a {Datadog::TraceSegment}
#
# source://ddtrace//lib/ddtrace/transport/serializable_trace.rb#8
class Datadog::Transport::SerializableTrace
  # @return [SerializableTrace] a new instance of SerializableTrace
  #
  # source://ddtrace//lib/ddtrace/transport/serializable_trace.rb#12
  def initialize(trace); end

  # JSON serializer interface.
  # Used by older version of the transport.
  #
  # source://ddtrace//lib/ddtrace/transport/serializable_trace.rb#31
  def to_json(*args); end

  # MessagePack serializer interface. Making this object
  # respond to `#to_msgpack` allows it to be automatically
  # serialized by MessagePack.
  #
  # This is more efficient than doing +MessagePack.pack(span.to_hash)+
  # as we don't have to create an intermediate Hash.
  #
  # @param packer [MessagePack::Packer] serialization buffer, can be +nil+ with JRuby
  #
  # source://ddtrace//lib/ddtrace/transport/serializable_trace.rb#24
  def to_msgpack(packer = T.unsafe(nil)); end

  # Returns the value of attribute trace.
  #
  # source://ddtrace//lib/ddtrace/transport/serializable_trace.rb#9
  def trace; end
end

# Tracks statistics for transports
#
# source://ddtrace//lib/ddtrace/transport/statistics.rb#9
module Datadog::Transport::Statistics
  # source://ddtrace//lib/ddtrace/transport/statistics.rb#48
  def metrics_for_exception(_exception); end

  # source://ddtrace//lib/ddtrace/transport/statistics.rb#31
  def metrics_for_response(response); end

  # source://ddtrace//lib/ddtrace/transport/statistics.rb#10
  def stats; end

  # source://ddtrace//lib/ddtrace/transport/statistics.rb#38
  def update_stats_from_exception!(exception); end

  # source://ddtrace//lib/ddtrace/transport/statistics.rb#14
  def update_stats_from_response!(response); end
end

# Stat counts
#
# source://ddtrace//lib/ddtrace/transport/statistics.rb#53
class Datadog::Transport::Statistics::Counts
  # @return [Counts] a new instance of Counts
  #
  # source://ddtrace//lib/ddtrace/transport/statistics.rb#61
  def initialize; end

  # Returns the value of attribute client_error.
  #
  # source://ddtrace//lib/ddtrace/transport/statistics.rb#54
  def client_error; end

  # Sets the attribute client_error
  #
  # @param value the value to set the attribute client_error to.
  #
  # source://ddtrace//lib/ddtrace/transport/statistics.rb#54
  def client_error=(_arg0); end

  # Returns the value of attribute consecutive_errors.
  #
  # source://ddtrace//lib/ddtrace/transport/statistics.rb#54
  def consecutive_errors; end

  # Sets the attribute consecutive_errors
  #
  # @param value the value to set the attribute consecutive_errors to.
  #
  # source://ddtrace//lib/ddtrace/transport/statistics.rb#54
  def consecutive_errors=(_arg0); end

  # Returns the value of attribute internal_error.
  #
  # source://ddtrace//lib/ddtrace/transport/statistics.rb#54
  def internal_error; end

  # Sets the attribute internal_error
  #
  # @param value the value to set the attribute internal_error to.
  #
  # source://ddtrace//lib/ddtrace/transport/statistics.rb#54
  def internal_error=(_arg0); end

  # source://ddtrace//lib/ddtrace/transport/statistics.rb#65
  def reset!; end

  # Returns the value of attribute server_error.
  #
  # source://ddtrace//lib/ddtrace/transport/statistics.rb#54
  def server_error; end

  # Sets the attribute server_error
  #
  # @param value the value to set the attribute server_error to.
  #
  # source://ddtrace//lib/ddtrace/transport/statistics.rb#54
  def server_error=(_arg0); end

  # Returns the value of attribute success.
  #
  # source://ddtrace//lib/ddtrace/transport/statistics.rb#54
  def success; end

  # Sets the attribute success
  #
  # @param value the value to set the attribute success to.
  #
  # source://ddtrace//lib/ddtrace/transport/statistics.rb#54
  def success=(_arg0); end
end

# Prepares traces for transport
#
# source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#12
class Datadog::Transport::TraceFormatter
  # @return [TraceFormatter] a new instance of TraceFormatter
  #
  # source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#21
  def initialize(trace); end

  # Modifies a trace so suitable for transport
  #
  # source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#27
  def format!; end

  # Returns the value of attribute root_span.
  #
  # source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#13
  def root_span; end

  # Returns the value of attribute trace.
  #
  # source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#13
  def trace; end

  protected

  # source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#61
  def set_resource!; end

  # source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#70
  def set_trace_tags!; end

  # source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#80
  def tag_agent_sample_rate!; end

  # source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#173
  def tag_high_order_trace_id!; end

  # source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#89
  def tag_hostname!; end

  # source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#98
  def tag_lang!; end

  # source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#107
  def tag_origin!; end

  # source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#116
  def tag_process_id!; end

  # source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#179
  def tag_profiling_enabled!; end

  # source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#122
  def tag_rate_limiter_rate!; end

  # source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#131
  def tag_rule_sample_rate!; end

  # source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#140
  def tag_runtime_id!; end

  # source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#149
  def tag_sample_rate!; end

  # source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#158
  def tag_sampling_decision_maker!; end

  # source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#164
  def tag_sampling_priority!; end

  private

  # source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#193
  def find_root_span(trace); end

  # @return [Boolean]
  #
  # source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#189
  def partial?; end

  class << self
    # source://ddtrace//lib/ddtrace/transport/trace_formatter.rb#17
    def format!(trace); end
  end
end

# source://ddtrace//lib/ddtrace/transport/traces.rb#9
module Datadog::Transport::Traces; end

# Traces chunker
#
# source://ddtrace//lib/ddtrace/transport/traces.rb#36
class Datadog::Transport::Traces::Chunker
  # Single traces larger than +max_size+ will be discarded.
  #
  # @param encoder [Datadog::Core::Encoding::Encoder]
  # @param max_size [String] maximum acceptable payload size
  # @return [Chunker] a new instance of Chunker
  #
  # source://ddtrace//lib/ddtrace/transport/traces.rb#50
  def initialize(encoder, max_size: T.unsafe(nil)); end

  # Encodes a list of traces in chunks.
  # Before serializing, all traces are normalized. Trace nesting is not changed.
  #
  # @param traces [Enumerable<Trace>] list of traces
  # @return [Enumerable[Array[Bytes,Integer]]] list of encoded chunks: each containing a byte array and
  #   number of traces
  #
  # source://ddtrace//lib/ddtrace/transport/traces.rb#61
  def encode_in_chunks(traces); end

  # Returns the value of attribute encoder.
  #
  # source://ddtrace//lib/ddtrace/transport/traces.rb#43
  def encoder; end

  # Returns the value of attribute max_size.
  #
  # source://ddtrace//lib/ddtrace/transport/traces.rb#43
  def max_size; end

  private

  # source://ddtrace//lib/ddtrace/transport/traces.rb#76
  def encode_one(trace); end
end

# Trace agent limit payload size of 10 MiB (since agent v5.11.0):
# https://github.com/DataDog/datadog-agent/blob/6.14.1/pkg/trace/api/api.go#L46
#
# We set the value to a conservative 5 MiB, in case network speed is slow.
#
# source://ddtrace//lib/ddtrace/transport/traces.rb#41
Datadog::Transport::Traces::Chunker::DEFAULT_MAX_PAYLOAD_SIZE = T.let(T.unsafe(nil), Integer)

# Data transfer object for encoded traces
#
# source://ddtrace//lib/ddtrace/transport/traces.rb#11
class Datadog::Transport::Traces::EncodedParcel
  include ::Datadog::Transport::Parcel

  # @return [EncodedParcel] a new instance of EncodedParcel
  #
  # source://ddtrace//lib/ddtrace/transport/traces.rb#16
  def initialize(data, trace_count); end

  # source://ddtrace//lib/ddtrace/transport/traces.rb#21
  def count; end

  # Returns the value of attribute trace_count.
  #
  # source://ddtrace//lib/ddtrace/transport/traces.rb#14
  def trace_count; end
end

# Encodes traces using {Datadog::Core::Encoding::Encoder} instances.
#
# source://ddtrace//lib/ddtrace/transport/traces.rb#92
module Datadog::Transport::Traces::Encoder
  private

  # source://ddtrace//lib/ddtrace/transport/traces.rb#95
  def encode_trace(encoder, trace); end

  class << self
    # source://ddtrace//lib/ddtrace/transport/traces.rb#95
    def encode_trace(encoder, trace); end
  end
end

# Traces request
#
# source://ddtrace//lib/ddtrace/transport/traces.rb#27
class Datadog::Transport::Traces::Request < ::Datadog::Transport::Request; end

# Traces response
#
# source://ddtrace//lib/ddtrace/transport/traces.rb#31
module Datadog::Transport::Traces::Response
  # Returns the value of attribute service_rates.
  #
  # source://ddtrace//lib/ddtrace/transport/traces.rb#32
  def service_rates; end

  # Returns the value of attribute trace_count.
  #
  # source://ddtrace//lib/ddtrace/transport/traces.rb#32
  def trace_count; end
end

# Sends traces based on transport API configuration.
#
# This class initializes the HTTP client, breaks down large
# batches of traces into smaller chunks and handles
# API version downgrade handshake.
#
# source://ddtrace//lib/ddtrace/transport/traces.rb#114
class Datadog::Transport::Traces::Transport
  # @return [Transport] a new instance of Transport
  #
  # source://ddtrace//lib/ddtrace/transport/traces.rb#117
  def initialize(apis, default_api); end

  # Returns the value of attribute apis.
  #
  # source://ddtrace//lib/ddtrace/transport/traces.rb#115
  def apis; end

  # Returns the value of attribute client.
  #
  # source://ddtrace//lib/ddtrace/transport/traces.rb#115
  def client; end

  # source://ddtrace//lib/ddtrace/transport/traces.rb#162
  def current_api; end

  # Returns the value of attribute current_api_id.
  #
  # source://ddtrace//lib/ddtrace/transport/traces.rb#115
  def current_api_id; end

  # Returns the value of attribute default_api.
  #
  # source://ddtrace//lib/ddtrace/transport/traces.rb#115
  def default_api; end

  # source://ddtrace//lib/ddtrace/transport/traces.rb#124
  def send_traces(traces); end

  # source://ddtrace//lib/ddtrace/transport/traces.rb#158
  def stats; end

  private

  # @raise [UnknownApiVersionError]
  #
  # source://ddtrace//lib/ddtrace/transport/traces.rb#181
  def change_api!(api_id); end

  # @raise [NoDowngradeAvailableError]
  #
  # source://ddtrace//lib/ddtrace/transport/traces.rb#174
  def downgrade!; end

  # @return [Boolean]
  #
  # source://ddtrace//lib/ddtrace/transport/traces.rb#168
  def downgrade?(response); end
end

# Raised when configured with an unknown API version
#
# source://ddtrace//lib/ddtrace/transport/traces.rb#202
class Datadog::Transport::Traces::Transport::NoDowngradeAvailableError < ::StandardError
  # @return [NoDowngradeAvailableError] a new instance of NoDowngradeAvailableError
  #
  # source://ddtrace//lib/ddtrace/transport/traces.rb#205
  def initialize(version); end

  # source://ddtrace//lib/ddtrace/transport/traces.rb#209
  def message; end

  # Returns the value of attribute version.
  #
  # source://ddtrace//lib/ddtrace/transport/traces.rb#203
  def version; end
end

# Raised when configured with an unknown API version
#
# source://ddtrace//lib/ddtrace/transport/traces.rb#189
class Datadog::Transport::Traces::Transport::UnknownApiVersionError < ::StandardError
  # @return [UnknownApiVersionError] a new instance of UnknownApiVersionError
  #
  # source://ddtrace//lib/ddtrace/transport/traces.rb#192
  def initialize(version); end

  # source://ddtrace//lib/ddtrace/transport/traces.rb#196
  def message; end

  # Returns the value of attribute version.
  #
  # source://ddtrace//lib/ddtrace/transport/traces.rb#190
  def version; end
end

# Railtie to include AutoInstrumentation in rails loading
#
# source://ddtrace//lib/datadog/tracing/contrib/rails/auto_instrument_railtie.rb#4
class DatadogAutoInstrumentRailtie < ::Rails::Railtie; end
